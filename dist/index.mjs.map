{"version":3,"sources":["../play-dl/Request/index.ts","../play-dl/YouTube/utils/cookie.ts","../play-dl/Request/useragent.ts","../play-dl/YouTube/classes/LiveStream.ts","../play-dl/YouTube/utils/cipher.ts","../play-dl/YouTube/classes/Channel.ts","../play-dl/YouTube/classes/Thumbnail.ts","../play-dl/YouTube/classes/Video.ts","../play-dl/YouTube/classes/Playlist.ts","../play-dl/YouTube/utils/extractor.ts","../play-dl/YouTube/classes/WebmSeeker.ts","../play-dl/YouTube/classes/SeekStream.ts","../play-dl/YouTube/stream.ts","../play-dl/YouTube/utils/parser.ts","../play-dl/YouTube/search.ts","../play-dl/Spotify/classes.ts","../play-dl/Spotify/index.ts","../play-dl/SoundCloud/index.ts","../play-dl/SoundCloud/classes.ts","../play-dl/Deezer/index.ts","../play-dl/Deezer/classes.ts","../play-dl/token.ts","../play-dl/index.ts"],"sourcesContent":["import { IncomingMessage } from 'node:http';\r\nimport { RequestOptions, request as httpsRequest } from 'node:https';\r\nimport { URL } from 'node:url';\r\nimport { BrotliDecompress, Deflate, Gunzip, createGunzip, createBrotliDecompress, createDeflate } from 'node:zlib';\r\nimport { cookieHeaders, getCookies } from '../YouTube/utils/cookie';\r\nimport { getRandomUserAgent } from './useragent';\r\n\r\ninterface RequestOpts extends RequestOptions {\r\n    body?: string;\r\n    method?: 'GET' | 'POST' | 'HEAD';\r\n    cookies?: boolean;\r\n    cookieJar?: { [key: string]: string };\r\n}\r\n\r\n/**\r\n * Main module which play-dl uses to make a request to stream url.\r\n * @param url URL to make https request to\r\n * @param options Request options for https request\r\n * @returns IncomingMessage from the request\r\n */\r\nexport function request_stream(req_url: string, options: RequestOpts = { method: 'GET' }): Promise<IncomingMessage> {\r\n    return new Promise(async (resolve, reject) => {\r\n        let res = await https_getter(req_url, options).catch((err: Error) => err);\r\n        if (res instanceof Error) {\r\n            reject(res);\r\n            return;\r\n        }\r\n        if (Number(res.statusCode) >= 300 && Number(res.statusCode) < 400) {\r\n            res = await request_stream(res.headers.location as string, options);\r\n        }\r\n        resolve(res);\r\n    });\r\n}\r\n/**\r\n * Makes a request and follows redirects if necessary\r\n * @param req_url URL to make https request to\r\n * @param options Request options for https request\r\n * @returns A promise with the final response object\r\n */\r\nfunction internalRequest(req_url: string, options: RequestOpts = { method: 'GET' }): Promise<IncomingMessage> {\r\n    return new Promise(async (resolve, reject) => {\r\n        let res = await https_getter(req_url, options).catch((err: Error) => err);\r\n        if (res instanceof Error) {\r\n            reject(res);\r\n            return;\r\n        }\r\n        if (Number(res.statusCode) >= 300 && Number(res.statusCode) < 400) {\r\n            res = await internalRequest(res.headers.location as string, options);\r\n        } else if (Number(res.statusCode) > 400) {\r\n            reject(new Error(`Got ${res.statusCode} from the request`));\r\n            return;\r\n        }\r\n        resolve(res);\r\n    });\r\n}\r\n/**\r\n * Main module which play-dl uses to make a request\r\n * @param url URL to make https request to\r\n * @param options Request options for https request\r\n * @returns body of that request\r\n */\r\nexport function request(req_url: string, options: RequestOpts = { method: 'GET' }): Promise<string> {\r\n    return new Promise(async (resolve, reject) => {\r\n        let cookies_added = false;\r\n        if (options.cookies) {\r\n            let cook = getCookies();\r\n            if (typeof cook === 'string' && options.headers) {\r\n                Object.assign(options.headers, { cookie: cook });\r\n                cookies_added = true;\r\n            }\r\n        }\r\n        if (options.cookieJar) {\r\n            const cookies = [];\r\n            for (const cookie of Object.entries(options.cookieJar)) {\r\n                cookies.push(cookie.join('='));\r\n            }\r\n\r\n            if (cookies.length !== 0) {\r\n                if (!options.headers) options.headers = {};\r\n                const existingCookies = cookies_added ? `; ${options.headers.cookie}` : '';\r\n                Object.assign(options.headers, { cookie: `${cookies.join('; ')}${existingCookies}` });\r\n            }\r\n        }\r\n        if (options.headers) {\r\n            options.headers = {\r\n                ...options.headers,\r\n                'accept-encoding': 'gzip, deflate, br',\r\n                'user-agent': getRandomUserAgent()\r\n            };\r\n        }\r\n        const res = await internalRequest(req_url, options).catch((err: Error) => err);\r\n        if (res instanceof Error) {\r\n            reject(res);\r\n            return;\r\n        }\r\n        if (res.headers && res.headers['set-cookie']) {\r\n            if (options.cookieJar) {\r\n                for (const cookie of res.headers['set-cookie']) {\r\n                    const parts = cookie.split(';')[0].trim().split('=');\r\n                    options.cookieJar[parts.shift() as string] = parts.join('=');\r\n                }\r\n            }\r\n            if (cookies_added) {\r\n                cookieHeaders(res.headers['set-cookie']);\r\n            }\r\n        }\r\n        const data: string[] = [];\r\n        let decoder: BrotliDecompress | Gunzip | Deflate | undefined = undefined;\r\n        const encoding = res.headers['content-encoding'];\r\n        if (encoding === 'gzip') decoder = createGunzip();\r\n        else if (encoding === 'br') decoder = createBrotliDecompress();\r\n        else if (encoding === 'deflate') decoder = createDeflate();\r\n\r\n        if (decoder) {\r\n            res.pipe(decoder);\r\n            decoder.setEncoding('utf-8');\r\n            decoder.on('data', (c) => data.push(c));\r\n            decoder.on('end', () => resolve(data.join('')));\r\n        } else {\r\n            res.setEncoding('utf-8');\r\n            res.on('data', (c) => data.push(c));\r\n            res.on('end', () => resolve(data.join('')));\r\n        }\r\n    });\r\n}\r\n\r\nexport function request_resolve_redirect(url: string): Promise<string> {\r\n    return new Promise(async (resolve, reject) => {\r\n        let res = await https_getter(url, { method: 'HEAD' }).catch((err: Error) => err);\r\n        if (res instanceof Error) {\r\n            reject(res);\r\n            return;\r\n        }\r\n        const statusCode = Number(res.statusCode);\r\n        if (statusCode < 300) {\r\n            resolve(url);\r\n        } else if (statusCode < 400) {\r\n            const resolved = await request_resolve_redirect(res.headers.location as string).catch((err) => err);\r\n            if (resolved instanceof Error) {\r\n                reject(resolved);\r\n                return;\r\n            }\r\n\r\n            resolve(resolved);\r\n        } else {\r\n            reject(new Error(`${res.statusCode}: ${res.statusMessage}, ${url}`));\r\n        }\r\n    });\r\n}\r\n\r\nexport function request_content_length(url: string): Promise<number> {\r\n    return new Promise(async (resolve, reject) => {\r\n        let res = await https_getter(url, { method: 'HEAD' }).catch((err: Error) => err);\r\n        if (res instanceof Error) {\r\n            reject(res);\r\n            return;\r\n        }\r\n        const statusCode = Number(res.statusCode);\r\n        if (statusCode < 300) {\r\n            resolve(Number(res.headers['content-length']));\r\n        } else if (statusCode < 400) {\r\n            const newURL = await request_resolve_redirect(res.headers.location as string).catch((err) => err);\r\n            if (newURL instanceof Error) {\r\n                reject(newURL);\r\n                return;\r\n            }\r\n\r\n            const res2 = await request_content_length(newURL).catch((err) => err);\r\n            if (res2 instanceof Error) {\r\n                reject(res2);\r\n                return;\r\n            }\r\n\r\n            resolve(res2);\r\n        } else {\r\n            reject(\r\n                new Error(`Failed to get content length with error: ${res.statusCode}, ${res.statusMessage}, ${url}`)\r\n            );\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Main module that play-dl uses for making a https request\r\n * @param req_url URL to make https request to\r\n * @param options Request options for https request\r\n * @returns Incoming Message from the https request\r\n */\r\nfunction https_getter(req_url: string, options: RequestOpts = {}): Promise<IncomingMessage> {\r\n    return new Promise((resolve, reject) => {\r\n        const s = new URL(req_url);\r\n        options.method ??= 'GET';\r\n        const req_options: RequestOptions = {\r\n            host: s.hostname,\r\n            path: s.pathname + s.search,\r\n            headers: options.headers ?? {},\r\n            method: options.method\r\n        };\r\n\r\n        const req = httpsRequest(req_options, resolve);\r\n        req.on('error', (err) => {\r\n            reject(err);\r\n        });\r\n        if (options.method === 'POST') req.write(options.body);\r\n        req.end();\r\n    });\r\n}\r\n","import { existsSync, readFileSync, writeFileSync } from 'node:fs';\r\n\r\nlet youtubeData: youtubeDataOptions;\r\nif (existsSync('.data/youtube.data')) {\r\n    youtubeData = JSON.parse(readFileSync('.data/youtube.data', 'utf-8'));\r\n    youtubeData.file = true;\r\n}\r\n\r\ninterface youtubeDataOptions {\r\n    cookie?: Object;\r\n    file?: boolean;\r\n}\r\n\r\nexport function getCookies(): undefined | string {\r\n    let result = '';\r\n    if (!youtubeData?.cookie) return undefined;\r\n    for (const [key, value] of Object.entries(youtubeData.cookie)) {\r\n        result += `${key}=${value};`;\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function setCookie(key: string, value: string): boolean {\r\n    if (!youtubeData?.cookie) return false;\r\n    key = key.trim();\r\n    value = value.trim();\r\n    Object.assign(youtubeData.cookie, { [key]: value });\r\n    return true;\r\n}\r\n\r\nexport function uploadCookie() {\r\n    if (youtubeData.cookie && youtubeData.file)\r\n        writeFileSync('.data/youtube.data', JSON.stringify(youtubeData, undefined, 4));\r\n}\r\n\r\nexport function setCookieToken(options: { cookie: string }) {\r\n    let cook = options.cookie;\r\n    let cookie: Object = {};\r\n    cook.split(';').forEach((x) => {\r\n        const arr = x.split('=');\r\n        if (arr.length <= 1) return;\r\n        const key = arr.shift()?.trim() as string;\r\n        const value = arr.join('=').trim();\r\n        Object.assign(cookie, { [key]: value });\r\n    });\r\n    youtubeData = { cookie };\r\n    youtubeData.file = false;\r\n}\r\n\r\n/**\r\n * Updates cookies locally either in file or in memory.\r\n *\r\n * Example\r\n * ```ts\r\n * const response = ... // Any https package get function.\r\n *\r\n * play.cookieHeaders(response.headers['set-cookie'])\r\n * ```\r\n * @param headCookie response headers['set-cookie'] array\r\n * @returns Nothing\r\n */\r\nexport function cookieHeaders(headCookie: string[]): void {\r\n    if (!youtubeData?.cookie) return;\r\n    headCookie.forEach((x: string) => {\r\n        x.split(';').forEach((z) => {\r\n            const arr = z.split('=');\r\n            if (arr.length <= 1) return;\r\n            const key = arr.shift()?.trim() as string;\r\n            const value = arr.join('=').trim();\r\n            setCookie(key, value);\r\n        });\r\n    });\r\n    uploadCookie();\r\n}\r\n","import useragents from './useragents.json';\r\n\r\nexport function setUserAgent(array: string[]): void {\r\n    useragents.push(...array);\r\n}\r\n\r\nfunction getRandomInt(min: number, max: number): number {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function getRandomUserAgent() {\r\n    const random = getRandomInt(0, useragents.length - 1);\r\n    return useragents[random];\r\n}\r\n","import { Readable } from 'node:stream';\r\nimport { IncomingMessage } from 'node:http';\r\nimport { parseAudioFormats, StreamOptions, StreamType } from '../stream';\r\nimport { request, request_stream } from '../../Request';\r\nimport { video_stream_info } from '../utils/extractor';\r\nimport { URL } from 'node:url';\r\n\r\n/**\r\n * YouTube Live Stream class for playing audio from Live Stream videos.\r\n */\r\nexport class LiveStream {\r\n    /**\r\n     * Readable Stream through which data passes\r\n     */\r\n    stream: Readable;\r\n    /**\r\n     * Type of audio data that we recieved from live stream youtube url.\r\n     */\r\n    type: StreamType;\r\n    /**\r\n     * Incoming message that we recieve.\r\n     *\r\n     * Storing this is essential.\r\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\r\n     */\r\n    private request?: IncomingMessage;\r\n    /**\r\n     * Timer that creates loop from interval time provided.\r\n     */\r\n    private normal_timer?: Timer;\r\n    /**\r\n     * Timer used to update dash url so as to avoid 404 errors after long hours of streaming.\r\n     *\r\n     * It updates dash_url every 30 minutes.\r\n     */\r\n    private dash_timer: Timer;\r\n    /**\r\n     * Given Dash URL.\r\n     */\r\n    private dash_url: string;\r\n    /**\r\n     * Base URL in dash manifest file.\r\n     */\r\n    private base_url: string;\r\n    /**\r\n     * Interval to fetch data again to dash url.\r\n     */\r\n    private interval: number;\r\n    /**\r\n     * Timer used to update dash url so as to avoid 404 errors after long hours of streaming.\r\n     *\r\n     * It updates dash_url every 30 minutes.\r\n     */\r\n    private video_url: string;\r\n    /**\r\n     * No of segments of data to add in stream before starting to loop\r\n     */\r\n    private precache: number;\r\n    /**\r\n     * Segment sequence number\r\n     */\r\n    private sequence: number;\r\n    /**\r\n     * Live Stream Class Constructor\r\n     * @param dash_url dash manifest URL\r\n     * @param target_interval interval time for fetching dash data again\r\n     * @param video_url Live Stream video url.\r\n     */\r\n    constructor(dash_url: string, interval: number, video_url: string, precache?: number) {\r\n        this.stream = new Readable({ highWaterMark: 5 * 1000 * 1000, read() {} });\r\n        this.type = StreamType.Arbitrary;\r\n        this.sequence = 0;\r\n        this.dash_url = dash_url;\r\n        this.base_url = '';\r\n        this.interval = interval;\r\n        this.video_url = video_url;\r\n        this.precache = precache || 3;\r\n        this.dash_timer = new Timer(() => {\r\n            this.dash_updater();\r\n            this.dash_timer.reuse();\r\n        }, 1800);\r\n        this.stream.on('close', () => {\r\n            this.cleanup();\r\n        });\r\n        this.initialize_dash();\r\n    }\r\n    /**\r\n     * This cleans every used variable in class.\r\n     *\r\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\r\n     */\r\n    private cleanup() {\r\n        this.normal_timer?.destroy();\r\n        this.dash_timer.destroy();\r\n        this.request?.destroy();\r\n        this.video_url = '';\r\n        this.request = undefined;\r\n        this.dash_url = '';\r\n        this.base_url = '';\r\n        this.interval = 0;\r\n    }\r\n    /**\r\n     * Updates dash url.\r\n     *\r\n     * Used by dash_timer for updating dash_url every 30 minutes.\r\n     */\r\n    private async dash_updater() {\r\n        const info = await video_stream_info(this.video_url);\r\n        if (info.LiveStreamData.dashManifestUrl) this.dash_url = info.LiveStreamData.dashManifestUrl;\r\n        return this.initialize_dash();\r\n    }\r\n    /**\r\n     * Initializes dash after getting dash url.\r\n     *\r\n     * Start if it is first time of initialishing dash function.\r\n     */\r\n    private async initialize_dash() {\r\n        const response = await request(this.dash_url);\r\n        const audioFormat = response\r\n            .split('<AdaptationSet id=\"0\"')[1]\r\n            .split('</AdaptationSet>')[0]\r\n            .split('</Representation>');\r\n        if (audioFormat[audioFormat.length - 1] === '') audioFormat.pop();\r\n        this.base_url = audioFormat[audioFormat.length - 1].split('<BaseURL>')[1].split('</BaseURL>')[0];\r\n        await request_stream(`https://${new URL(this.base_url).host}/generate_204`);\r\n        if (this.sequence === 0) {\r\n            const list = audioFormat[audioFormat.length - 1]\r\n                .split('<SegmentList>')[1]\r\n                .split('</SegmentList>')[0]\r\n                .replaceAll('<SegmentURL media=\"', '')\r\n                .split('\"/>');\r\n            if (list[list.length - 1] === '') list.pop();\r\n            if (list.length > this.precache) list.splice(0, list.length - this.precache);\r\n            this.sequence = Number(list[0].split('sq/')[1].split('/')[0]);\r\n            this.first_data(list.length);\r\n        }\r\n    }\r\n    /**\r\n     * Used only after initializing dash function first time.\r\n     * @param len Length of data that you want to\r\n     */\r\n    private async first_data(len: number) {\r\n        for (let i = 1; i <= len; i++) {\r\n            await new Promise(async (resolve) => {\r\n                const stream = await request_stream(this.base_url + 'sq/' + this.sequence).catch((err: Error) => err);\r\n                if (stream instanceof Error) {\r\n                    this.stream.emit('error', stream);\r\n                    return;\r\n                }\r\n                this.request = stream;\r\n                stream.on('data', (c) => {\r\n                    this.stream.push(c);\r\n                });\r\n                stream.on('end', () => {\r\n                    this.sequence++;\r\n                    resolve('');\r\n                });\r\n                stream.once('error', (err) => {\r\n                    this.stream.emit('error', err);\r\n                });\r\n            });\r\n        }\r\n        this.normal_timer = new Timer(() => {\r\n            this.loop();\r\n            this.normal_timer?.reuse();\r\n        }, this.interval);\r\n    }\r\n    /**\r\n     * This loops function in Live Stream Class.\r\n     *\r\n     * Gets next segment and push it.\r\n     */\r\n    private loop() {\r\n        return new Promise(async (resolve) => {\r\n            const stream = await request_stream(this.base_url + 'sq/' + this.sequence).catch((err: Error) => err);\r\n            if (stream instanceof Error) {\r\n                this.stream.emit('error', stream);\r\n                return;\r\n            }\r\n            this.request = stream;\r\n            stream.on('data', (c) => {\r\n                this.stream.push(c);\r\n            });\r\n            stream.on('end', () => {\r\n                this.sequence++;\r\n                resolve('');\r\n            });\r\n            stream.once('error', (err) => {\r\n                this.stream.emit('error', err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Deprecated Functions\r\n     */\r\n    pause() {}\r\n    /**\r\n     * Deprecated Functions\r\n     */\r\n    resume() {}\r\n}\r\n/**\r\n * YouTube Stream Class for playing audio from normal videos.\r\n */\r\nexport class Stream {\r\n    /**\r\n     * Readable Stream through which data passes\r\n     */\r\n    stream: Readable;\r\n    /**\r\n     * Type of audio data that we recieved from normal youtube url.\r\n     */\r\n    type: StreamType;\r\n    /**\r\n     * Audio Endpoint Format Url to get data from.\r\n     */\r\n    private url: string;\r\n    /**\r\n     * Used to calculate no of bytes data that we have recieved\r\n     */\r\n    private bytes_count: number;\r\n    /**\r\n     * Calculate per second bytes by using contentLength (Total bytes) / Duration (in seconds)\r\n     */\r\n    private per_sec_bytes: number;\r\n    /**\r\n     * Total length of audio file in bytes\r\n     */\r\n    private content_length: number;\r\n    /**\r\n     * YouTube video url. [ Used only for retrying purposes only. ]\r\n     */\r\n    private video_url: string;\r\n    /**\r\n     * Timer for looping data every 265 seconds.\r\n     */\r\n    private timer: Timer;\r\n    /**\r\n     * Quality given by user. [ Used only for retrying purposes only. ]\r\n     */\r\n    private quality: number;\r\n    /**\r\n     * Incoming message that we recieve.\r\n     *\r\n     * Storing this is essential.\r\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\r\n     */\r\n    private request: IncomingMessage | null;\r\n    /**\r\n     * YouTube Stream Class constructor\r\n     * @param url Audio Endpoint url.\r\n     * @param type Type of Stream\r\n     * @param duration Duration of audio playback [ in seconds ]\r\n     * @param contentLength Total length of Audio file in bytes.\r\n     * @param video_url YouTube video url.\r\n     * @param options Options provided to stream function.\r\n     */\r\n    constructor(\r\n        url: string,\r\n        type: StreamType,\r\n        duration: number,\r\n        contentLength: number,\r\n        video_url: string,\r\n        options: StreamOptions\r\n    ) {\r\n        this.stream = new Readable({ highWaterMark: 5 * 1000 * 1000, read() {} });\r\n        this.url = url;\r\n        this.quality = options.quality as number;\r\n        this.type = type;\r\n        this.bytes_count = 0;\r\n        this.video_url = video_url;\r\n        this.per_sec_bytes = Math.ceil(contentLength / duration);\r\n        this.content_length = contentLength;\r\n        this.request = null;\r\n        this.timer = new Timer(() => {\r\n            this.timer.reuse();\r\n            this.loop();\r\n        }, 265);\r\n        this.stream.on('close', () => {\r\n            this.timer.destroy();\r\n            this.cleanup();\r\n        });\r\n        this.loop();\r\n    }\r\n    /**\r\n     * Retry if we get 404 or 403 Errors.\r\n     */\r\n    private async retry() {\r\n        const info = await video_stream_info(this.video_url);\r\n        const audioFormat = parseAudioFormats(info.format);\r\n        this.url = audioFormat[this.quality].url;\r\n    }\r\n    /**\r\n     * This cleans every used variable in class.\r\n     *\r\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\r\n     */\r\n    private cleanup() {\r\n        this.request?.destroy();\r\n        this.request = null;\r\n        this.url = '';\r\n    }\r\n    /**\r\n     * Getting data from audio endpoint url and passing it to stream.\r\n     *\r\n     * If 404 or 403 occurs, it will retry again.\r\n     */\r\n    private async loop() {\r\n        if (this.stream.destroyed) {\r\n            this.timer.destroy();\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        const end: number = this.bytes_count + this.per_sec_bytes * 300;\r\n        const stream = await request_stream(this.url, {\r\n            headers: {\r\n                range: `bytes=${this.bytes_count}-${end >= this.content_length ? '' : end}`\r\n            }\r\n        }).catch((err: Error) => err);\r\n        if (stream instanceof Error) {\r\n            this.stream.emit('error', stream);\r\n            this.bytes_count = 0;\r\n            this.per_sec_bytes = 0;\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        if (Number(stream.statusCode) >= 400) {\r\n            this.cleanup();\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            this.loop();\r\n            return;\r\n        }\r\n        this.request = stream;\r\n        stream.on('data', (c) => {\r\n            this.stream.push(c);\r\n        });\r\n\r\n        stream.once('error', async () => {\r\n            this.cleanup();\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            this.loop();\r\n        });\r\n\r\n        stream.on('data', (chunk: any) => {\r\n            this.bytes_count += chunk.length;\r\n        });\r\n\r\n        stream.on('end', () => {\r\n            if (end >= this.content_length) {\r\n                this.timer.destroy();\r\n                this.stream.push(null);\r\n                this.cleanup();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Pauses timer.\r\n     * Stops running of loop.\r\n     *\r\n     * Useful if you don't want to get excess data to be stored in stream.\r\n     */\r\n    pause() {\r\n        this.timer.pause();\r\n    }\r\n    /**\r\n     * Resumes timer.\r\n     * Starts running of loop.\r\n     */\r\n    resume() {\r\n        this.timer.resume();\r\n    }\r\n}\r\n/**\r\n * Timer Class.\r\n *\r\n * setTimeout + extra features ( re-starting, pausing, resuming ).\r\n */\r\nexport class Timer {\r\n    /**\r\n     * Boolean for checking if Timer is destroyed or not.\r\n     */\r\n    private destroyed: boolean;\r\n    /**\r\n     * Boolean for checking if Timer is paused or not.\r\n     */\r\n    private paused: boolean;\r\n    /**\r\n     * setTimeout function\r\n     */\r\n    private timer: NodeJS.Timer;\r\n    /**\r\n     * Callback to be executed once timer finishes.\r\n     */\r\n    private callback: () => void;\r\n    /**\r\n     * Seconds time when it is started.\r\n     */\r\n    private time_start: number;\r\n    /**\r\n     * Total time left.\r\n     */\r\n    private time_left: number;\r\n    /**\r\n     * Total time given by user [ Used only for re-using timer. ]\r\n     */\r\n    private time_total: number;\r\n    /**\r\n     * Constructor for Timer Class\r\n     * @param callback Function to execute when timer is up.\r\n     * @param time Total time to wait before execution.\r\n     */\r\n    constructor(callback: () => void, time: number) {\r\n        this.callback = callback;\r\n        this.time_total = time;\r\n        this.time_left = time;\r\n        this.paused = false;\r\n        this.destroyed = false;\r\n        this.time_start = process.hrtime()[0];\r\n        this.timer = setTimeout(this.callback, this.time_total * 1000);\r\n    }\r\n    /**\r\n     * Pauses Timer\r\n     * @returns Boolean to tell that if it is paused or not.\r\n     */\r\n    pause() {\r\n        if (!this.paused && !this.destroyed) {\r\n            this.paused = true;\r\n            clearTimeout(this.timer);\r\n            this.time_left = this.time_left - (process.hrtime()[0] - this.time_start);\r\n            return true;\r\n        } else return false;\r\n    }\r\n    /**\r\n     * Resumes Timer\r\n     * @returns Boolean to tell that if it is resumed or not.\r\n     */\r\n    resume() {\r\n        if (this.paused && !this.destroyed) {\r\n            this.paused = false;\r\n            this.time_start = process.hrtime()[0];\r\n            this.timer = setTimeout(this.callback, this.time_left * 1000);\r\n            return true;\r\n        } else return false;\r\n    }\r\n    /**\r\n     * Reusing of timer\r\n     * @returns Boolean to tell if it is re-used or not.\r\n     */\r\n    reuse() {\r\n        if (!this.destroyed) {\r\n            clearTimeout(this.timer);\r\n            this.time_left = this.time_total;\r\n            this.paused = false;\r\n            this.time_start = process.hrtime()[0];\r\n            this.timer = setTimeout(this.callback, this.time_total * 1000);\r\n            return true;\r\n        } else return false;\r\n    }\r\n    /**\r\n     * Destroy timer.\r\n     *\r\n     * It can't be used again.\r\n     */\r\n    destroy() {\r\n        clearTimeout(this.timer);\r\n        this.destroyed = true;\r\n        this.callback = () => {};\r\n        this.time_total = 0;\r\n        this.time_left = 0;\r\n        this.paused = false;\r\n        this.time_start = 0;\r\n    }\r\n}\r\n","import { URL, URLSearchParams } from 'node:url';\r\nimport { request } from './../../Request';\r\n\r\ninterface formatOptions {\r\n    url?: string;\r\n    sp?: string;\r\n    signatureCipher?: string;\r\n    cipher?: string;\r\n    s?: string;\r\n}\r\n// RegExp for various js functions\r\nconst var_js = '[a-zA-Z_\\\\$]\\\\w*';\r\nconst singlequote_js = `'[^'\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^'\\\\\\\\]*)*'`;\r\nconst duoblequote_js = `\"[^\"\\\\\\\\]*(:?\\\\\\\\[\\\\s\\\\S][^\"\\\\\\\\]*)*\"`;\r\nconst quote_js = `(?:${singlequote_js}|${duoblequote_js})`;\r\nconst key_js = `(?:${var_js}|${quote_js})`;\r\nconst prop_js = `(?:\\\\.${var_js}|\\\\[${quote_js}\\\\])`;\r\nconst empty_js = `(?:''|\"\")`;\r\nconst reverse_function = ':function\\\\(a\\\\)\\\\{' + '(?:return )?a\\\\.reverse\\\\(\\\\)' + '\\\\}';\r\nconst slice_function = ':function\\\\(a,b\\\\)\\\\{' + 'return a\\\\.slice\\\\(b\\\\)' + '\\\\}';\r\nconst splice_function = ':function\\\\(a,b\\\\)\\\\{' + 'a\\\\.splice\\\\(0,b\\\\)' + '\\\\}';\r\nconst swap_function =\r\n    ':function\\\\(a,b\\\\)\\\\{' +\r\n    'var c=a\\\\[0\\\\];a\\\\[0\\\\]=a\\\\[b(?:%a\\\\.length)?\\\\];a\\\\[b(?:%a\\\\.length)?\\\\]=c(?:;return a)?' +\r\n    '\\\\}';\r\nconst obj_regexp = new RegExp(\r\n    `var (${var_js})=\\\\{((?:(?:${key_js}${reverse_function}|${key_js}${slice_function}|${key_js}${splice_function}|${key_js}${swap_function}),?\\\\r?\\\\n?)+)\\\\};`\r\n);\r\nconst function_regexp = new RegExp(\r\n    `${\r\n        `function(?: ${var_js})?\\\\(a\\\\)\\\\{` + `a=a\\\\.split\\\\(${empty_js}\\\\);\\\\s*` + `((?:(?:a=)?${var_js}`\r\n    }${prop_js}\\\\(a,\\\\d+\\\\);)+)` +\r\n        `return a\\\\.join\\\\(${empty_js}\\\\)` +\r\n        `\\\\}`\r\n);\r\nconst reverse_regexp = new RegExp(`(?:^|,)(${key_js})${reverse_function}`, 'm');\r\nconst slice_regexp = new RegExp(`(?:^|,)(${key_js})${slice_function}`, 'm');\r\nconst splice_regexp = new RegExp(`(?:^|,)(${key_js})${splice_function}`, 'm');\r\nconst swap_regexp = new RegExp(`(?:^|,)(${key_js})${swap_function}`, 'm');\r\n/**\r\n * Function to get tokens from html5player body data.\r\n * @param body body data of html5player.\r\n * @returns Array of tokens.\r\n */\r\nfunction js_tokens(body: string) {\r\n    const function_action = function_regexp.exec(body);\r\n    const object_action = obj_regexp.exec(body);\r\n    if (!function_action || !object_action) return null;\r\n\r\n    const object = object_action[1].replace(/\\$/g, '\\\\$');\r\n    const object_body = object_action[2].replace(/\\$/g, '\\\\$');\r\n    const function_body = function_action[1].replace(/\\$/g, '\\\\$');\r\n\r\n    let result = reverse_regexp.exec(object_body);\r\n    const reverseKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\r\n\r\n    result = slice_regexp.exec(object_body);\r\n    const sliceKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\r\n\r\n    result = splice_regexp.exec(object_body);\r\n    const spliceKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\r\n\r\n    result = swap_regexp.exec(object_body);\r\n    const swapKey = result && result[1].replace(/\\$/g, '\\\\$').replace(/\\$|^'|^\"|'$|\"$/g, '');\r\n\r\n    const keys = `(${[reverseKey, sliceKey, spliceKey, swapKey].join('|')})`;\r\n    const myreg = `(?:a=)?${object}(?:\\\\.${keys}|\\\\['${keys}'\\\\]|\\\\[\"${keys}\"\\\\])` + `\\\\(a,(\\\\d+)\\\\)`;\r\n    const tokenizeRegexp = new RegExp(myreg, 'g');\r\n    const tokens = [];\r\n    while ((result = tokenizeRegexp.exec(function_body)) !== null) {\r\n        const key = result[1] || result[2] || result[3];\r\n        switch (key) {\r\n            case swapKey:\r\n                tokens.push(`sw${result[4]}`);\r\n                break;\r\n            case reverseKey:\r\n                tokens.push('rv');\r\n                break;\r\n            case sliceKey:\r\n                tokens.push(`sl${result[4]}`);\r\n                break;\r\n            case spliceKey:\r\n                tokens.push(`sp${result[4]}`);\r\n                break;\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n/**\r\n * Function to decipher signature\r\n * @param tokens Tokens from js_tokens function\r\n * @param signature Signatured format url\r\n * @returns deciphered signature\r\n */\r\nfunction deciper_signature(tokens: string[], signature: string) {\r\n    let sig = signature.split('');\r\n    const len = tokens.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let token = tokens[i],\r\n            pos;\r\n        switch (token.slice(0, 2)) {\r\n            case 'sw':\r\n                pos = parseInt(token.slice(2));\r\n                swappositions(sig, pos);\r\n                break;\r\n            case 'rv':\r\n                sig.reverse();\r\n                break;\r\n            case 'sl':\r\n                pos = parseInt(token.slice(2));\r\n                sig = sig.slice(pos);\r\n                break;\r\n            case 'sp':\r\n                pos = parseInt(token.slice(2));\r\n                sig.splice(0, pos);\r\n                break;\r\n        }\r\n    }\r\n    return sig.join('');\r\n}\r\n/**\r\n * Function to swap positions in a array\r\n * @param array array\r\n * @param position position to switch with first element\r\n */\r\nfunction swappositions(array: string[], position: number) {\r\n    const first = array[0];\r\n    array[0] = array[position];\r\n    array[position] = first;\r\n}\r\n/**\r\n * Sets Download url with some extra parameter\r\n * @param format video fomat\r\n * @param sig deciphered signature\r\n * @returns void\r\n */\r\nfunction download_url(format: formatOptions, sig: string) {\r\n    if (!format.url) return;\r\n\r\n    const decoded_url = decodeURIComponent(format.url);\r\n\r\n    const parsed_url = new URL(decoded_url);\r\n    parsed_url.searchParams.set('ratebypass', 'yes');\r\n\r\n    if (sig) {\r\n        parsed_url.searchParams.set(format.sp || 'signature', sig);\r\n    }\r\n    format.url = parsed_url.toString();\r\n}\r\n/**\r\n * Main function which handles all queries related to video format deciphering\r\n * @param formats video formats\r\n * @param html5player url of html5player\r\n * @returns array of format.\r\n */\r\nexport async function format_decipher(formats: formatOptions[], html5player: string): Promise<formatOptions[]> {\r\n    const body = await request(html5player);\r\n    const tokens = js_tokens(body);\r\n    formats.forEach((format) => {\r\n        const cipher = format.signatureCipher || format.cipher;\r\n        if (cipher) {\r\n            const params = Object.fromEntries(new URLSearchParams(cipher));\r\n            Object.assign(format, params);\r\n            delete format.signatureCipher;\r\n            delete format.cipher;\r\n        }\r\n        if (tokens && format.s) {\r\n            const sig = deciper_signature(tokens, format.s);\r\n            download_url(format, sig);\r\n            delete format.s;\r\n            delete format.sp;\r\n        }\r\n    });\r\n    return formats;\r\n}\r\n","export interface ChannelIconInterface {\r\n    /**\r\n     * YouTube Channel Icon URL\r\n     */\r\n    url: string;\r\n    /**\r\n     * YouTube Channel Icon Width\r\n     */\r\n    width: number;\r\n    /**\r\n     * YouTube Channel Icon Height\r\n     */\r\n    height: number;\r\n}\r\n/**\r\n * YouTube Channel Class\r\n */\r\nexport class YouTubeChannel {\r\n    /**\r\n     * YouTube Channel Title\r\n     */\r\n    name?: string;\r\n    /**\r\n     * YouTube Channel Verified status.\r\n     */\r\n    verified?: boolean;\r\n    /**\r\n     * YouTube Channel artist if any.\r\n     */\r\n    artist?: boolean;\r\n    /**\r\n     * YouTube Channel ID.\r\n     */\r\n    id?: string;\r\n    /**\r\n     * YouTube Class type. == \"channel\"\r\n     */\r\n    type: 'video' | 'playlist' | 'channel';\r\n    /**\r\n     * YouTube Channel Url\r\n     */\r\n    url?: string;\r\n    /**\r\n     * YouTube Channel Icons data.\r\n     */\r\n    icons?: ChannelIconInterface[];\r\n    /**\r\n     * YouTube Channel subscribers count.\r\n     */\r\n    subscribers?: string;\r\n    /**\r\n     * YouTube Channel Constructor\r\n     * @param data YouTube Channel data that we recieve from basic info or from search\r\n     */\r\n    constructor(data: any = {}) {\r\n        if (!data) throw new Error(`Cannot instantiate the ${this.constructor.name} class without data!`);\r\n        this.type = 'channel';\r\n        this.name = data.name || null;\r\n        this.verified = !!data.verified || false;\r\n        this.artist = !!data.artist || false;\r\n        this.id = data.id || null;\r\n        this.url = data.url || null;\r\n        this.icons = data.icons || [{ url: null, width: 0, height: 0 }];\r\n        this.subscribers = data.subscribers || null;\r\n    }\r\n\r\n    /**\r\n     * Returns channel icon url\r\n     * @param {object} options Icon options\r\n     * @param {number} [options.size=0] Icon size. **Default is 0**\r\n     */\r\n    iconURL(options = { size: 0 }): string | undefined {\r\n        if (typeof options.size !== 'number' || options.size < 0) throw new Error('invalid icon size');\r\n        if (!this.icons?.[0]?.url) return undefined;\r\n        const def = this.icons?.[0]?.url.split('=s')[1].split('-c')[0];\r\n        return this.icons?.[0]?.url.replace(`=s${def}-c`, `=s${options.size}-c`);\r\n    }\r\n    /**\r\n     * Converts Channel Class to channel name.\r\n     * @returns name of channel\r\n     */\r\n    toString(): string {\r\n        return this.name || '';\r\n    }\r\n    /**\r\n     * Converts Channel Class to JSON format\r\n     * @returns json data of the channel\r\n     */\r\n    toJSON(): ChannelJSON {\r\n        return {\r\n            name: this.name,\r\n            verified: this.verified,\r\n            artist: this.artist,\r\n            id: this.id,\r\n            url: this.url,\r\n            icons: this.icons,\r\n            type: this.type,\r\n            subscribers: this.subscribers\r\n        };\r\n    }\r\n}\r\n\r\ninterface ChannelJSON {\r\n    /**\r\n     * YouTube Channel Title\r\n     */\r\n    name?: string;\r\n    /**\r\n     * YouTube Channel Verified status.\r\n     */\r\n    verified?: boolean;\r\n    /**\r\n     * YouTube Channel artist if any.\r\n     */\r\n    artist?: boolean;\r\n    /**\r\n     * YouTube Channel ID.\r\n     */\r\n    id?: string;\r\n    /**\r\n     * Type of Class [ Channel ]\r\n     */\r\n    type: 'video' | 'playlist' | 'channel';\r\n    /**\r\n     * YouTube Channel Url\r\n     */\r\n    url?: string;\r\n    /**\r\n     * YouTube Channel Icon data.\r\n     */\r\n    icons?: ChannelIconInterface[];\r\n    /**\r\n     * YouTube Channel subscribers count.\r\n     */\r\n    subscribers?: string;\r\n}\r\n","export class YouTubeThumbnail {\r\n    url: string;\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor(data: any) {\r\n        this.url = data.url;\r\n        this.width = data.width;\r\n        this.height = data.height;\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            url: this.url,\r\n            width: this.width,\r\n            height: this.height\r\n        };\r\n    }\r\n}\r\n","import { YouTubeChannel } from './Channel';\r\nimport { YouTubeThumbnail } from './Thumbnail';\r\n\r\n/**\r\n * Licensed music in the video\r\n * \r\n * The property names change depending on your region's language.\r\n */\r\ninterface VideoMusic {\r\n    song?: string;\r\n    url?: string | null;\r\n    artist?: string;\r\n    album?: string;\r\n    writers?: string;\r\n    licenses?: string;\r\n}\r\n\r\ninterface VideoOptions {\r\n    /**\r\n     * YouTube Video ID\r\n     */\r\n    id?: string;\r\n    /**\r\n     * YouTube video url\r\n     */\r\n    url: string;\r\n    /**\r\n     * YouTube Video title\r\n     */\r\n    title?: string;\r\n    /**\r\n     * YouTube Video description.\r\n     */\r\n    description?: string;\r\n    /**\r\n     * YouTube Video Duration Formatted\r\n     */\r\n    durationRaw: string;\r\n    /**\r\n     * YouTube Video Duration in seconds\r\n     */\r\n    durationInSec: number;\r\n    /**\r\n     * YouTube Video Uploaded Date\r\n     */\r\n    uploadedAt?: string;\r\n    /**\r\n     * If the video is upcoming or a premiere that isn't currently live, this will contain the premiere date, for watch page playlists this will be true, it defaults to undefined\r\n     */\r\n    upcoming?: Date | true;\r\n    /**\r\n     * YouTube Views\r\n     */\r\n    views: number;\r\n    /**\r\n     * YouTube Thumbnail Data\r\n     */\r\n    thumbnail?: {\r\n        width: number | undefined;\r\n        height: number | undefined;\r\n        url: string | undefined;\r\n    };\r\n    /**\r\n     * YouTube Video's uploader Channel Data\r\n     */\r\n    channel?: YouTubeChannel;\r\n    /**\r\n     * YouTube Video's likes\r\n     */\r\n    likes: number;\r\n    /**\r\n     * YouTube Video live status\r\n     */\r\n    live: boolean;\r\n    /**\r\n     * YouTube Video private status\r\n     */\r\n    private: boolean;\r\n    /**\r\n     * YouTube Video tags\r\n     */\r\n    tags: string[];\r\n    /**\r\n     * `true` if the video has been identified by the YouTube community as inappropriate or offensive to some audiences and viewer discretion is advised\r\n     */\r\n    discretionAdvised?: boolean;\r\n    /**\r\n     * Gives info about music content in that video.\r\n     * \r\n     * The property names of VideoMusic change depending on your region's language.\r\n     */\r\n    music?: VideoMusic[];\r\n    /**\r\n     * The chapters for this video\r\n     *\r\n     * If the video doesn't have any chapters or if the video object wasn't created by {@link video_basic_info} or {@link video_info} this will be an empty array.\r\n     */\r\n    chapters: VideoChapter[];\r\n}\r\n\r\nexport interface VideoChapter {\r\n    /**\r\n     * The title of the chapter\r\n     */\r\n    title: string;\r\n    /**\r\n     * The timestamp of the start of the chapter\r\n     */\r\n    timestamp: string;\r\n    /**\r\n     * The start of the chapter in seconds\r\n     */\r\n    seconds: number;\r\n    /**\r\n     * Thumbnails of the frame at the start of this chapter\r\n     */\r\n    thumbnails: YouTubeThumbnail[];\r\n}\r\n\r\n/**\r\n * Class for YouTube Video url\r\n */\r\nexport class YouTubeVideo {\r\n    /**\r\n     * YouTube Video ID\r\n     */\r\n    id?: string;\r\n    /**\r\n     * YouTube video url\r\n     */\r\n    url: string;\r\n    /**\r\n     * YouTube Class type. == \"video\"\r\n     */\r\n    type: 'video' | 'playlist' | 'channel';\r\n    /**\r\n     * YouTube Video title\r\n     */\r\n    title?: string;\r\n    /**\r\n     * YouTube Video description.\r\n     */\r\n    description?: string;\r\n    /**\r\n     * YouTube Video Duration Formatted\r\n     */\r\n    durationRaw: string;\r\n    /**\r\n     * YouTube Video Duration in seconds\r\n     */\r\n    durationInSec: number;\r\n    /**\r\n     * YouTube Video Uploaded Date\r\n     */\r\n    uploadedAt?: string;\r\n    /**\r\n     * YouTube Live Date\r\n     */\r\n    liveAt?: string;\r\n    /**\r\n     * If the video is upcoming or a premiere that isn't currently live, this will contain the premiere date, for watch page playlists this will be true, it defaults to undefined\r\n     */\r\n    upcoming?: Date | true;\r\n    /**\r\n     * YouTube Views\r\n     */\r\n    views: number;\r\n    /**\r\n     * YouTube Thumbnail Data\r\n     */\r\n    thumbnails: YouTubeThumbnail[];\r\n    /**\r\n     * YouTube Video's uploader Channel Data\r\n     */\r\n    channel?: YouTubeChannel;\r\n    /**\r\n     * YouTube Video's likes\r\n     */\r\n    likes: number;\r\n    /**\r\n     * YouTube Video live status\r\n     */\r\n    live: boolean;\r\n    /**\r\n     * YouTube Video private status\r\n     */\r\n    private: boolean;\r\n    /**\r\n     * YouTube Video tags\r\n     */\r\n    tags: string[];\r\n    /**\r\n     * `true` if the video has been identified by the YouTube community as inappropriate or offensive to some audiences and viewer discretion is advised\r\n     */\r\n    discretionAdvised?: boolean;\r\n    /**\r\n     * Gives info about music content in that video.\r\n     */\r\n    music?: VideoMusic[];\r\n    /**\r\n     * The chapters for this video\r\n     *\r\n     * If the video doesn't have any chapters or if the video object wasn't created by {@link video_basic_info} or {@link video_info} this will be an empty array.\r\n     */\r\n    chapters: VideoChapter[];\r\n    /**\r\n     * Constructor for YouTube Video Class\r\n     * @param data JSON parsed data.\r\n     */\r\n    constructor(data: any) {\r\n        if (!data) throw new Error(`Can not initiate ${this.constructor.name} without data`);\r\n\r\n        this.id = data.id || undefined;\r\n        this.url = `https://www.youtube.com/watch?v=${this.id}`;\r\n        this.type = 'video';\r\n        this.title = data.title || undefined;\r\n        this.description = data.description || undefined;\r\n        this.durationRaw = data.duration_raw || '0:00';\r\n        this.durationInSec = (data.duration < 0 ? 0 : data.duration) || 0;\r\n        this.uploadedAt = data.uploadedAt || undefined;\r\n        this.liveAt = data.liveAt || undefined;\r\n        this.upcoming = data.upcoming;\r\n        this.views = parseInt(data.views) || 0;\r\n        const thumbnails = [];\r\n        for (const thumb of data.thumbnails) {\r\n            thumbnails.push(new YouTubeThumbnail(thumb));\r\n        }\r\n        this.thumbnails = thumbnails || [];\r\n        this.channel = new YouTubeChannel(data.channel) || {};\r\n        this.likes = data.likes || 0;\r\n        this.live = !!data.live;\r\n        this.private = !!data.private;\r\n        this.tags = data.tags || [];\r\n        this.discretionAdvised = data.discretionAdvised ?? undefined;\r\n        this.music = data.music || [];\r\n        this.chapters = data.chapters || [];\r\n    }\r\n    /**\r\n     * Converts class to title name of video.\r\n     * @returns Title name\r\n     */\r\n    toString(): string {\r\n        return this.url || '';\r\n    }\r\n    /**\r\n     * Converts class to JSON data\r\n     * @returns JSON data.\r\n     */\r\n    toJSON(): VideoOptions {\r\n        return {\r\n            id: this.id,\r\n            url: this.url,\r\n            title: this.title,\r\n            description: this.description,\r\n            durationInSec: this.durationInSec,\r\n            durationRaw: this.durationRaw,\r\n            uploadedAt: this.uploadedAt,\r\n            thumbnail: this.thumbnails[this.thumbnails.length - 1].toJSON() || this.thumbnails,\r\n            channel: this.channel,\r\n            views: this.views,\r\n            tags: this.tags,\r\n            likes: this.likes,\r\n            live: this.live,\r\n            private: this.private,\r\n            discretionAdvised: this.discretionAdvised,\r\n            music: this.music,\r\n            chapters: this.chapters\r\n        };\r\n    }\r\n}\r\n","import { getPlaylistVideos, getContinuationToken } from '../utils/extractor';\r\nimport { request } from '../../Request';\r\nimport { YouTubeChannel } from './Channel';\r\nimport { YouTubeVideo } from './Video';\r\nimport { YouTubeThumbnail } from './Thumbnail';\r\nconst BASE_API = 'https://www.youtube.com/youtubei/v1/browse?key=';\r\n/**\r\n * YouTube Playlist Class containing vital informations about playlist.\r\n */\r\nexport class YouTubePlayList {\r\n    /**\r\n     * YouTube Playlist ID\r\n     */\r\n    id?: string;\r\n    /**\r\n     * YouTube Playlist Name\r\n     */\r\n    title?: string;\r\n    /**\r\n     * YouTube Class type. == \"playlist\"\r\n     */\r\n    type: 'video' | 'playlist' | 'channel';\r\n    /**\r\n     * Total no of videos in that playlist\r\n     */\r\n    videoCount?: number;\r\n    /**\r\n     * Time when playlist was last updated\r\n     */\r\n    lastUpdate?: string;\r\n    /**\r\n     * Total views of that playlist\r\n     */\r\n    views?: number;\r\n    /**\r\n     * YouTube Playlist url\r\n     */\r\n    url?: string;\r\n    /**\r\n     * YouTube Playlist url with starting video url.\r\n     */\r\n    link?: string;\r\n    /**\r\n     * YouTube Playlist channel data\r\n     */\r\n    channel?: YouTubeChannel;\r\n    /**\r\n     * YouTube Playlist thumbnail Data\r\n     */\r\n    thumbnail?: YouTubeThumbnail;\r\n    /**\r\n     * Videos array containing data of first 100 videos\r\n     */\r\n    private videos?: YouTubeVideo[];\r\n    /**\r\n     * Map contaning data of all fetched videos\r\n     */\r\n    private fetched_videos: Map<string, YouTubeVideo[]>;\r\n    /**\r\n     * Token containing API key, Token, ClientVersion.\r\n     */\r\n    private _continuation: {\r\n        api?: string;\r\n        token?: string;\r\n        clientVersion?: string;\r\n    } = {};\r\n    /**\r\n     * Total no of pages count.\r\n     */\r\n    private __count: number;\r\n    /**\r\n     * Constructor for YouTube Playlist Class\r\n     * @param data Json Parsed YouTube Playlist data\r\n     * @param searchResult If the data is from search or not\r\n     */\r\n    constructor(data: any, searchResult = false) {\r\n        if (!data) throw new Error(`Cannot instantiate the ${this.constructor.name} class without data!`);\r\n        this.__count = 0;\r\n        this.fetched_videos = new Map();\r\n        this.type = 'playlist';\r\n        if (searchResult) this.__patchSearch(data);\r\n        else this.__patch(data);\r\n    }\r\n    /**\r\n     * Updates variable according to a normal data.\r\n     * @param data Json Parsed YouTube Playlist data\r\n     */\r\n    private __patch(data: any) {\r\n        this.id = data.id || undefined;\r\n        this.url = data.url || undefined;\r\n        this.title = data.title || undefined;\r\n        this.videoCount = data.videoCount || 0;\r\n        this.lastUpdate = data.lastUpdate || undefined;\r\n        this.views = data.views || 0;\r\n        this.link = data.link || undefined;\r\n        this.channel = new YouTubeChannel(data.channel) || undefined;\r\n        this.thumbnail = data.thumbnail ? new YouTubeThumbnail(data.thumbnail) : undefined;\r\n        this.videos = data.videos || [];\r\n        this.__count++;\r\n        this.fetched_videos.set(`${this.__count}`, this.videos as YouTubeVideo[]);\r\n        this._continuation.api = data.continuation?.api ?? undefined;\r\n        this._continuation.token = data.continuation?.token ?? undefined;\r\n        this._continuation.clientVersion = data.continuation?.clientVersion ?? '<important data>';\r\n    }\r\n    /**\r\n     * Updates variable according to a searched data.\r\n     * @param data Json Parsed YouTube Playlist data\r\n     */\r\n    private __patchSearch(data: any) {\r\n        this.id = data.id || undefined;\r\n        this.url = this.id ? `https://www.youtube.com/playlist?list=${this.id}` : undefined;\r\n        this.title = data.title || undefined;\r\n        this.thumbnail = new YouTubeThumbnail(data.thumbnail) || undefined;\r\n        this.channel = data.channel || undefined;\r\n        this.videos = [];\r\n        this.videoCount = data.videos || 0;\r\n        this.link = undefined;\r\n        this.lastUpdate = undefined;\r\n        this.views = 0;\r\n    }\r\n    /**\r\n     * Parses next segment of videos from playlist and returns parsed data.\r\n     * @param limit Total no of videos to parse.\r\n     *\r\n     * Default = Infinity\r\n     * @returns Array of YouTube Video Class\r\n     */\r\n    async next(limit = Infinity): Promise<YouTubeVideo[]> {\r\n        if (!this._continuation || !this._continuation.token) return [];\r\n\r\n        const nextPage = await request(`${BASE_API}${this._continuation.api}&prettyPrint=false`, {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                continuation: this._continuation.token,\r\n                context: {\r\n                    client: {\r\n                        utcOffsetMinutes: 0,\r\n                        gl: 'US',\r\n                        hl: 'en',\r\n                        clientName: 'WEB',\r\n                        clientVersion: this._continuation.clientVersion\r\n                    },\r\n                    user: {},\r\n                    request: {}\r\n                }\r\n            })\r\n        });\r\n\r\n        const contents =\r\n            JSON.parse(nextPage)?.onResponseReceivedActions[0]?.appendContinuationItemsAction?.continuationItems;\r\n        if (!contents) return [];\r\n\r\n        const playlist_videos = getPlaylistVideos(contents, limit);\r\n        this.fetched_videos.set(`${this.__count}`, playlist_videos);\r\n        this._continuation.token = getContinuationToken(contents);\r\n        return playlist_videos;\r\n    }\r\n    /**\r\n     * Fetches remaining data from playlist\r\n     *\r\n     * For fetching and getting all songs data, see `total_pages` property.\r\n     * @param max Max no of videos to fetch\r\n     *\r\n     * Default = Infinity\r\n     * @returns\r\n     */\r\n    async fetch(max = Infinity): Promise<YouTubePlayList> {\r\n        const continuation = this._continuation.token;\r\n        if (!continuation) return this;\r\n        if (max < 1) max = Infinity;\r\n\r\n        while (typeof this._continuation.token === 'string' && this._continuation.token.length) {\r\n            this.__count++;\r\n            const res = await this.next();\r\n            max -= res.length;\r\n            if (max <= 0) break;\r\n            if (!res.length) break;\r\n        }\r\n\r\n        return this;\r\n    }\r\n    /**\r\n     * YouTube Playlists are divided into pages.\r\n     *\r\n     * For example, if you want to get 101 - 200 songs\r\n     *\r\n     * ```ts\r\n     * const playlist = await play.playlist_info('playlist url')\r\n     *\r\n     * await playlist.fetch()\r\n     *\r\n     * const result = playlist.page(2)\r\n     * ```\r\n     * @param number Page number\r\n     * @returns Array of YouTube Video Class\r\n     * @see {@link YouTubePlayList.all_videos}\r\n     */\r\n    page(number: number): YouTubeVideo[] {\r\n        if (!number) throw new Error('Page number is not provided');\r\n        if (!this.fetched_videos.has(`${number}`)) throw new Error('Given Page number is invalid');\r\n        return this.fetched_videos.get(`${number}`) as YouTubeVideo[];\r\n    }\r\n    /**\r\n     * Gets total number of pages in that playlist class.\r\n     * @see {@link YouTubePlayList.all_videos}\r\n     */\r\n    get total_pages() {\r\n        return this.fetched_videos.size;\r\n    }\r\n    /**\r\n     * This tells total number of videos that have been fetched so far.\r\n     *\r\n     * This can be equal to videosCount if all videos in playlist have been fetched and they are not hidden.\r\n     */\r\n    get total_videos() {\r\n        const page_number: number = this.total_pages;\r\n        return (page_number - 1) * 100 + (this.fetched_videos.get(`${page_number}`) as YouTubeVideo[]).length;\r\n    }\r\n    /**\r\n     * Fetches all the videos in the playlist and returns them\r\n     *\r\n     * ```ts\r\n     * const playlist = await play.playlist_info('playlist url')\r\n     *\r\n     * const videos = await playlist.all_videos()\r\n     * ```\r\n     * @returns An array of {@link YouTubeVideo} objects\r\n     * @see {@link YouTubePlayList.fetch}\r\n     */\r\n    async all_videos(): Promise<YouTubeVideo[]> {\r\n        await this.fetch();\r\n\r\n        const videos = [];\r\n\r\n        for (const page of this.fetched_videos.values()) videos.push(...page);\r\n\r\n        return videos;\r\n    }\r\n    /**\r\n     * Converts Playlist Class to a json parsed data.\r\n     * @returns\r\n     */\r\n    toJSON(): PlaylistJSON {\r\n        return {\r\n            id: this.id,\r\n            title: this.title,\r\n            thumbnail: this.thumbnail?.toJSON() || this.thumbnail,\r\n            channel: this.channel,\r\n            url: this.url,\r\n            videos: this.videos\r\n        };\r\n    }\r\n}\r\n\r\ninterface PlaylistJSON {\r\n    /**\r\n     * YouTube Playlist ID\r\n     */\r\n    id?: string;\r\n    /**\r\n     * YouTube Playlist Name\r\n     */\r\n    title?: string;\r\n    /**\r\n     * Total no of videos in that playlist\r\n     */\r\n    videoCount?: number;\r\n    /**\r\n     * Time when playlist was last updated\r\n     */\r\n    lastUpdate?: string;\r\n    /**\r\n     * Total views of that playlist\r\n     */\r\n    views?: number;\r\n    /**\r\n     * YouTube Playlist url\r\n     */\r\n    url?: string;\r\n    /**\r\n     * YouTube Playlist url with starting video url.\r\n     */\r\n    link?: string;\r\n    /**\r\n     * YouTube Playlist channel data\r\n     */\r\n    channel?: YouTubeChannel;\r\n    /**\r\n     * YouTube Playlist thumbnail Data\r\n     */\r\n    thumbnail?: {\r\n        width: number | undefined;\r\n        height: number | undefined;\r\n        url: string | undefined;\r\n    };\r\n    /**\r\n     * first 100 videos in that playlist\r\n     */\r\n    videos?: YouTubeVideo[];\r\n}\r\n","import { request } from './../../Request/index';\r\nimport { format_decipher } from './cipher';\r\nimport { VideoChapter, YouTubeVideo } from '../classes/Video';\r\nimport { YouTubePlayList } from '../classes/Playlist';\r\nimport { InfoData, StreamInfoData } from './constants';\r\nimport { URL, URLSearchParams } from 'node:url';\r\nimport { parseAudioFormats } from '../stream';\r\n\r\ninterface InfoOptions {\r\n    htmldata?: boolean;\r\n    language?: string;\r\n}\r\n\r\ninterface PlaylistOptions {\r\n    incomplete?: boolean;\r\n    language?: string;\r\n}\r\n\r\nconst video_id_pattern = /^[a-zA-Z\\d_-]{11,12}$/;\r\nconst playlist_id_pattern = /^(PL|UU|LL|RD|OL)[a-zA-Z\\d_-]{10,}$/;\r\nconst DEFAULT_API_KEY = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8';\r\nconst video_pattern =\r\n    /^((?:https?:)?\\/\\/)?(?:(?:www|m|music)\\.)?((?:youtube\\.com|youtu.be))(\\/(?:[\\w\\-]+\\?v=|shorts\\/|embed\\/|v\\/)?)([\\w\\-]+)(\\S+)?$/;\r\nconst playlist_pattern =\r\n    /^((?:https?:)?\\/\\/)?(?:(?:www|m|music)\\.)?((?:youtube\\.com|youtu.be))\\/(?:(playlist|watch))?(.*)?((\\?|\\&)list=)(PL|UU|LL|RD|OL)[a-zA-Z\\d_-]{10,}(&.*)?$/;\r\n/**\r\n * Validate YouTube URL or ID.\r\n *\r\n * **CAUTION :** If your search word is 11 or 12 characters long, you might get it validated as video ID.\r\n *\r\n * To avoid above, add one more condition to yt_validate\r\n * ```ts\r\n * if (url.startsWith('https') && yt_validate(url) === 'video') {\r\n *      // YouTube Video Url.\r\n * }\r\n * ```\r\n * @param url YouTube URL OR ID\r\n * @returns\r\n * ```\r\n * 'playlist' | 'video' | 'search' | false\r\n * ```\r\n */\r\nexport function yt_validate(url: string): 'playlist' | 'video' | 'search' | false {\r\n    const url_ = url.trim();\r\n    if (url_.indexOf('list=') === -1) {\r\n        if (url_.startsWith('https')) {\r\n            if (url_.match(video_pattern)) {\r\n                let id: string;\r\n                if (url_.includes('youtu.be/')) id = url_.split('youtu.be/')[1].split(/(\\?|\\/|&)/)[0];\r\n                else if (url_.includes('youtube.com/embed/'))\r\n                    id = url_.split('youtube.com/embed/')[1].split(/(\\?|\\/|&)/)[0];\r\n                else if (url_.includes('youtube.com/shorts/'))\r\n                    id = url_.split('youtube.com/shorts/')[1].split(/(\\?|\\/|&)/)[0];\r\n                else id = url_.split('watch?v=')[1]?.split(/(\\?|\\/|&)/)[0];\r\n                if (id?.match(video_id_pattern)) return 'video';\r\n                else return false;\r\n            } else return false;\r\n        } else {\r\n            if (url_.match(video_id_pattern)) return 'video';\r\n            else if (url_.match(playlist_id_pattern)) return 'playlist';\r\n            else return 'search';\r\n        }\r\n    } else {\r\n        if (!url_.match(playlist_pattern)) return yt_validate(url_.replace(/(\\?|\\&)list=[^&]*/, ''));\r\n        else return 'playlist';\r\n    }\r\n}\r\n/**\r\n * Extracts the video ID from a YouTube URL.\r\n *\r\n * Will return the value of `urlOrId` if it looks like a video ID.\r\n * @param urlOrId A YouTube URL or video ID\r\n * @returns the video ID or `false` if it can't find a video ID.\r\n */\r\nfunction extractVideoId(urlOrId: string): string | false {\r\n    if (urlOrId.startsWith('https://') && urlOrId.match(video_pattern)) {\r\n        let id: string;\r\n        if (urlOrId.includes('youtu.be/')) {\r\n            id = urlOrId.split('youtu.be/')[1].split(/(\\?|\\/|&)/)[0];\r\n        } else if (urlOrId.includes('youtube.com/embed/')) {\r\n            id = urlOrId.split('youtube.com/embed/')[1].split(/(\\?|\\/|&)/)[0];\r\n        } else if (urlOrId.includes('youtube.com/shorts/')) {\r\n            id = urlOrId.split('youtube.com/shorts/')[1].split(/(\\?|\\/|&)/)[0];\r\n        } else {\r\n            id = (urlOrId.split('watch?v=')[1] ?? urlOrId.split('&v=')[1]).split(/(\\?|\\/|&)/)[0];\r\n        }\r\n\r\n        if (id.match(video_id_pattern)) return id;\r\n    } else if (urlOrId.match(video_id_pattern)) {\r\n        return urlOrId;\r\n    }\r\n\r\n    return false;\r\n}\r\n/**\r\n * Extract ID of YouTube url.\r\n * @param url ID or url of YouTube\r\n * @returns ID of video or playlist.\r\n */\r\nexport function extractID(url: string): string {\r\n    const check = yt_validate(url);\r\n    if (!check || check === 'search') throw new Error('This is not a YouTube url or videoId or PlaylistID');\r\n    const url_ = url.trim();\r\n    if (url_.startsWith('https')) {\r\n        if (url_.indexOf('list=') === -1) {\r\n            const video_id = extractVideoId(url_);\r\n            if (!video_id) throw new Error('This is not a YouTube url or videoId or PlaylistID');\r\n            return video_id;\r\n        } else {\r\n            return url_.split('list=')[1].split('&')[0];\r\n        }\r\n    } else return url_;\r\n}\r\n/**\r\n * Basic function to get data from a YouTube url or ID.\r\n *\r\n * Example\r\n * ```ts\r\n * const video = await play.video_basic_info('youtube video url')\r\n *\r\n * const res = ... // Any https package get function.\r\n *\r\n * const video = await play.video_basic_info(res.body, { htmldata : true })\r\n * ```\r\n * @param url YouTube url or ID or html body data\r\n * @param options Video Info Options\r\n *  - `boolean` htmldata : given data is html data or not\r\n * @returns Video Basic Info {@link InfoData}.\r\n */\r\nexport async function video_basic_info(url: string, options: InfoOptions = {}): Promise<InfoData> {\r\n    if (typeof url !== 'string') throw new Error('url parameter is not a URL string or a string of HTML');\r\n    const url_ = url.trim();\r\n    let body: string;\r\n    const cookieJar = {};\r\n    if (options.htmldata) {\r\n        body = url_;\r\n    } else {\r\n        const video_id = extractVideoId(url_);\r\n        if (!video_id) throw new Error('This is not a YouTube Watch URL');\r\n        const new_url = `https://www.youtube.com/watch?v=${video_id}&has_verified=1`;\r\n        body = await request(new_url, {\r\n            headers: {\r\n                'accept-language': options.language || 'en-US;q=0.9'\r\n            },\r\n            cookies: true,\r\n            cookieJar\r\n        });\r\n    }\r\n    if (body.indexOf('Our systems have detected unusual traffic from your computer network.') !== -1)\r\n        throw new Error('Captcha page: YouTube has detected that you are a bot!');\r\n    const player_data = body\r\n        .split('var ytInitialPlayerResponse = ')?.[1]\r\n        ?.split(';</script>')[0]\r\n        .split(/(?<=}}});\\s*(var|const|let)\\s/)[0];\r\n    if (!player_data) throw new Error('Initial Player Response Data is undefined.');\r\n    const initial_data = body\r\n        .split('var ytInitialData = ')?.[1]\r\n        ?.split(';</script>')[0]\r\n        .split(/;\\s*(var|const|let)\\s/)[0];\r\n    if (!initial_data) throw new Error('Initial Response Data is undefined.');\r\n    const player_response = JSON.parse(player_data);\r\n    const initial_response = JSON.parse(initial_data);\r\n    const vid = player_response.videoDetails;\r\n\r\n    let discretionAdvised = false;\r\n    let upcoming = false;\r\n    if (player_response.playabilityStatus.status !== 'OK') {\r\n        if (player_response.playabilityStatus.status === 'CONTENT_CHECK_REQUIRED') {\r\n            if (options.htmldata)\r\n                throw new Error(\r\n                    `Accepting the viewer discretion is not supported when using htmldata, video: ${vid.videoId}`\r\n                );\r\n            discretionAdvised = true;\r\n            const cookies =\r\n                initial_response.topbar.desktopTopbarRenderer.interstitial?.consentBumpV2Renderer.agreeButton\r\n                    .buttonRenderer.command.saveConsentAction;\r\n            if (cookies) {\r\n                Object.assign(cookieJar, {\r\n                    VISITOR_INFO1_LIVE: cookies.visitorCookie,\r\n                    CONSENT: cookies.consentCookie\r\n                });\r\n            }\r\n\r\n            const updatedValues = await acceptViewerDiscretion(vid.videoId, cookieJar, body, true);\r\n            player_response.streamingData = updatedValues.streamingData;\r\n            initial_response.contents.twoColumnWatchNextResults.secondaryResults = updatedValues.relatedVideos;\r\n        } else if (player_response.playabilityStatus.status === 'LIVE_STREAM_OFFLINE') upcoming = true;\r\n        else\r\n            throw new Error(\r\n                `While getting info from url\\n${\r\n                    player_response.playabilityStatus.errorScreen.playerErrorMessageRenderer?.reason.simpleText ??\r\n                    player_response.playabilityStatus.errorScreen.playerKavRenderer?.reason.simpleText ??\r\n                    player_response.playabilityStatus.reason\r\n                }`\r\n            );\r\n    }\r\n    const ownerInfo =\r\n        initial_response.contents.twoColumnWatchNextResults.results?.results?.contents[1]?.videoSecondaryInfoRenderer\r\n            ?.owner?.videoOwnerRenderer;\r\n    const badge = ownerInfo?.badges?.[0]?.metadataBadgeRenderer?.style?.toLowerCase();\r\n    const html5player = `https://www.youtube.com${body.split('\"jsUrl\":\"')[1].split('\"')[0]}`;\r\n    const related: string[] = [];\r\n    initial_response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results.forEach(\r\n        (res: any) => {\r\n            if (res.compactVideoRenderer)\r\n                related.push(`https://www.youtube.com/watch?v=${res.compactVideoRenderer.videoId}`);\r\n            if (res.itemSectionRenderer?.contents)\r\n                res.itemSectionRenderer.contents.forEach((x: any) => {\r\n                    if (x.compactVideoRenderer)\r\n                        related.push(`https://www.youtube.com/watch?v=${x.compactVideoRenderer.videoId}`);\r\n                });\r\n        }\r\n    );\r\n    const microformat = player_response.microformat.playerMicroformatRenderer;\r\n    const musicInfo = initial_response.engagementPanels.find((item: any) => item?.engagementPanelSectionListRenderer?.panelIdentifier == 'engagement-panel-structured-description')?.engagementPanelSectionListRenderer.content.structuredDescriptionContentRenderer.items\r\n        .find((el: any) => el.videoDescriptionMusicSectionRenderer)?.videoDescriptionMusicSectionRenderer.carouselLockups;\r\n\r\n    const music: any[] = [];\r\n    if (musicInfo) {\r\n        musicInfo.forEach((x: any) => {\r\n            if (!x.carouselLockupRenderer) return;\r\n            const row = x.carouselLockupRenderer;\r\n\r\n            const song = row.videoLockup?.compactVideoRenderer.title.simpleText ?? row.videoLockup?.compactVideoRenderer.title.runs?.find((x:any) => x.text)?.text;\r\n            const metadata = row.infoRows?.map((info: any) => [info.infoRowRenderer.title.simpleText.toLowerCase(), ((info.infoRowRenderer.expandedMetadata ?? info.infoRowRenderer.defaultMetadata)?.runs?.map((i:any) => i.text).join(\"\")) ?? info.infoRowRenderer.defaultMetadata?.simpleText ?? info.infoRowRenderer.expandedMetadata?.simpleText ?? \"\"]);\r\n            const contents = Object.fromEntries(metadata ?? {});\r\n            const id = row.videoLockup?.compactVideoRenderer.navigationEndpoint?.watchEndpoint.videoId\r\n                ?? row.infoRows?.find((x: any) => x.infoRowRenderer.title.simpleText.toLowerCase() == \"song\")?.infoRowRenderer.defaultMetadata.runs?.find((x: any) => x.navigationEndpoint)?.navigationEndpoint.watchEndpoint?.videoId;\r\n\r\n            music.push({song, url: id ? `https://www.youtube.com/watch?v=${id}` : null, ...contents})\r\n        });\r\n    }\r\n    const rawChapters =\r\n        initial_response.playerOverlays.playerOverlayRenderer.decoratedPlayerBarRenderer?.decoratedPlayerBarRenderer.playerBar?.multiMarkersPlayerBarRenderer.markersMap.find(\r\n            (m: any) => m.key === 'DESCRIPTION_CHAPTERS'\r\n        )?.value?.chapters;\r\n    const chapters: VideoChapter[] = [];\r\n    if (rawChapters) {\r\n        for (const { chapterRenderer } of rawChapters) {\r\n            chapters.push({\r\n                title: chapterRenderer.title.simpleText,\r\n                timestamp: parseSeconds(chapterRenderer.timeRangeStartMillis / 1000),\r\n                seconds: chapterRenderer.timeRangeStartMillis / 1000,\r\n                thumbnails: chapterRenderer.thumbnail.thumbnails\r\n            });\r\n        }\r\n    }\r\n    let upcomingDate;\r\n    if (upcoming) {\r\n        if (microformat.liveBroadcastDetails.startTimestamp)\r\n            upcomingDate = new Date(microformat.liveBroadcastDetails.startTimestamp);\r\n        else {\r\n            const timestamp =\r\n                player_response.playabilityStatus.liveStreamability.liveStreamabilityRenderer.offlineSlate\r\n                    .liveStreamOfflineSlateRenderer.scheduledStartTime;\r\n            upcomingDate = new Date(parseInt(timestamp) * 1000);\r\n        }\r\n    }\r\n\r\n    const likeRenderer = initial_response.contents.twoColumnWatchNextResults.results.results.contents\r\n        .find((content: any) => content.videoPrimaryInfoRenderer)\r\n        ?.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons?.find(\r\n            (button: any) => button.toggleButtonRenderer?.defaultIcon.iconType === 'LIKE' || button.segmentedLikeDislikeButtonRenderer?.likeButton.toggleButtonRenderer?.defaultIcon.iconType === 'LIKE'\r\n        )\r\n\r\n    const video_details = new YouTubeVideo({\r\n        id: vid.videoId,\r\n        title: vid.title,\r\n        description: vid.shortDescription,\r\n        duration: Number(vid.lengthSeconds),\r\n        duration_raw: parseSeconds(vid.lengthSeconds),\r\n        uploadedAt: microformat.publishDate,\r\n        liveAt: microformat.liveBroadcastDetails?.startTimestamp,\r\n        upcoming: upcomingDate,\r\n        thumbnails: vid.thumbnail.thumbnails,\r\n        channel: {\r\n            name: vid.author,\r\n            id: vid.channelId,\r\n            url: `https://www.youtube.com/channel/${vid.channelId}`,\r\n            verified: Boolean(badge?.includes('verified')),\r\n            artist: Boolean(badge?.includes('artist')),\r\n            icons: ownerInfo?.thumbnail?.thumbnails || undefined\r\n        },\r\n        views: vid.viewCount,\r\n        tags: vid.keywords,\r\n        likes: parseInt(\r\n            likeRenderer?.toggleButtonRenderer?.defaultText.accessibility?.accessibilityData.label.replace(/\\D+/g, '') ?? \r\n            likeRenderer?.segmentedLikeDislikeButtonRenderer?.likeButton.toggleButtonRenderer?.defaultText.accessibility?.accessibilityData.label.replace(/\\D+/g, '') ?? 0\r\n        ),\r\n        live: vid.isLiveContent,\r\n        private: vid.isPrivate,\r\n        discretionAdvised,\r\n        music,\r\n        chapters\r\n    });\r\n    let format = [];\r\n    if (!upcoming) {\r\n        format.push(...(player_response.streamingData.formats ?? []));\r\n        format.push(...(player_response.streamingData.adaptiveFormats ?? []));\r\n\r\n        // get the formats for the android player for legacy videos\r\n        // fixes the stream being closed because not enough data\r\n        // arrived in time for ffmpeg to be able to extract audio data\r\n        if (parseAudioFormats(format).length === 0 && !options.htmldata) {\r\n            format = await getAndroidFormats(vid.videoId, cookieJar, body);\r\n        }\r\n    }\r\n    const LiveStreamData = {\r\n        isLive: video_details.live,\r\n        dashManifestUrl: player_response.streamingData?.dashManifestUrl ?? null,\r\n        hlsManifestUrl: player_response.streamingData?.hlsManifestUrl ?? null\r\n    };\r\n    return {\r\n        LiveStreamData,\r\n        html5player,\r\n        format,\r\n        video_details,\r\n        related_videos: related\r\n    };\r\n}\r\n/**\r\n * Gets the data required for streaming from YouTube url, ID or html body data and deciphers it.\r\n *\r\n * Internal function used by {@link stream} instead of {@link video_info}\r\n * because it only extracts the information required for streaming.\r\n *\r\n * @param url YouTube url or ID or html body data\r\n * @param options Video Info Options\r\n *  - `boolean` htmldata : given data is html data or not\r\n * @returns Deciphered Video Info {@link StreamInfoData}.\r\n */\r\nexport async function video_stream_info(url: string, options: InfoOptions = {}): Promise<StreamInfoData> {\r\n    if (typeof url !== 'string') throw new Error('url parameter is not a URL string or a string of HTML');\r\n    let body: string;\r\n    const cookieJar = {};\r\n    if (options.htmldata) {\r\n        body = url;\r\n    } else {\r\n        const video_id = extractVideoId(url);\r\n        if (!video_id) throw new Error('This is not a YouTube Watch URL');\r\n        const new_url = `https://www.youtube.com/watch?v=${video_id}&has_verified=1`;\r\n        body = await request(new_url, {\r\n            headers: { 'accept-language': 'en-US,en;q=0.9' },\r\n            cookies: true,\r\n            cookieJar\r\n        });\r\n    }\r\n    if (body.indexOf('Our systems have detected unusual traffic from your computer network.') !== -1)\r\n        throw new Error('Captcha page: YouTube has detected that you are a bot!');\r\n    const player_data = body\r\n        .split('var ytInitialPlayerResponse = ')?.[1]\r\n        ?.split(';</script>')[0]\r\n        .split(/(?<=}}});\\s*(var|const|let)\\s/)[0];\r\n    if (!player_data) throw new Error('Initial Player Response Data is undefined.');\r\n    const player_response = JSON.parse(player_data);\r\n    let upcoming = false;\r\n    if (player_response.playabilityStatus.status !== 'OK') {\r\n        if (player_response.playabilityStatus.status === 'CONTENT_CHECK_REQUIRED') {\r\n            if (options.htmldata)\r\n                throw new Error(\r\n                    `Accepting the viewer discretion is not supported when using htmldata, video: ${player_response.videoDetails.videoId}`\r\n                );\r\n\r\n            const initial_data = body\r\n                .split('var ytInitialData = ')?.[1]\r\n                ?.split(';</script>')[0]\r\n                .split(/;\\s*(var|const|let)\\s/)[0];\r\n            if (!initial_data) throw new Error('Initial Response Data is undefined.');\r\n\r\n            const cookies =\r\n                JSON.parse(initial_data).topbar.desktopTopbarRenderer.interstitial?.consentBumpV2Renderer.agreeButton\r\n                    .buttonRenderer.command.saveConsentAction;\r\n            if (cookies) {\r\n                Object.assign(cookieJar, {\r\n                    VISITOR_INFO1_LIVE: cookies.visitorCookie,\r\n                    CONSENT: cookies.consentCookie\r\n                });\r\n            }\r\n\r\n            const updatedValues = await acceptViewerDiscretion(\r\n                player_response.videoDetails.videoId,\r\n                cookieJar,\r\n                body,\r\n                false\r\n            );\r\n            player_response.streamingData = updatedValues.streamingData;\r\n        } else if (player_response.playabilityStatus.status === 'LIVE_STREAM_OFFLINE') upcoming = true;\r\n        else\r\n            throw new Error(\r\n                `While getting info from url\\n${\r\n                    player_response.playabilityStatus.errorScreen.playerErrorMessageRenderer?.reason.simpleText ??\r\n                    player_response.playabilityStatus.errorScreen.playerKavRenderer?.reason.simpleText ??\r\n                    player_response.playabilityStatus.reason\r\n                }`\r\n            );\r\n    }\r\n    const html5player = `https://www.youtube.com${body.split('\"jsUrl\":\"')[1].split('\"')[0]}`;\r\n    const duration = Number(player_response.videoDetails.lengthSeconds);\r\n    const video_details = {\r\n        url: `https://www.youtube.com/watch?v=${player_response.videoDetails.videoId}`,\r\n        durationInSec: (duration < 0 ? 0 : duration) || 0\r\n    };\r\n    let format = [];\r\n    if (!upcoming) {\r\n        format.push(...(player_response.streamingData.formats ?? []));\r\n        format.push(...(player_response.streamingData.adaptiveFormats ?? []));\r\n\r\n        // get the formats for the android player for legacy videos\r\n        // fixes the stream being closed because not enough data\r\n        // arrived in time for ffmpeg to be able to extract audio data\r\n        if (parseAudioFormats(format).length === 0 && !options.htmldata) {\r\n            format = await getAndroidFormats(player_response.videoDetails.videoId, cookieJar, body);\r\n        }\r\n    }\r\n\r\n    const LiveStreamData = {\r\n        isLive: player_response.videoDetails.isLiveContent,\r\n        dashManifestUrl: player_response.streamingData?.dashManifestUrl ?? null,\r\n        hlsManifestUrl: player_response.streamingData?.hlsManifestUrl ?? null\r\n    };\r\n    return await decipher_info(\r\n        {\r\n            LiveStreamData,\r\n            html5player,\r\n            format,\r\n            video_details\r\n        },\r\n        true\r\n    );\r\n}\r\n/**\r\n * Function to convert seconds to [hour : minutes : seconds] format\r\n * @param seconds seconds to convert\r\n * @returns [hour : minutes : seconds] format\r\n */\r\nfunction parseSeconds(seconds: number): string {\r\n    const d = Number(seconds);\r\n    const h = Math.floor(d / 3600);\r\n    const m = Math.floor((d % 3600) / 60);\r\n    const s = Math.floor((d % 3600) % 60);\r\n\r\n    const hDisplay = h > 0 ? (h < 10 ? `0${h}` : h) + ':' : '';\r\n    const mDisplay = m > 0 ? (m < 10 ? `0${m}` : m) + ':' : '00:';\r\n    const sDisplay = s > 0 ? (s < 10 ? `0${s}` : s) : '00';\r\n    return hDisplay + mDisplay + sDisplay;\r\n}\r\n/**\r\n * Gets data from YouTube url or ID or html body data and deciphers it.\r\n * ```\r\n * video_basic_info + decipher_info = video_info\r\n * ```\r\n *\r\n * Example\r\n * ```ts\r\n * const video = await play.video_info('youtube video url')\r\n *\r\n * const res = ... // Any https package get function.\r\n *\r\n * const video = await play.video_info(res.body, { htmldata : true })\r\n * ```\r\n * @param url YouTube url or ID or html body data\r\n * @param options Video Info Options\r\n *  - `boolean` htmldata : given data is html data or not\r\n * @returns Deciphered Video Info {@link InfoData}.\r\n */\r\nexport async function video_info(url: string, options: InfoOptions = {}): Promise<InfoData> {\r\n    const data = await video_basic_info(url.trim(), options);\r\n    return await decipher_info(data);\r\n}\r\n/**\r\n * Function uses data from video_basic_info and deciphers it if it contains signatures.\r\n * @param data Data - {@link InfoData}\r\n * @param audio_only `boolean` - To decipher only audio formats only.\r\n * @returns Deciphered Video Info {@link InfoData}\r\n */\r\nexport async function decipher_info<T extends InfoData | StreamInfoData>(\r\n    data: T,\r\n    audio_only: boolean = false\r\n): Promise<T> {\r\n    if (\r\n        data.LiveStreamData.isLive === true &&\r\n        data.LiveStreamData.dashManifestUrl !== null &&\r\n        data.video_details.durationInSec === 0\r\n    ) {\r\n        return data;\r\n    } else if (data.format.length > 0 && (data.format[0].signatureCipher || data.format[0].cipher)) {\r\n        if (audio_only) data.format = parseAudioFormats(data.format);\r\n        data.format = await format_decipher(data.format, data.html5player);\r\n        return data;\r\n    } else return data;\r\n}\r\n/**\r\n * Gets YouTube playlist info from a playlist url.\r\n *\r\n * Example\r\n * ```ts\r\n * const playlist = await play.playlist_info('youtube playlist url')\r\n *\r\n * const playlist = await play.playlist_info('youtube playlist url', { incomplete : true })\r\n * ```\r\n * @param url Playlist URL\r\n * @param options Playlist Info Options\r\n * - `boolean` incomplete : When this is set to `false` (default) this function will throw an error\r\n *                          if the playlist contains hidden videos.\r\n *                          If it is set to `true`, it parses the playlist skipping the hidden videos,\r\n *                          only visible videos are included in the resulting {@link YouTubePlaylist}.\r\n *\r\n * @returns YouTube Playlist\r\n */\r\nexport async function playlist_info(url: string, options: PlaylistOptions = {}): Promise<YouTubePlayList> {\r\n    if (!url || typeof url !== 'string') throw new Error(`Expected playlist url, received ${typeof url}!`);\r\n    let url_ = url.trim();\r\n    if (!url_.startsWith('https')) url_ = `https://www.youtube.com/playlist?list=${url_}`;\r\n    if (url_.indexOf('list=') === -1) throw new Error('This is not a Playlist URL');\r\n\r\n    if (url_.includes('music.youtube.com')) {\r\n        const urlObj = new URL(url_);\r\n        urlObj.hostname = 'www.youtube.com';\r\n        url_ = urlObj.toString();\r\n    }\r\n\r\n    const body = await request(url_, {\r\n        headers: {\r\n            'accept-language': options.language || 'en-US;q=0.9'\r\n        }\r\n    });\r\n    if (body.indexOf('Our systems have detected unusual traffic from your computer network.') !== -1)\r\n        throw new Error('Captcha page: YouTube has detected that you are a bot!');\r\n    const response = JSON.parse(\r\n        body\r\n            .split('var ytInitialData = ')[1]\r\n            .split(';</script>')[0]\r\n            .split(/;\\s*(var|const|let)\\s/)[0]\r\n    );\r\n    if (response.alerts) {\r\n        if (response.alerts[0].alertWithButtonRenderer?.type === 'INFO') {\r\n            if (!options.incomplete)\r\n                throw new Error(\r\n                    `While parsing playlist url\\n${response.alerts[0].alertWithButtonRenderer.text.simpleText}`\r\n                );\r\n        } else if (response.alerts[0].alertRenderer?.type === 'ERROR')\r\n            throw new Error(`While parsing playlist url\\n${response.alerts[0].alertRenderer.text.runs[0].text}`);\r\n        else throw new Error('While parsing playlist url\\nUnknown Playlist Error');\r\n    }\r\n    if (url_.indexOf('watch?v=') !== -1 || url_.indexOf('youtu.be/') !== -1) {\r\n        return getWatchPlaylist(response, body, url_);\r\n    } else return getNormalPlaylist(response, body);\r\n}\r\n/**\r\n * Function to parse Playlist from YouTube search\r\n * @param data html data of that request\r\n * @param limit No. of videos to parse\r\n * @returns Array of YouTubeVideo.\r\n */\r\nexport function getPlaylistVideos(data: any, limit = Infinity): YouTubeVideo[] {\r\n    const videos = [];\r\n\r\n    for (let i = 0; i < data.length; i++) {\r\n        if (limit === videos.length) break;\r\n        const info = data[i].playlistVideoRenderer;\r\n        if (!info || !info.shortBylineText) continue;\r\n\r\n        videos.push(\r\n            new YouTubeVideo({\r\n                id: info.videoId,\r\n                duration: parseInt(info.lengthSeconds) || 0,\r\n                duration_raw: info.lengthText?.simpleText ?? '0:00',\r\n                thumbnails: info.thumbnail.thumbnails,\r\n                title: info.title.runs[0].text,\r\n                upcoming: info.upcomingEventData?.startTime\r\n                    ? new Date(parseInt(info.upcomingEventData.startTime) * 1000)\r\n                    : undefined,\r\n                channel: {\r\n                    id: info.shortBylineText.runs[0].navigationEndpoint.browseEndpoint.browseId || undefined,\r\n                    name: info.shortBylineText.runs[0].text || undefined,\r\n                    url: `https://www.youtube.com${\r\n                        info.shortBylineText.runs[0].navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\r\n                        info.shortBylineText.runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url\r\n                    }`,\r\n                    icon: undefined\r\n                }\r\n            })\r\n        );\r\n    }\r\n    return videos;\r\n}\r\n/**\r\n * Function to get Continuation Token\r\n * @param data html data of playlist url\r\n * @returns token\r\n */\r\nexport function getContinuationToken(data: any): string {\r\n    return data.find((x: any) => Object.keys(x)[0] === 'continuationItemRenderer')?.continuationItemRenderer\r\n        .continuationEndpoint?.continuationCommand?.token;\r\n}\r\n\r\nasync function acceptViewerDiscretion(\r\n    videoId: string,\r\n    cookieJar: { [key: string]: string },\r\n    body: string,\r\n    extractRelated: boolean\r\n): Promise<{ streamingData: any; relatedVideos?: any }> {\r\n    const apiKey =\r\n        body.split('INNERTUBE_API_KEY\":\"')[1]?.split('\"')[0] ??\r\n        body.split('innertubeApiKey\":\"')[1]?.split('\"')[0] ??\r\n        DEFAULT_API_KEY;\r\n    const sessionToken =\r\n        body.split('\"XSRF_TOKEN\":\"')[1]?.split('\"')[0].replaceAll('\\\\u003d', '=') ??\r\n        body.split('\"xsrf_token\":\"')[1]?.split('\"')[0].replaceAll('\\\\u003d', '=');\r\n    if (!sessionToken)\r\n        throw new Error(`Unable to extract XSRF_TOKEN to accept the viewer discretion popup for video: ${videoId}.`);\r\n\r\n    const verificationResponse = await request(`https://www.youtube.com/youtubei/v1/verify_age?key=${apiKey}&prettyPrint=false`, {\r\n        method: 'POST',\r\n        body: JSON.stringify({\r\n            context: {\r\n                client: {\r\n                    utcOffsetMinutes: 0,\r\n                    gl: 'US',\r\n                    hl: 'en',\r\n                    clientName: 'WEB',\r\n                    clientVersion:\r\n                        body.split('\"INNERTUBE_CONTEXT_CLIENT_VERSION\":\"')[1]?.split('\"')[0] ??\r\n                        body.split('\"innertube_context_client_version\":\"')[1]?.split('\"')[0] ??\r\n                        '<some version>'\r\n                },\r\n                user: {},\r\n                request: {}\r\n            },\r\n            nextEndpoint: {\r\n                urlEndpoint: {\r\n                    url: `watch?v=${videoId}`\r\n                }\r\n            },\r\n            setControvercy: true\r\n        }),\r\n        cookies: true,\r\n        cookieJar\r\n    });\r\n\r\n    const endpoint = JSON.parse(verificationResponse).actions[0].navigateAction.endpoint;\r\n\r\n    const videoPage = await request(`https://www.youtube.com/${endpoint.urlEndpoint.url}&pbj=1`, {\r\n        method: 'POST',\r\n        headers: {\r\n            'Content-Type': 'application/x-www-form-urlencoded'\r\n        },\r\n        body: new URLSearchParams([\r\n            ['command', JSON.stringify(endpoint)],\r\n            ['session_token', sessionToken]\r\n        ]).toString(),\r\n        cookies: true,\r\n        cookieJar\r\n    });\r\n\r\n    if (videoPage.includes('<h1>Something went wrong</h1>'))\r\n        throw new Error(`Unable to accept the viewer discretion popup for video: ${videoId}`);\r\n\r\n    const videoPageData = JSON.parse(videoPage);\r\n\r\n    if (videoPageData[2].playerResponse.playabilityStatus.status !== 'OK')\r\n        throw new Error(\r\n            `While getting info from url after trying to accept the discretion popup for video ${videoId}\\n${\r\n                videoPageData[2].playerResponse.playabilityStatus.errorScreen.playerErrorMessageRenderer?.reason\r\n                    .simpleText ??\r\n                videoPageData[2].playerResponse.playabilityStatus.errorScreen.playerKavRenderer?.reason.simpleText\r\n            }`\r\n        );\r\n\r\n    const streamingData = videoPageData[2].playerResponse.streamingData;\r\n\r\n    if (extractRelated)\r\n        return {\r\n            streamingData,\r\n            relatedVideos: videoPageData[3].response.contents.twoColumnWatchNextResults.secondaryResults\r\n        };\r\n\r\n    return { streamingData };\r\n}\r\n\r\nasync function getAndroidFormats(videoId: string, cookieJar: { [key: string]: string }, body: string): Promise<any[]> {\r\n    const apiKey =\r\n        body.split('INNERTUBE_API_KEY\":\"')[1]?.split('\"')[0] ??\r\n        body.split('innertubeApiKey\":\"')[1]?.split('\"')[0] ??\r\n        DEFAULT_API_KEY;\r\n\r\n    const response = await request(`https://www.youtube.com/youtubei/v1/player?key=${apiKey}&prettyPrint=false`, {\r\n        method: 'POST',\r\n        body: JSON.stringify({\r\n            context: {\r\n                client: {\r\n                    clientName: 'ANDROID',\r\n                    clientVersion: '16.49',\r\n                    hl: 'en',\r\n                    timeZone: 'UTC',\r\n                    utcOffsetMinutes: 0\r\n                }\r\n            },\r\n            videoId: videoId,\r\n            playbackContext: { contentPlaybackContext: { html5Preference: 'HTML5_PREF_WANTS' } },\r\n            contentCheckOk: true,\r\n            racyCheckOk: true\r\n        }),\r\n        cookies: true,\r\n        cookieJar\r\n    });\r\n\r\n    return JSON.parse(response).streamingData.formats;\r\n}\r\n\r\nfunction getWatchPlaylist(response: any, body: any, url: string): YouTubePlayList {\r\n    const playlist_details = response.contents.twoColumnWatchNextResults.playlist?.playlist;\r\n    if (!playlist_details)\r\n        throw new Error(\"Watch playlist unavailable due to YouTube layout changes.\")\r\n\r\n    const videos = getWatchPlaylistVideos(playlist_details.contents);\r\n    const API_KEY =\r\n        body.split('INNERTUBE_API_KEY\":\"')[1]?.split('\"')[0] ??\r\n        body.split('innertubeApiKey\":\"')[1]?.split('\"')[0] ??\r\n        DEFAULT_API_KEY;\r\n\r\n    const videoCount = playlist_details.totalVideos;\r\n    const channel = playlist_details.shortBylineText?.runs?.[0];\r\n    const badge = playlist_details.badges?.[0]?.metadataBadgeRenderer?.style.toLowerCase();\r\n\r\n    return new YouTubePlayList({\r\n        continuation: {\r\n            api: API_KEY,\r\n            token: getContinuationToken(playlist_details.contents),\r\n            clientVersion:\r\n                body.split('\"INNERTUBE_CONTEXT_CLIENT_VERSION\":\"')[1]?.split('\"')[0] ??\r\n                body.split('\"innertube_context_client_version\":\"')[1]?.split('\"')[0] ??\r\n                '<some version>'\r\n        },\r\n        id: playlist_details.playlistId || '',\r\n        title: playlist_details.title || '',\r\n        videoCount: parseInt(videoCount) || 0,\r\n        videos: videos,\r\n        url: url,\r\n        channel: {\r\n            id: channel?.navigationEndpoint?.browseEndpoint?.browseId || null,\r\n            name: channel?.text || null,\r\n            url: `https://www.youtube.com${\r\n                channel?.navigationEndpoint?.browseEndpoint?.canonicalBaseUrl ||\r\n                channel?.navigationEndpoint?.commandMetadata?.webCommandMetadata?.url\r\n            }`,\r\n            verified: Boolean(badge?.includes('verified')),\r\n            artist: Boolean(badge?.includes('artist'))\r\n        }\r\n    });\r\n}\r\n\r\nfunction getNormalPlaylist(response: any, body: any): YouTubePlayList {\r\n    const json_data =\r\n        response.contents.twoColumnBrowseResultsRenderer.tabs[0].tabRenderer.content.sectionListRenderer.contents[0]\r\n            .itemSectionRenderer.contents[0].playlistVideoListRenderer.contents;\r\n    const playlist_details = response.sidebar.playlistSidebarRenderer.items;\r\n\r\n    const API_KEY =\r\n        body.split('INNERTUBE_API_KEY\":\"')[1]?.split('\"')[0] ??\r\n        body.split('innertubeApiKey\":\"')[1]?.split('\"')[0] ??\r\n        DEFAULT_API_KEY;\r\n    const videos = getPlaylistVideos(json_data, 100);\r\n\r\n    const data = playlist_details[0].playlistSidebarPrimaryInfoRenderer;\r\n    if (!data.title.runs || !data.title.runs.length) throw new Error('Failed to Parse Playlist info.');\r\n\r\n    const author = playlist_details[1]?.playlistSidebarSecondaryInfoRenderer.videoOwner;\r\n    const views = data.stats.length === 3 ? data.stats[1].simpleText.replace(/\\D/g, '') : 0;\r\n    const lastUpdate =\r\n        data.stats\r\n            .find((x: any) => 'runs' in x && x['runs'].find((y: any) => y.text.toLowerCase().includes('last update')))\r\n            ?.runs.pop()?.text ?? null;\r\n    const videosCount = data.stats[0].runs[0].text.replace(/\\D/g, '') || 0;\r\n\r\n    const res = new YouTubePlayList({\r\n        continuation: {\r\n            api: API_KEY,\r\n            token: getContinuationToken(json_data),\r\n            clientVersion:\r\n                body.split('\"INNERTUBE_CONTEXT_CLIENT_VERSION\":\"')[1]?.split('\"')[0] ??\r\n                body.split('\"innertube_context_client_version\":\"')[1]?.split('\"')[0] ??\r\n                '<some version>'\r\n        },\r\n        id: data.title.runs[0].navigationEndpoint.watchEndpoint.playlistId,\r\n        title: data.title.runs[0].text,\r\n        videoCount: parseInt(videosCount) || 0,\r\n        lastUpdate: lastUpdate,\r\n        views: parseInt(views) || 0,\r\n        videos: videos,\r\n        url: `https://www.youtube.com/playlist?list=${data.title.runs[0].navigationEndpoint.watchEndpoint.playlistId}`,\r\n        link: `https://www.youtube.com${data.title.runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url}`,\r\n        channel: author\r\n            ? {\r\n                  name: author.videoOwnerRenderer.title.runs[0].text,\r\n                  id: author.videoOwnerRenderer.title.runs[0].navigationEndpoint.browseEndpoint.browseId,\r\n                  url: `https://www.youtube.com${\r\n                      author.videoOwnerRenderer.navigationEndpoint.commandMetadata.webCommandMetadata.url ||\r\n                      author.videoOwnerRenderer.navigationEndpoint.browseEndpoint.canonicalBaseUrl\r\n                  }`,\r\n                  icons: author.videoOwnerRenderer.thumbnail.thumbnails ?? []\r\n              }\r\n            : {},\r\n        thumbnail: data.thumbnailRenderer.playlistVideoThumbnailRenderer?.thumbnail.thumbnails.length\r\n            ? data.thumbnailRenderer.playlistVideoThumbnailRenderer.thumbnail.thumbnails[\r\n                  data.thumbnailRenderer.playlistVideoThumbnailRenderer.thumbnail.thumbnails.length - 1\r\n              ]\r\n            : null\r\n    });\r\n    return res;\r\n}\r\n\r\nfunction getWatchPlaylistVideos(data: any, limit = Infinity): YouTubeVideo[] {\r\n    const videos: YouTubeVideo[] = [];\r\n\r\n    for (let i = 0; i < data.length; i++) {\r\n        if (limit === videos.length) break;\r\n        const info = data[i].playlistPanelVideoRenderer;\r\n        if (!info || !info.shortBylineText) continue;\r\n        const channel_info = info.shortBylineText.runs[0];\r\n\r\n        videos.push(\r\n            new YouTubeVideo({\r\n                id: info.videoId,\r\n                duration: parseDuration(info.lengthText?.simpleText) || 0,\r\n                duration_raw: info.lengthText?.simpleText ?? '0:00',\r\n                thumbnails: info.thumbnail.thumbnails,\r\n                title: info.title.simpleText,\r\n                upcoming:\r\n                    info.thumbnailOverlays[0].thumbnailOverlayTimeStatusRenderer?.style === 'UPCOMING' || undefined,\r\n                channel: {\r\n                    id: channel_info.navigationEndpoint.browseEndpoint.browseId || undefined,\r\n                    name: channel_info.text || undefined,\r\n                    url: `https://www.youtube.com${\r\n                        channel_info.navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\r\n                        channel_info.navigationEndpoint.commandMetadata.webCommandMetadata.url\r\n                    }`,\r\n                    icon: undefined\r\n                }\r\n            })\r\n        );\r\n    }\r\n\r\n    return videos;\r\n}\r\n\r\nfunction parseDuration(text: string): number {\r\n    if (!text) return 0;\r\n    const split = text.split(':');\r\n\r\n    switch (split.length) {\r\n        case 2:\r\n            return parseInt(split[0]) * 60 + parseInt(split[1]);\r\n\r\n        case 3:\r\n            return parseInt(split[0]) * 60 * 60 + parseInt(split[1]) * 60 + parseInt(split[2]);\r\n\r\n        default:\r\n            return 0;\r\n    }\r\n}","import { WebmElements, WebmHeader } from 'play-audio';\r\nimport { Duplex, DuplexOptions } from 'node:stream';\r\n\r\nenum DataType {\r\n    master,\r\n    string,\r\n    uint,\r\n    binary,\r\n    float\r\n}\r\n\r\nexport enum WebmSeekerState {\r\n    READING_HEAD = 'READING_HEAD',\r\n    READING_DATA = 'READING_DATA'\r\n}\r\n\r\ninterface WebmSeekerOptions extends DuplexOptions {\r\n    mode?: 'precise' | 'granular';\r\n}\r\n\r\nconst WEB_ELEMENT_KEYS = Object.keys(WebmElements);\r\n\r\nexport class WebmSeeker extends Duplex {\r\n    remaining?: Buffer;\r\n    state: WebmSeekerState;\r\n    chunk?: Buffer;\r\n    cursor: number;\r\n    header: WebmHeader;\r\n    headfound: boolean;\r\n    headerparsed: boolean;\r\n    seekfound: boolean;\r\n    private data_size: number;\r\n    private offset: number;\r\n    private data_length: number;\r\n    private sec: number;\r\n    private time: number;\r\n\r\n    constructor(sec: number, options: WebmSeekerOptions) {\r\n        super(options);\r\n        this.state = WebmSeekerState.READING_HEAD;\r\n        this.cursor = 0;\r\n        this.header = new WebmHeader();\r\n        this.headfound = false;\r\n        this.headerparsed = false;\r\n        this.seekfound = false;\r\n        this.data_length = 0;\r\n        this.data_size = 0;\r\n        this.offset = 0;\r\n        this.sec = sec;\r\n        this.time = Math.floor(sec / 10) * 10;\r\n    }\r\n\r\n    private get vint_length(): number {\r\n        let i = 0;\r\n        for (; i < 8; i++) {\r\n            if ((1 << (7 - i)) & this.chunk![this.cursor]) break;\r\n        }\r\n        return ++i;\r\n    }\r\n\r\n    private vint_value(): boolean {\r\n        if (!this.chunk) return false;\r\n        const length = this.vint_length;\r\n        if (this.chunk.length < this.cursor + length) return false;\r\n        let value = this.chunk[this.cursor] & ((1 << (8 - length)) - 1);\r\n        for (let i = this.cursor + 1; i < this.cursor + length; i++) value = (value << 8) + this.chunk[i];\r\n        this.data_size = length;\r\n        this.data_length = value;\r\n        return true;\r\n    }\r\n\r\n    cleanup() {\r\n        this.cursor = 0;\r\n        this.chunk = undefined;\r\n        this.remaining = undefined;\r\n    }\r\n\r\n    _read() {}\r\n\r\n    seek(content_length: number): Error | number {\r\n        let clusterlength = 0,\r\n            position = 0;\r\n        let time_left = (this.sec - this.time) * 1000 || 0;\r\n        time_left = Math.round(time_left / 20) * 20;\r\n        if (!this.header.segment.cues) return new Error('Failed to Parse Cues');\r\n\r\n        for (let i = 0; i < this.header.segment.cues.length; i++) {\r\n            const data = this.header.segment.cues[i];\r\n            if (Math.floor((data.time as number) / 1000) === this.time) {\r\n                position = data.position as number;\r\n                clusterlength = (this.header.segment.cues[i + 1]?.position || content_length) - position - 1;\r\n                break;\r\n            } else continue;\r\n        }\r\n        if (clusterlength === 0) return position;\r\n        return this.offset + Math.round(position + (time_left / 20) * (clusterlength / 500));\r\n    }\r\n\r\n    _write(chunk: Buffer, _: BufferEncoding, callback: (error?: Error | null) => void): void {\r\n        if (this.remaining) {\r\n            this.chunk = Buffer.concat([this.remaining, chunk]);\r\n            this.remaining = undefined;\r\n        } else this.chunk = chunk;\r\n\r\n        let err: Error | undefined;\r\n\r\n        if (this.state === WebmSeekerState.READING_HEAD) err = this.readHead();\r\n        else if (!this.seekfound) err = this.getClosestBlock();\r\n        else err = this.readTag();\r\n\r\n        if (err) callback(err);\r\n        else callback();\r\n    }\r\n\r\n    private readHead(): Error | undefined {\r\n        if (!this.chunk) return new Error('Chunk is missing');\r\n\r\n        while (this.chunk.length > this.cursor) {\r\n            const oldCursor = this.cursor;\r\n            const id = this.vint_length;\r\n            if (this.chunk.length < this.cursor + id) break;\r\n\r\n            const ebmlID = this.parseEbmlID(this.chunk.slice(this.cursor, this.cursor + id).toString('hex'));\r\n            this.cursor += id;\r\n\r\n            if (!this.vint_value()) {\r\n                this.cursor = oldCursor;\r\n                break;\r\n            }\r\n            if (!ebmlID) {\r\n                this.cursor += this.data_size + this.data_length;\r\n                continue;\r\n            }\r\n\r\n            if (!this.headfound) {\r\n                if (ebmlID.name === 'ebml') this.headfound = true;\r\n                else return new Error('Failed to find EBML ID at start of stream.');\r\n            }\r\n            const data = this.chunk.slice(\r\n                this.cursor + this.data_size,\r\n                this.cursor + this.data_size + this.data_length\r\n            );\r\n            const parse = this.header.parse(ebmlID, data);\r\n            if (parse instanceof Error) return parse;\r\n\r\n            // stop parsing the header once we have found the correct cue\r\n\r\n            if (ebmlID.name === 'seekHead') this.offset = oldCursor;\r\n\r\n            if (\r\n                ebmlID.name === 'cueClusterPosition' &&\r\n                this.header.segment.cues!.length > 2 &&\r\n                this.time === (this.header.segment.cues!.at(-2)!.time as number) / 1000\r\n            )\r\n                this.emit('headComplete');\r\n\r\n            if (ebmlID.type === DataType.master) {\r\n                this.cursor += this.data_size;\r\n                continue;\r\n            }\r\n\r\n            if (this.chunk.length < this.cursor + this.data_size + this.data_length) {\r\n                this.cursor = oldCursor;\r\n                break;\r\n            } else this.cursor += this.data_size + this.data_length;\r\n        }\r\n        this.remaining = this.chunk.slice(this.cursor);\r\n        this.cursor = 0;\r\n    }\r\n\r\n    private readTag(): Error | undefined {\r\n        if (!this.chunk) return new Error('Chunk is missing');\r\n\r\n        while (this.chunk.length > this.cursor) {\r\n            const oldCursor = this.cursor;\r\n            const id = this.vint_length;\r\n            if (this.chunk.length < this.cursor + id) break;\r\n\r\n            const ebmlID = this.parseEbmlID(this.chunk.slice(this.cursor, this.cursor + id).toString('hex'));\r\n            this.cursor += id;\r\n\r\n            if (!this.vint_value()) {\r\n                this.cursor = oldCursor;\r\n                break;\r\n            }\r\n            if (!ebmlID) {\r\n                this.cursor += this.data_size + this.data_length;\r\n                continue;\r\n            }\r\n\r\n            const data = this.chunk.slice(\r\n                this.cursor + this.data_size,\r\n                this.cursor + this.data_size + this.data_length\r\n            );\r\n            const parse = this.header.parse(ebmlID, data);\r\n            if (parse instanceof Error) return parse;\r\n\r\n            if (ebmlID.type === DataType.master) {\r\n                this.cursor += this.data_size;\r\n                continue;\r\n            }\r\n\r\n            if (this.chunk.length < this.cursor + this.data_size + this.data_length) {\r\n                this.cursor = oldCursor;\r\n                break;\r\n            } else this.cursor += this.data_size + this.data_length;\r\n\r\n            if (ebmlID.name === 'simpleBlock') {\r\n                const track = this.header.segment.tracks![this.header.audioTrack];\r\n                if (!track || track.trackType !== 2) return new Error('No audio Track in this webm file.');\r\n                if ((data[0] & 0xf) === track.trackNumber) this.push(data.slice(4));\r\n            }\r\n        }\r\n        this.remaining = this.chunk.slice(this.cursor);\r\n        this.cursor = 0;\r\n    }\r\n\r\n    private getClosestBlock(): Error | undefined {\r\n        if (this.sec === 0) {\r\n            this.seekfound = true;\r\n            return this.readTag();\r\n        }\r\n        if (!this.chunk) return new Error('Chunk is missing');\r\n        this.cursor = 0;\r\n        let positionFound = false;\r\n        while (!positionFound && this.cursor < this.chunk.length) {\r\n            this.cursor = this.chunk.indexOf('a3', this.cursor, 'hex');\r\n            if (this.cursor === -1) return new Error('Failed to find nearest Block.');\r\n            this.cursor++;\r\n            if (!this.vint_value()) return new Error('Failed to find correct simpleBlock in first chunk');\r\n            if (this.cursor + this.data_length + this.data_length > this.chunk.length) continue;\r\n            const data = this.chunk.slice(\r\n                this.cursor + this.data_size,\r\n                this.cursor + this.data_size + this.data_length\r\n            );\r\n            const track = this.header.segment.tracks![this.header.audioTrack];\r\n            if (!track || track.trackType !== 2) return new Error('No audio Track in this webm file.');\r\n            if ((data[0] & 0xf) === track.trackNumber) {\r\n                this.cursor += this.data_size + this.data_length;\r\n                this.push(data.slice(4));\r\n                positionFound = true;\r\n            } else continue;\r\n        }\r\n        if (!positionFound) return new Error('Failed to find nearest correct simple Block.');\r\n        this.seekfound = true;\r\n        return this.readTag();\r\n    }\r\n\r\n    private parseEbmlID(ebmlID: string) {\r\n        if (WEB_ELEMENT_KEYS.includes(ebmlID)) return WebmElements[ebmlID];\r\n        else return false;\r\n    }\r\n\r\n    _destroy(error: Error | null, callback: (error: Error | null) => void): void {\r\n        this.cleanup();\r\n        callback(error);\r\n    }\r\n\r\n    _final(callback: (error?: Error | null) => void): void {\r\n        this.cleanup();\r\n        callback();\r\n    }\r\n}\r\n","import { IncomingMessage } from 'node:http';\r\nimport { request_stream } from '../../Request';\r\nimport { parseAudioFormats, StreamOptions, StreamType } from '../stream';\r\nimport { video_stream_info } from '../utils/extractor';\r\nimport { Timer } from './LiveStream';\r\nimport { WebmSeeker, WebmSeekerState } from './WebmSeeker';\r\n\r\n/**\r\n * YouTube Stream Class for seeking audio to a timeStamp.\r\n */\r\nexport class SeekStream {\r\n    /**\r\n     * WebmSeeker Stream through which data passes\r\n     */\r\n    stream: WebmSeeker;\r\n    /**\r\n     * Type of audio data that we recieved from normal youtube url.\r\n     */\r\n    type: StreamType;\r\n    /**\r\n     * Audio Endpoint Format Url to get data from.\r\n     */\r\n    private url: string;\r\n    /**\r\n     * Used to calculate no of bytes data that we have recieved\r\n     */\r\n    private bytes_count: number;\r\n    /**\r\n     * Calculate per second bytes by using contentLength (Total bytes) / Duration (in seconds)\r\n     */\r\n    private per_sec_bytes: number;\r\n    /**\r\n     * Length of the header in bytes\r\n     */\r\n    private header_length: number;\r\n    /**\r\n     * Total length of audio file in bytes\r\n     */\r\n    private content_length: number;\r\n    /**\r\n     * YouTube video url. [ Used only for retrying purposes only. ]\r\n     */\r\n    private video_url: string;\r\n    /**\r\n     * Timer for looping data every 265 seconds.\r\n     */\r\n    private timer: Timer;\r\n    /**\r\n     * Quality given by user. [ Used only for retrying purposes only. ]\r\n     */\r\n    private quality: number;\r\n    /**\r\n     * Incoming message that we recieve.\r\n     *\r\n     * Storing this is essential.\r\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\r\n     */\r\n    private request: IncomingMessage | null;\r\n    /**\r\n     * YouTube Stream Class constructor\r\n     * @param url Audio Endpoint url.\r\n     * @param type Type of Stream\r\n     * @param duration Duration of audio playback [ in seconds ]\r\n     * @param headerLength Length of the header in bytes.\r\n     * @param contentLength Total length of Audio file in bytes.\r\n     * @param bitrate Bitrate provided by YouTube.\r\n     * @param video_url YouTube video url.\r\n     * @param options Options provided to stream function.\r\n     */\r\n    constructor(\r\n        url: string,\r\n        duration: number,\r\n        headerLength: number,\r\n        contentLength: number,\r\n        bitrate: number,\r\n        video_url: string,\r\n        options: StreamOptions\r\n    ) {\r\n        this.stream = new WebmSeeker(options.seek!, {\r\n            highWaterMark: 5 * 1000 * 1000,\r\n            readableObjectMode: true\r\n        });\r\n        this.url = url;\r\n        this.quality = options.quality as number;\r\n        this.type = StreamType.Opus;\r\n        this.bytes_count = 0;\r\n        this.video_url = video_url;\r\n        this.per_sec_bytes = bitrate ? Math.ceil(bitrate / 8) : Math.ceil(contentLength / duration);\r\n        this.header_length = headerLength;\r\n        this.content_length = contentLength;\r\n        this.request = null;\r\n        this.timer = new Timer(() => {\r\n            this.timer.reuse();\r\n            this.loop();\r\n        }, 265);\r\n        this.stream.on('close', () => {\r\n            this.timer.destroy();\r\n            this.cleanup();\r\n        });\r\n        this.seek();\r\n    }\r\n    /**\r\n     * **INTERNAL Function**\r\n     *\r\n     * Uses stream functions to parse Webm Head and gets Offset byte to seek to.\r\n     * @returns Nothing\r\n     */\r\n    private async seek(): Promise<void> {\r\n        const parse = await new Promise(async (res, rej) => {\r\n            if (!this.stream.headerparsed) {\r\n                const stream = await request_stream(this.url, {\r\n                    headers: {\r\n                        range: `bytes=0-${this.header_length}`\r\n                    }\r\n                }).catch((err: Error) => err);\r\n\r\n                if (stream instanceof Error) {\r\n                    rej(stream);\r\n                    return;\r\n                }\r\n                if (Number(stream.statusCode) >= 400) {\r\n                    rej(400);\r\n                    return;\r\n                }\r\n                this.request = stream;\r\n                stream.pipe(this.stream, { end: false });\r\n\r\n                // headComplete should always be called, leaving this here just in case\r\n                stream.once('end', () => {\r\n                    this.stream.state = WebmSeekerState.READING_DATA;\r\n                    res('');\r\n                });\r\n\r\n                this.stream.once('headComplete', () => {\r\n                    stream.unpipe(this.stream);\r\n                    stream.destroy();\r\n                    this.stream.state = WebmSeekerState.READING_DATA;\r\n                    res('');\r\n                });\r\n            } else res('');\r\n        }).catch((err) => err);\r\n        if (parse instanceof Error) {\r\n            this.stream.emit('error', parse);\r\n            this.bytes_count = 0;\r\n            this.per_sec_bytes = 0;\r\n            this.cleanup();\r\n            return;\r\n        } else if (parse === 400) {\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            return this.seek();\r\n        }\r\n        const bytes = this.stream.seek(this.content_length);\r\n        if (bytes instanceof Error) {\r\n            this.stream.emit('error', bytes);\r\n            this.bytes_count = 0;\r\n            this.per_sec_bytes = 0;\r\n            this.cleanup();\r\n            return;\r\n        }\r\n\r\n        this.stream.seekfound = false;\r\n        this.bytes_count = bytes;\r\n        this.timer.reuse();\r\n        this.loop();\r\n    }\r\n    /**\r\n     * Retry if we get 404 or 403 Errors.\r\n     */\r\n    private async retry() {\r\n        const info = await video_stream_info(this.video_url);\r\n        const audioFormat = parseAudioFormats(info.format);\r\n        this.url = audioFormat[this.quality].url;\r\n    }\r\n    /**\r\n     * This cleans every used variable in class.\r\n     *\r\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\r\n     */\r\n    private cleanup() {\r\n        this.request?.destroy();\r\n        this.request = null;\r\n        this.url = '';\r\n    }\r\n    /**\r\n     * Getting data from audio endpoint url and passing it to stream.\r\n     *\r\n     * If 404 or 403 occurs, it will retry again.\r\n     */\r\n    private async loop() {\r\n        if (this.stream.destroyed) {\r\n            this.timer.destroy();\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        const end: number = this.bytes_count + this.per_sec_bytes * 300;\r\n        const stream = await request_stream(this.url, {\r\n            headers: {\r\n                range: `bytes=${this.bytes_count}-${end >= this.content_length ? '' : end}`\r\n            }\r\n        }).catch((err: Error) => err);\r\n        if (stream instanceof Error) {\r\n            this.stream.emit('error', stream);\r\n            this.bytes_count = 0;\r\n            this.per_sec_bytes = 0;\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        if (Number(stream.statusCode) >= 400) {\r\n            this.cleanup();\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            this.loop();\r\n            return;\r\n        }\r\n        this.request = stream;\r\n        stream.pipe(this.stream, { end: false });\r\n\r\n        stream.once('error', async () => {\r\n            this.cleanup();\r\n            await this.retry();\r\n            this.timer.reuse();\r\n            this.loop();\r\n        });\r\n\r\n        stream.on('data', (chunk: any) => {\r\n            this.bytes_count += chunk.length;\r\n        });\r\n\r\n        stream.on('end', () => {\r\n            if (end >= this.content_length) {\r\n                this.timer.destroy();\r\n                this.stream.end();\r\n                this.cleanup();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Pauses timer.\r\n     * Stops running of loop.\r\n     *\r\n     * Useful if you don't want to get excess data to be stored in stream.\r\n     */\r\n    pause() {\r\n        this.timer.pause();\r\n    }\r\n    /**\r\n     * Resumes timer.\r\n     * Starts running of loop.\r\n     */\r\n    resume() {\r\n        this.timer.resume();\r\n    }\r\n}\r\n","import { request_content_length, request_stream } from '../Request';\r\nimport { LiveStream, Stream } from './classes/LiveStream';\r\nimport { SeekStream } from './classes/SeekStream';\r\nimport { InfoData, StreamInfoData } from './utils/constants';\r\nimport { video_stream_info } from './utils/extractor';\r\nimport { URL } from 'node:url';\r\n\r\nexport enum StreamType {\r\n    Arbitrary = 'arbitrary',\r\n    Raw = 'raw',\r\n    OggOpus = 'ogg/opus',\r\n    WebmOpus = 'webm/opus',\r\n    Opus = 'opus'\r\n}\r\n\r\nexport interface StreamOptions {\r\n    seek?: number;\r\n    quality?: number;\r\n    language?: string;\r\n    htmldata?: boolean;\r\n    precache?: number;\r\n    discordPlayerCompatibility?: boolean;\r\n}\r\n\r\n/**\r\n * Command to find audio formats from given format array\r\n * @param formats Formats to search from\r\n * @returns Audio Formats array\r\n */\r\nexport function parseAudioFormats(formats: any[]) {\r\n    const result: any[] = [];\r\n    formats.forEach((format) => {\r\n        const type = format.mimeType as string;\r\n        if (type.startsWith('audio')) {\r\n            format.codec = type.split('codecs=\"')[1].split('\"')[0];\r\n            format.container = type.split('audio/')[1].split(';')[0];\r\n            result.push(format);\r\n        }\r\n    });\r\n    return result;\r\n}\r\n/**\r\n * Type for YouTube Stream\r\n */\r\nexport type YouTubeStream = Stream | LiveStream | SeekStream;\r\n/**\r\n * Stream command for YouTube\r\n * @param url YouTube URL\r\n * @param options lets you add quality for stream\r\n * @returns Stream class with type and stream for playing.\r\n */\r\nexport async function stream(url: string, options: StreamOptions = {}): Promise<YouTubeStream> {\r\n    const info = await video_stream_info(url, { htmldata: options.htmldata, language: options.language });\r\n    return await stream_from_info(info, options);\r\n}\r\n/**\r\n * Stream command for YouTube using info from video_info or decipher_info function.\r\n * @param info video_info data\r\n * @param options lets you add quality for stream\r\n * @returns Stream class with type and stream for playing.\r\n */\r\nexport async function stream_from_info(\r\n    info: InfoData | StreamInfoData,\r\n    options: StreamOptions = {}\r\n): Promise<YouTubeStream> {\r\n    if (info.format.length === 0)\r\n        throw new Error('Upcoming and premiere videos that are not currently live cannot be streamed.');\r\n    if (options.quality && !Number.isInteger(options.quality))\r\n        throw new Error(\"Quality must be set to an integer.\")\r\n\r\n    const final: any[] = [];\r\n    if (\r\n        info.LiveStreamData.isLive === true &&\r\n        info.LiveStreamData.dashManifestUrl !== null &&\r\n        info.video_details.durationInSec === 0\r\n    ) {\r\n        return new LiveStream(\r\n            info.LiveStreamData.dashManifestUrl,\r\n            info.format[info.format.length - 1].targetDurationSec as number,\r\n            info.video_details.url,\r\n            options.precache\r\n        );\r\n    }\r\n\r\n    const audioFormat = parseAudioFormats(info.format);\r\n    if (typeof options.quality !== 'number') options.quality = audioFormat.length - 1;\r\n    else if (options.quality <= 0) options.quality = 0;\r\n    else if (options.quality >= audioFormat.length) options.quality = audioFormat.length - 1;\r\n    if (audioFormat.length !== 0) final.push(audioFormat[options.quality]);\r\n    else final.push(info.format[info.format.length - 1]);\r\n    let type: StreamType =\r\n        final[0].codec === 'opus' && final[0].container === 'webm' ? StreamType.WebmOpus : StreamType.Arbitrary;\r\n    await request_stream(`https://${new URL(final[0].url).host}/generate_204`);\r\n    if (type === StreamType.WebmOpus) {\r\n        if (!options.discordPlayerCompatibility) {\r\n            options.seek ??= 0;\r\n            if (options.seek >= info.video_details.durationInSec || options.seek < 0)\r\n                throw new Error(`Seeking beyond limit. [ 0 - ${info.video_details.durationInSec - 1}]`);\r\n            return new SeekStream(\r\n                final[0].url,\r\n                info.video_details.durationInSec,\r\n                final[0].indexRange.end,\r\n                Number(final[0].contentLength),\r\n                Number(final[0].bitrate),\r\n                info.video_details.url,\r\n                options\r\n            );\r\n        } else if (options.seek) throw new Error('Can not seek with discordPlayerCompatibility set to true.');\r\n    }\r\n\r\n    let contentLength;\r\n    if (final[0].contentLength) {\r\n        contentLength = Number(final[0].contentLength);\r\n    } else {\r\n        contentLength = await request_content_length(final[0].url);\r\n    }\r\n\r\n    return new Stream(\r\n        final[0].url,\r\n        type,\r\n        info.video_details.durationInSec,\r\n        contentLength,\r\n        info.video_details.url,\r\n        options\r\n    );\r\n}\r\n","import { YouTubeVideo } from '../classes/Video';\r\nimport { YouTubePlayList } from '../classes/Playlist';\r\nimport { YouTubeChannel } from '../classes/Channel';\r\nimport { YouTube } from '..';\r\nimport { YouTubeThumbnail } from '../classes/Thumbnail';\r\n\r\nconst BLURRED_THUMBNAILS = [\r\n    '-oaymwEpCOADEI4CSFryq4qpAxsIARUAAAAAGAElAADIQj0AgKJDeAHtAZmZGUI=',\r\n    '-oaymwEiCOADEI4CSFXyq4qpAxQIARUAAIhCGAFwAcABBu0BmZkZQg==',\r\n    '-oaymwEiCOgCEMoBSFXyq4qpAxQIARUAAIhCGAFwAcABBu0BZmbmQQ==',\r\n    '-oaymwEiCNAFEJQDSFXyq4qpAxQIARUAAIhCGAFwAcABBu0BZmZmQg==',\r\n    '-oaymwEdCNAFEJQDSFryq4qpAw8IARUAAIhCGAHtAWZmZkI=',\r\n    '-oaymwEdCNACELwBSFryq4qpAw8IARUAAIhCGAHtAT0K10E='\r\n];\r\n\r\nexport interface ParseSearchInterface {\r\n    type?: 'video' | 'playlist' | 'channel';\r\n    limit?: number;\r\n    language?: string;\r\n    unblurNSFWThumbnails?: boolean;\r\n}\r\n\r\nexport interface thumbnail {\r\n    width: string;\r\n    height: string;\r\n    url: string;\r\n}\r\n/**\r\n * Main command which converts html body data and returns the type of data requested.\r\n * @param html body of that request\r\n * @param options limit & type of YouTube search you want.\r\n * @returns Array of one of YouTube type.\r\n */\r\nexport function ParseSearchResult(html: string, options?: ParseSearchInterface): YouTube[] {\r\n    if (!html) throw new Error(\"Can't parse Search result without data\");\r\n    if (!options) options = { type: 'video', limit: 0 };\r\n    else if (!options.type) options.type = 'video';\r\n    const hasLimit = typeof options.limit === 'number' && options.limit > 0;\r\n    options.unblurNSFWThumbnails ??= false;\r\n\r\n    const data = html\r\n        .split('var ytInitialData = ')?.[1]\r\n        ?.split(';</script>')[0]\r\n        .split(/;\\s*(var|const|let)\\s/)[0];\r\n    const json_data = JSON.parse(data);\r\n    const results = [];\r\n    const details =\r\n        json_data.contents.twoColumnSearchResultsRenderer.primaryContents.sectionListRenderer.contents.flatMap(\r\n            (s: any) => s.itemSectionRenderer?.contents\r\n        );\r\n    for (const detail of details) {\r\n        if (hasLimit && results.length === options.limit) break;\r\n        if (!detail || (!detail.videoRenderer && !detail.channelRenderer && !detail.playlistRenderer)) continue;\r\n        switch (options.type) {\r\n            case 'video': {\r\n                const parsed = parseVideo(detail);\r\n                if (parsed) {\r\n                    if (options.unblurNSFWThumbnails) parsed.thumbnails.forEach(unblurThumbnail);\r\n                    results.push(parsed);\r\n                }\r\n                break;\r\n            }\r\n            case 'channel': {\r\n                const parsed = parseChannel(detail);\r\n                if (parsed) results.push(parsed);\r\n                break;\r\n            }\r\n            case 'playlist': {\r\n                const parsed = parsePlaylist(detail);\r\n                if (parsed) {\r\n                    if (options.unblurNSFWThumbnails && parsed.thumbnail) unblurThumbnail(parsed.thumbnail);\r\n                    results.push(parsed);\r\n                }\r\n                break;\r\n            }\r\n            default:\r\n                throw new Error(`Unknown search type: ${options.type}`);\r\n        }\r\n    }\r\n    return results;\r\n}\r\n/**\r\n * Function to convert [hour : minutes : seconds] format to seconds\r\n * @param duration hour : minutes : seconds format\r\n * @returns seconds\r\n */\r\nfunction parseDuration(duration: string): number {\r\n    if (!duration) return 0;\r\n    const args = duration.split(':');\r\n    let dur = 0;\r\n\r\n    switch (args.length) {\r\n        case 3:\r\n            dur = parseInt(args[0]) * 60 * 60 + parseInt(args[1]) * 60 + parseInt(args[2]);\r\n            break;\r\n        case 2:\r\n            dur = parseInt(args[0]) * 60 + parseInt(args[1]);\r\n            break;\r\n        default:\r\n            dur = parseInt(args[0]);\r\n    }\r\n\r\n    return dur;\r\n}\r\n/**\r\n * Function to parse Channel searches\r\n * @param data body of that channel request.\r\n * @returns YouTubeChannel class\r\n */\r\nexport function parseChannel(data?: any): YouTubeChannel {\r\n    if (!data || !data.channelRenderer) throw new Error('Failed to Parse YouTube Channel');\r\n    const badge = data.channelRenderer.ownerBadges?.[0]?.metadataBadgeRenderer?.style?.toLowerCase();\r\n    const url = `https://www.youtube.com${\r\n        data.channelRenderer.navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\r\n        data.channelRenderer.navigationEndpoint.commandMetadata.webCommandMetadata.url\r\n    }`;\r\n    const thumbnail = data.channelRenderer.thumbnail.thumbnails[data.channelRenderer.thumbnail.thumbnails.length - 1];\r\n    const res = new YouTubeChannel({\r\n        id: data.channelRenderer.channelId,\r\n        name: data.channelRenderer.title.simpleText,\r\n        icon: {\r\n            url: thumbnail.url.replace('//', 'https://'),\r\n            width: thumbnail.width,\r\n            height: thumbnail.height\r\n        },\r\n        url: url,\r\n        verified: Boolean(badge?.includes('verified')),\r\n        artist: Boolean(badge?.includes('artist')),\r\n        subscribers: data.channelRenderer.subscriberCountText?.simpleText ?? '0 subscribers'\r\n    });\r\n\r\n    return res;\r\n}\r\n/**\r\n * Function to parse Video searches\r\n * @param data body of that video request.\r\n * @returns YouTubeVideo class\r\n */\r\nexport function parseVideo(data?: any): YouTubeVideo {\r\n    if (!data || !data.videoRenderer) throw new Error('Failed to Parse YouTube Video');\r\n\r\n    const channel = data.videoRenderer.ownerText.runs[0];\r\n    const badge = data.videoRenderer.ownerBadges?.[0]?.metadataBadgeRenderer?.style?.toLowerCase();\r\n    const durationText = data.videoRenderer.lengthText;\r\n    const res = new YouTubeVideo({\r\n        id: data.videoRenderer.videoId,\r\n        url: `https://www.youtube.com/watch?v=${data.videoRenderer.videoId}`,\r\n        title: data.videoRenderer.title.runs[0].text,\r\n        description: data.videoRenderer.detailedMetadataSnippets?.[0].snippetText.runs?.length\r\n            ? data.videoRenderer.detailedMetadataSnippets[0].snippetText.runs.map((run: any) => run.text).join('')\r\n            : '',\r\n        duration: durationText ? parseDuration(durationText.simpleText) : 0,\r\n        duration_raw: durationText ? durationText.simpleText : null,\r\n        thumbnails: data.videoRenderer.thumbnail.thumbnails,\r\n        channel: {\r\n            id: channel.navigationEndpoint.browseEndpoint.browseId || null,\r\n            name: channel.text || null,\r\n            url: `https://www.youtube.com${\r\n                channel.navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\r\n                channel.navigationEndpoint.commandMetadata.webCommandMetadata.url\r\n            }`,\r\n            icons: data.videoRenderer.channelThumbnailSupportedRenderers.channelThumbnailWithLinkRenderer.thumbnail\r\n                .thumbnails,\r\n            verified: Boolean(badge?.includes('verified')),\r\n            artist: Boolean(badge?.includes('artist'))\r\n        },\r\n        uploadedAt: data.videoRenderer.publishedTimeText?.simpleText ?? null,\r\n        upcoming: data.videoRenderer.upcomingEventData?.startTime\r\n            ? new Date(parseInt(data.videoRenderer.upcomingEventData.startTime) * 1000)\r\n            : undefined,\r\n        views: data.videoRenderer.viewCountText?.simpleText?.replace(/\\D/g, '') ?? 0,\r\n        live: durationText ? false : true\r\n    });\r\n\r\n    return res;\r\n}\r\n/**\r\n * Function to parse Playlist searches\r\n * @param data body of that playlist request.\r\n * @returns YouTubePlaylist class\r\n */\r\nexport function parsePlaylist(data?: any): YouTubePlayList {\r\n    if (!data || !data.playlistRenderer) throw new Error('Failed to Parse YouTube Playlist');\r\n\r\n    const thumbnail =\r\n        data.playlistRenderer.thumbnails[0].thumbnails[data.playlistRenderer.thumbnails[0].thumbnails.length - 1];\r\n    const channel = data.playlistRenderer.shortBylineText.runs?.[0];\r\n\r\n    const res = new YouTubePlayList(\r\n        {\r\n            id: data.playlistRenderer.playlistId,\r\n            title: data.playlistRenderer.title.simpleText,\r\n            thumbnail: {\r\n                id: data.playlistRenderer.playlistId,\r\n                url: thumbnail.url,\r\n                height: thumbnail.height,\r\n                width: thumbnail.width\r\n            },\r\n            channel: {\r\n                id: channel?.navigationEndpoint.browseEndpoint.browseId,\r\n                name: channel?.text,\r\n                url: `https://www.youtube.com${channel?.navigationEndpoint.commandMetadata.webCommandMetadata.url}`\r\n            },\r\n            videos: parseInt(data.playlistRenderer.videoCount.replace(/\\D/g, ''))\r\n        },\r\n        true\r\n    );\r\n\r\n    return res;\r\n}\r\n\r\nfunction unblurThumbnail(thumbnail: YouTubeThumbnail) {\r\n    if (BLURRED_THUMBNAILS.find((sqp) => thumbnail.url.includes(sqp))) {\r\n        thumbnail.url = thumbnail.url.split('?')[0];\r\n\r\n        // we need to update the size parameters as the sqp parameter also included a cropped size\r\n        switch (thumbnail.url.split('/').at(-1)!.split('.')[0]) {\r\n            case 'hq2':\r\n            case 'hqdefault':\r\n                thumbnail.width = 480;\r\n                thumbnail.height = 360;\r\n                break;\r\n            case 'hq720':\r\n                thumbnail.width = 1280;\r\n                thumbnail.height = 720;\r\n                break;\r\n            case 'sddefault':\r\n                thumbnail.width = 640;\r\n                thumbnail.height = 480;\r\n                break;\r\n            case 'mqdefault':\r\n                thumbnail.width = 320;\r\n                thumbnail.height = 180;\r\n                break;\r\n            case 'default':\r\n                thumbnail.width = 120;\r\n                thumbnail.height = 90;\r\n                break;\r\n            default:\r\n                thumbnail.width = thumbnail.height = NaN;\r\n        }\r\n    }\r\n}\r\n","import { request } from './../Request';\r\nimport { ParseSearchInterface, ParseSearchResult } from './utils/parser';\r\nimport { YouTubeVideo } from './classes/Video';\r\nimport { YouTubeChannel } from './classes/Channel';\r\nimport { YouTubePlayList } from './classes/Playlist';\r\n\r\nenum SearchType {\r\n    Video = 'EgIQAQ%253D%253D',\r\n    PlayList = 'EgIQAw%253D%253D',\r\n    Channel = 'EgIQAg%253D%253D'\r\n}\r\n\r\n/**\r\n * Type for YouTube returns\r\n */\r\nexport type YouTube = YouTubeVideo | YouTubeChannel | YouTubePlayList;\r\n/**\r\n * Command to search from YouTube\r\n * @param search The query to search\r\n * @param options limit & type of YouTube search you want.\r\n * @returns YouTube type.\r\n */\r\nexport async function yt_search(search: string, options: ParseSearchInterface = {}): Promise<YouTube[]> {\r\n    let url = 'https://www.youtube.com/results?search_query=' + search;\r\n    options.type ??= 'video';\r\n    if (url.indexOf('&sp=') === -1) {\r\n        url += '&sp=';\r\n        switch (options.type) {\r\n            case 'channel':\r\n                url += SearchType.Channel;\r\n                break;\r\n            case 'playlist':\r\n                url += SearchType.PlayList;\r\n                break;\r\n            case 'video':\r\n                url += SearchType.Video;\r\n                break;\r\n            default:\r\n                throw new Error(`Unknown search type: ${options.type}`);\r\n        }\r\n    }\r\n    const body = await request(url, {\r\n        headers: {\r\n            'accept-language': options.language || 'en-US;q=0.9'\r\n        }\r\n    });\r\n    if (body.indexOf('Our systems have detected unusual traffic from your computer network.') !== -1)\r\n        throw new Error('Captcha page: YouTube has detected that you are a bot!');\r\n    return ParseSearchResult(body, options);\r\n}\r\n","import { request } from '../Request';\r\nimport { SpotifyDataOptions } from '.';\r\nimport { AlbumJSON, PlaylistJSON, TrackJSON } from './constants';\r\n\r\nexport interface SpotifyTrackAlbum {\r\n    /**\r\n     * Spotify Track Album name\r\n     */\r\n    name: string;\r\n    /**\r\n     * Spotify Track Album url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Spotify Track Album id\r\n     */\r\n    id: string;\r\n    /**\r\n     * Spotify Track Album release date\r\n     */\r\n    release_date: string;\r\n    /**\r\n     * Spotify Track Album release date **precise**\r\n     */\r\n    release_date_precision: string;\r\n    /**\r\n     * Spotify Track Album total tracks number\r\n     */\r\n    total_tracks: number;\r\n}\r\n\r\nexport interface SpotifyArtists {\r\n    /**\r\n     * Spotify Artist Name\r\n     */\r\n    name: string;\r\n    /**\r\n     * Spotify Artist Url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Spotify Artist ID\r\n     */\r\n    id: string;\r\n}\r\n\r\nexport interface SpotifyThumbnail {\r\n    /**\r\n     * Spotify Thumbnail height\r\n     */\r\n    height: number;\r\n    /**\r\n     * Spotify Thumbnail width\r\n     */\r\n    width: number;\r\n    /**\r\n     * Spotify Thumbnail url\r\n     */\r\n    url: string;\r\n}\r\n\r\nexport interface SpotifyCopyright {\r\n    /**\r\n     * Spotify Copyright Text\r\n     */\r\n    text: string;\r\n    /**\r\n     * Spotify Copyright Type\r\n     */\r\n    type: string;\r\n}\r\n/**\r\n * Spotify Track Class\r\n */\r\nexport class SpotifyTrack {\r\n    /**\r\n     * Spotify Track Name\r\n     */\r\n    name: string;\r\n    /**\r\n     * Spotify Class type. == \"track\"\r\n     */\r\n    type: 'track' | 'playlist' | 'album';\r\n    /**\r\n     * Spotify Track ID\r\n     */\r\n    id: string;\r\n    /**\r\n     * Spotify Track ISRC\r\n     */\r\n    isrc: string;\r\n    /**\r\n     * Spotify Track url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Spotify Track explicit info.\r\n     */\r\n    explicit: boolean;\r\n    /**\r\n     * Spotify Track playability info.\r\n     */\r\n    playable: boolean;\r\n    /**\r\n     * Spotify Track Duration in seconds\r\n     */\r\n    durationInSec: number;\r\n    /**\r\n     * Spotify Track Duration in milli seconds\r\n     */\r\n    durationInMs: number;\r\n    /**\r\n     * Spotify Track Artists data [ array ]\r\n     */\r\n    artists: SpotifyArtists[];\r\n    /**\r\n     * Spotify Track Album data\r\n     */\r\n    album: SpotifyTrackAlbum | undefined;\r\n    /**\r\n     * Spotify Track Thumbnail Data\r\n     */\r\n    thumbnail: SpotifyThumbnail | undefined;\r\n    /**\r\n     * Constructor for Spotify Track\r\n     * @param data\r\n     */\r\n    constructor(data: any) {\r\n        this.name = data.name;\r\n        this.id = data.id;\r\n        this.isrc = data.external_ids?.isrc || '';\r\n        this.type = 'track';\r\n        this.url = data.external_urls.spotify;\r\n        this.explicit = data.explicit;\r\n        this.playable = data.is_playable;\r\n        this.durationInMs = data.duration_ms;\r\n        this.durationInSec = Math.round(this.durationInMs / 1000);\r\n        const artists: SpotifyArtists[] = [];\r\n        data.artists.forEach((v: any) => {\r\n            artists.push({\r\n                name: v.name,\r\n                id: v.id,\r\n                url: v.external_urls.spotify\r\n            });\r\n        });\r\n        this.artists = artists;\r\n        if (!data.album?.name) this.album = undefined;\r\n        else {\r\n            this.album = {\r\n                name: data.album.name,\r\n                url: data.external_urls.spotify,\r\n                id: data.album.id,\r\n                release_date: data.album.release_date,\r\n                release_date_precision: data.album.release_date_precision,\r\n                total_tracks: data.album.total_tracks\r\n            };\r\n        }\r\n        if (!data.album?.images?.[0]) this.thumbnail = undefined;\r\n        else this.thumbnail = data.album.images[0];\r\n    }\r\n\r\n    toJSON(): TrackJSON {\r\n        return {\r\n            name: this.name,\r\n            id: this.id,\r\n            url: this.url,\r\n            explicit: this.explicit,\r\n            durationInMs: this.durationInMs,\r\n            durationInSec: this.durationInSec,\r\n            artists: this.artists,\r\n            album: this.album,\r\n            thumbnail: this.thumbnail\r\n        };\r\n    }\r\n}\r\n/**\r\n * Spotify Playlist Class\r\n */\r\nexport class SpotifyPlaylist {\r\n    /**\r\n     * Spotify Playlist Name\r\n     */\r\n    name: string;\r\n    /**\r\n     * Spotify Class type. == \"playlist\"\r\n     */\r\n    type: 'track' | 'playlist' | 'album';\r\n    /**\r\n     * Spotify Playlist collaborative boolean.\r\n     */\r\n    collaborative: boolean;\r\n    /**\r\n     * Spotify Playlist Description\r\n     */\r\n    description: string;\r\n    /**\r\n     * Spotify Playlist URL\r\n     */\r\n    url: string;\r\n    /**\r\n     * Spotify Playlist ID\r\n     */\r\n    id: string;\r\n    /**\r\n     * Spotify Playlist Thumbnail Data\r\n     */\r\n    thumbnail: SpotifyThumbnail;\r\n    /**\r\n     * Spotify Playlist Owner Artist data\r\n     */\r\n    owner: SpotifyArtists;\r\n    /**\r\n     * Spotify Playlist total tracks Count\r\n     */\r\n    tracksCount: number;\r\n    /**\r\n     * Spotify Playlist Spotify data\r\n     *\r\n     * @private\r\n     */\r\n    private spotifyData: SpotifyDataOptions;\r\n    /**\r\n     * Spotify Playlist fetched tracks Map\r\n     *\r\n     * @private\r\n     */\r\n    private fetched_tracks: Map<string, SpotifyTrack[]>;\r\n    /**\r\n     * Boolean to tell whether it is a searched result or not.\r\n     */\r\n    private readonly search: boolean;\r\n    /**\r\n     * Constructor for Spotify Playlist Class\r\n     * @param data JSON parsed data of playlist\r\n     * @param spotifyData Data about sporify token for furhter fetching.\r\n     */\r\n    constructor(data: any, spotifyData: SpotifyDataOptions, search: boolean) {\r\n        this.name = data.name;\r\n        this.type = 'playlist';\r\n        this.search = search;\r\n        this.collaborative = data.collaborative;\r\n        this.description = data.description;\r\n        this.url = data.external_urls.spotify;\r\n        this.id = data.id;\r\n        this.thumbnail = data.images[0];\r\n        this.owner = {\r\n            name: data.owner.display_name,\r\n            url: data.owner.external_urls.spotify,\r\n            id: data.owner.id\r\n        };\r\n        this.tracksCount = Number(data.tracks.total);\r\n        const videos: SpotifyTrack[] = [];\r\n        if (!this.search)\r\n            data.tracks.items.forEach((v: any) => {\r\n                if (v.track) videos.push(new SpotifyTrack(v.track));\r\n            });\r\n        this.fetched_tracks = new Map();\r\n        this.fetched_tracks.set('1', videos);\r\n        this.spotifyData = spotifyData;\r\n    }\r\n    /**\r\n     * Fetches Spotify Playlist tracks more than 100 tracks.\r\n     *\r\n     * For getting all tracks in playlist, see `total_pages` property.\r\n     * @returns Playlist Class.\r\n     */\r\n    async fetch() {\r\n        if (this.search) return this;\r\n        let fetching: number;\r\n        if (this.tracksCount > 1000) fetching = 1000;\r\n        else fetching = this.tracksCount;\r\n        if (fetching <= 100) return this;\r\n        const work = [];\r\n        for (let i = 2; i <= Math.ceil(fetching / 100); i++) {\r\n            work.push(\r\n                new Promise(async (resolve, reject) => {\r\n                    const response = await request(\r\n                        `https://api.spotify.com/v1/playlists/${this.id}/tracks?offset=${\r\n                            (i - 1) * 100\r\n                        }&limit=100&market=${this.spotifyData.market}`,\r\n                        {\r\n                            headers: {\r\n                                Authorization: `${this.spotifyData.token_type} ${this.spotifyData.access_token}`\r\n                            }\r\n                        }\r\n                    ).catch((err) => reject(`Response Error : \\n${err}`));\r\n                    const videos: SpotifyTrack[] = [];\r\n                    if (typeof response !== 'string') return;\r\n                    const json_data = JSON.parse(response);\r\n                    json_data.items.forEach((v: any) => {\r\n                        if (v.track) videos.push(new SpotifyTrack(v.track));\r\n                    });\r\n                    this.fetched_tracks.set(`${i}`, videos);\r\n                    resolve('Success');\r\n                })\r\n            );\r\n        }\r\n        await Promise.allSettled(work);\r\n        return this;\r\n    }\r\n    /**\r\n     * Spotify Playlist tracks are divided in pages.\r\n     *\r\n     * For example getting data of 101 - 200 videos in a playlist,\r\n     *\r\n     * ```ts\r\n     * const playlist = await play.spotify('playlist url')\r\n     *\r\n     * await playlist.fetch()\r\n     *\r\n     * const result = playlist.page(2)\r\n     * ```\r\n     * @param num Page Number\r\n     * @returns\r\n     */\r\n    page(num: number) {\r\n        if (!num) throw new Error('Page number is not provided');\r\n        if (!this.fetched_tracks.has(`${num}`)) throw new Error('Given Page number is invalid');\r\n        return this.fetched_tracks.get(`${num}`) as SpotifyTrack[];\r\n    }\r\n    /**\r\n     * Gets total number of pages in that playlist class.\r\n     * @see {@link SpotifyPlaylist.all_tracks}\r\n     */\r\n    get total_pages() {\r\n        return this.fetched_tracks.size;\r\n    }\r\n    /**\r\n     * Spotify Playlist total no of tracks that have been fetched so far.\r\n     */\r\n    get total_tracks() {\r\n        if (this.search) return this.tracksCount;\r\n        const page_number: number = this.total_pages;\r\n        return (page_number - 1) * 100 + (this.fetched_tracks.get(`${page_number}`) as SpotifyTrack[]).length;\r\n    }\r\n    /**\r\n     * Fetches all the tracks in the playlist and returns them\r\n     *\r\n     * ```ts\r\n     * const playlist = await play.spotify('playlist url')\r\n     *\r\n     * const tracks = await playlist.all_tracks()\r\n     * ```\r\n     * @returns An array of {@link SpotifyTrack}\r\n     */\r\n    async all_tracks(): Promise<SpotifyTrack[]> {\r\n        await this.fetch();\r\n\r\n        const tracks: SpotifyTrack[] = [];\r\n\r\n        for (const page of this.fetched_tracks.values()) tracks.push(...page);\r\n\r\n        return tracks;\r\n    }\r\n    /**\r\n     * Converts Class to JSON\r\n     * @returns JSON data\r\n     */\r\n    toJSON(): PlaylistJSON {\r\n        return {\r\n            name: this.name,\r\n            collaborative: this.collaborative,\r\n            description: this.description,\r\n            url: this.url,\r\n            id: this.id,\r\n            thumbnail: this.thumbnail,\r\n            owner: this.owner,\r\n            tracksCount: this.tracksCount\r\n        };\r\n    }\r\n}\r\n/**\r\n * Spotify Album Class\r\n */\r\nexport class SpotifyAlbum {\r\n    /**\r\n     * Spotify Album Name\r\n     */\r\n    name: string;\r\n    /**\r\n     * Spotify Class type. == \"album\"\r\n     */\r\n    type: 'track' | 'playlist' | 'album';\r\n    /**\r\n     * Spotify Album url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Spotify Album id\r\n     */\r\n    id: string;\r\n    /**\r\n     * Spotify Album Thumbnail data\r\n     */\r\n    thumbnail: SpotifyThumbnail;\r\n    /**\r\n     * Spotify Album artists [ array ]\r\n     */\r\n    artists: SpotifyArtists[];\r\n    /**\r\n     * Spotify Album copyright data [ array ]\r\n     */\r\n    copyrights: SpotifyCopyright[];\r\n    /**\r\n     * Spotify Album Release date\r\n     */\r\n    release_date: string;\r\n    /**\r\n     * Spotify Album Release Date **precise**\r\n     */\r\n    release_date_precision: string;\r\n    /**\r\n     * Spotify Album total no of tracks\r\n     */\r\n    tracksCount: number;\r\n    /**\r\n     * Spotify Album Spotify data\r\n     *\r\n     * @private\r\n     */\r\n    private spotifyData: SpotifyDataOptions;\r\n    /**\r\n     * Spotify Album fetched tracks Map\r\n     *\r\n     * @private\r\n     */\r\n    private fetched_tracks: Map<string, SpotifyTrack[]>;\r\n    /**\r\n     * Boolean to tell whether it is a searched result or not.\r\n     */\r\n    private readonly search: boolean;\r\n    /**\r\n     * Constructor for Spotify Album Class\r\n     * @param data Json parsed album data\r\n     * @param spotifyData Spotify credentials\r\n     */\r\n    constructor(data: any, spotifyData: SpotifyDataOptions, search: boolean) {\r\n        this.name = data.name;\r\n        this.type = 'album';\r\n        this.id = data.id;\r\n        this.search = search;\r\n        this.url = data.external_urls.spotify;\r\n        this.thumbnail = data.images[0];\r\n        const artists: SpotifyArtists[] = [];\r\n        data.artists.forEach((v: any) => {\r\n            artists.push({\r\n                name: v.name,\r\n                id: v.id,\r\n                url: v.external_urls.spotify\r\n            });\r\n        });\r\n        this.artists = artists;\r\n        this.copyrights = data.copyrights;\r\n        this.release_date = data.release_date;\r\n        this.release_date_precision = data.release_date_precision;\r\n        this.tracksCount = data.total_tracks;\r\n        const videos: SpotifyTrack[] = [];\r\n        if (!this.search)\r\n            data.tracks.items.forEach((v: any) => {\r\n                videos.push(new SpotifyTrack(v));\r\n            });\r\n        this.fetched_tracks = new Map();\r\n        this.fetched_tracks.set('1', videos);\r\n        this.spotifyData = spotifyData;\r\n    }\r\n    /**\r\n     * Fetches Spotify Album tracks more than 50 tracks.\r\n     *\r\n     * For getting all tracks in album, see `total_pages` property.\r\n     * @returns Album Class.\r\n     */\r\n    async fetch() {\r\n        if (this.search) return this;\r\n        let fetching: number;\r\n        if (this.tracksCount > 500) fetching = 500;\r\n        else fetching = this.tracksCount;\r\n        if (fetching <= 50) return this;\r\n        const work = [];\r\n        for (let i = 2; i <= Math.ceil(fetching / 50); i++) {\r\n            work.push(\r\n                new Promise(async (resolve, reject) => {\r\n                    const response = await request(\r\n                        `https://api.spotify.com/v1/albums/${this.id}/tracks?offset=${(i - 1) * 50}&limit=50&market=${\r\n                            this.spotifyData.market\r\n                        }`,\r\n                        {\r\n                            headers: {\r\n                                Authorization: `${this.spotifyData.token_type} ${this.spotifyData.access_token}`\r\n                            }\r\n                        }\r\n                    ).catch((err) => reject(`Response Error : \\n${err}`));\r\n                    const videos: SpotifyTrack[] = [];\r\n                    if (typeof response !== 'string') return;\r\n                    const json_data = JSON.parse(response);\r\n                    json_data.items.forEach((v: any) => {\r\n                        if (v) videos.push(new SpotifyTrack(v));\r\n                    });\r\n                    this.fetched_tracks.set(`${i}`, videos);\r\n                    resolve('Success');\r\n                })\r\n            );\r\n        }\r\n        await Promise.allSettled(work);\r\n        return this;\r\n    }\r\n    /**\r\n     * Spotify Album tracks are divided in pages.\r\n     *\r\n     * For example getting data of 51 - 100 videos in a album,\r\n     *\r\n     * ```ts\r\n     * const album = await play.spotify('album url')\r\n     *\r\n     * await album.fetch()\r\n     *\r\n     * const result = album.page(2)\r\n     * ```\r\n     * @param num Page Number\r\n     * @returns\r\n     */\r\n    page(num: number) {\r\n        if (!num) throw new Error('Page number is not provided');\r\n        if (!this.fetched_tracks.has(`${num}`)) throw new Error('Given Page number is invalid');\r\n        return this.fetched_tracks.get(`${num}`);\r\n    }\r\n    /**\r\n     * Gets total number of pages in that album class.\r\n     * @see {@link SpotifyAlbum.all_tracks}\r\n     */\r\n    get total_pages() {\r\n        return this.fetched_tracks.size;\r\n    }\r\n    /**\r\n     * Spotify Album total no of tracks that have been fetched so far.\r\n     */\r\n    get total_tracks() {\r\n        if (this.search) return this.tracksCount;\r\n        const page_number: number = this.total_pages;\r\n        return (page_number - 1) * 100 + (this.fetched_tracks.get(`${page_number}`) as SpotifyTrack[]).length;\r\n    }\r\n    /**\r\n     * Fetches all the tracks in the album and returns them\r\n     *\r\n     * ```ts\r\n     * const album = await play.spotify('album url')\r\n     *\r\n     * const tracks = await album.all_tracks()\r\n     * ```\r\n     * @returns An array of {@link SpotifyTrack}\r\n     */\r\n    async all_tracks(): Promise<SpotifyTrack[]> {\r\n        await this.fetch();\r\n\r\n        const tracks: SpotifyTrack[] = [];\r\n\r\n        for (const page of this.fetched_tracks.values()) tracks.push(...page);\r\n\r\n        return tracks;\r\n    }\r\n    /**\r\n     * Converts Class to JSON\r\n     * @returns JSON data\r\n     */\r\n    toJSON(): AlbumJSON {\r\n        return {\r\n            name: this.name,\r\n            id: this.id,\r\n            type: this.type,\r\n            url: this.url,\r\n            thumbnail: this.thumbnail,\r\n            artists: this.artists,\r\n            copyrights: this.copyrights,\r\n            release_date: this.release_date,\r\n            release_date_precision: this.release_date_precision,\r\n            tracksCount: this.tracksCount\r\n        };\r\n    }\r\n}\r\n","import { request } from '../Request';\r\nimport { SpotifyAlbum, SpotifyPlaylist, SpotifyTrack } from './classes';\r\nimport { existsSync, readFileSync, writeFileSync } from 'node:fs';\r\n\r\nlet spotifyData: SpotifyDataOptions;\r\nif (existsSync('.data/spotify.data')) {\r\n    spotifyData = JSON.parse(readFileSync('.data/spotify.data', 'utf-8'));\r\n    spotifyData.file = true;\r\n}\r\n/**\r\n * Spotify Data options that are stored in spotify.data file.\r\n */\r\nexport interface SpotifyDataOptions {\r\n    client_id: string;\r\n    client_secret: string;\r\n    redirect_url?: string;\r\n    authorization_code?: string;\r\n    access_token?: string;\r\n    refresh_token?: string;\r\n    token_type?: string;\r\n    expires_in?: number;\r\n    expiry?: number;\r\n    market?: string;\r\n    file?: boolean;\r\n}\r\n\r\nconst pattern = /^((https:)?\\/\\/)?open.spotify.com\\/(track|album|playlist)\\//;\r\n/**\r\n * Gets Spotify url details.\r\n *\r\n * ```ts\r\n * let spot = await play.spotify('spotify url')\r\n *\r\n * // spot.type === \"track\" | \"playlist\" | \"album\"\r\n *\r\n * if (spot.type === \"track\") {\r\n *      spot = spot as play.SpotifyTrack\r\n *      // Code with spotify track class.\r\n * }\r\n * ```\r\n * @param url Spotify Url\r\n * @returns A {@link SpotifyTrack} or {@link SpotifyPlaylist} or {@link SpotifyAlbum}\r\n */\r\nexport async function spotify(url: string): Promise<Spotify> {\r\n    if (!spotifyData) throw new Error('Spotify Data is missing\\nDid you forgot to do authorization ?');\r\n    const url_ = url.trim();\r\n    if (!url_.match(pattern)) throw new Error('This is not a Spotify URL');\r\n    if (url_.indexOf('track/') !== -1) {\r\n        const trackID = url_.split('track/')[1].split('&')[0].split('?')[0];\r\n        const response = await request(`https://api.spotify.com/v1/tracks/${trackID}?market=${spotifyData.market}`, {\r\n            headers: {\r\n                Authorization: `${spotifyData.token_type} ${spotifyData.access_token}`\r\n            }\r\n        }).catch((err: Error) => {\r\n            return err;\r\n        });\r\n        if (response instanceof Error) throw response;\r\n        return new SpotifyTrack(JSON.parse(response));\r\n    } else if (url_.indexOf('album/') !== -1) {\r\n        const albumID = url.split('album/')[1].split('&')[0].split('?')[0];\r\n        const response = await request(`https://api.spotify.com/v1/albums/${albumID}?market=${spotifyData.market}`, {\r\n            headers: {\r\n                Authorization: `${spotifyData.token_type} ${spotifyData.access_token}`\r\n            }\r\n        }).catch((err: Error) => {\r\n            return err;\r\n        });\r\n        if (response instanceof Error) throw response;\r\n        return new SpotifyAlbum(JSON.parse(response), spotifyData, false);\r\n    } else if (url_.indexOf('playlist/') !== -1) {\r\n        const playlistID = url.split('playlist/')[1].split('&')[0].split('?')[0];\r\n        const response = await request(\r\n            `https://api.spotify.com/v1/playlists/${playlistID}?market=${spotifyData.market}`,\r\n            {\r\n                headers: {\r\n                    Authorization: `${spotifyData.token_type} ${spotifyData.access_token}`\r\n                }\r\n            }\r\n        ).catch((err: Error) => {\r\n            return err;\r\n        });\r\n        if (response instanceof Error) throw response;\r\n        return new SpotifyPlaylist(JSON.parse(response), spotifyData, false);\r\n    } else throw new Error('URL is out of scope for play-dl.');\r\n}\r\n/**\r\n * Validate Spotify url\r\n * @param url Spotify URL\r\n * @returns\r\n * ```ts\r\n * 'track' | 'playlist' | 'album' | 'search' | false\r\n * ```\r\n */\r\nexport function sp_validate(url: string): 'track' | 'playlist' | 'album' | 'search' | false {\r\n    const url_ = url.trim();\r\n    if (!url_.startsWith('https')) return 'search';\r\n    if (!url_.match(pattern)) return false;\r\n    if (url_.indexOf('track/') !== -1) {\r\n        return 'track';\r\n    } else if (url_.indexOf('album/') !== -1) {\r\n        return 'album';\r\n    } else if (url_.indexOf('playlist/') !== -1) {\r\n        return 'playlist';\r\n    } else return false;\r\n}\r\n/**\r\n * Fuction for authorizing for spotify data.\r\n * @param data Sportify Data options to validate\r\n * @returns boolean.\r\n */\r\nexport async function SpotifyAuthorize(data: SpotifyDataOptions, file: boolean): Promise<boolean> {\r\n    const response = await request(`https://accounts.spotify.com/api/token`, {\r\n        headers: {\r\n            'Authorization': `Basic ${Buffer.from(`${data.client_id}:${data.client_secret}`).toString('base64')}`,\r\n            'Content-Type': 'application/x-www-form-urlencoded'\r\n        },\r\n        body: `grant_type=authorization_code&code=${data.authorization_code}&redirect_uri=${encodeURI(\r\n            data.redirect_url as string\r\n        )}`,\r\n        method: 'POST'\r\n    }).catch((err: Error) => {\r\n        return err;\r\n    });\r\n    if (response instanceof Error) throw response;\r\n    const resp_json = JSON.parse(response);\r\n    spotifyData = {\r\n        client_id: data.client_id,\r\n        client_secret: data.client_secret,\r\n        redirect_url: data.redirect_url,\r\n        access_token: resp_json.access_token,\r\n        refresh_token: resp_json.refresh_token,\r\n        expires_in: Number(resp_json.expires_in),\r\n        expiry: Date.now() + (resp_json.expires_in - 1) * 1000,\r\n        token_type: resp_json.token_type,\r\n        market: data.market\r\n    };\r\n    if (file) writeFileSync('.data/spotify.data', JSON.stringify(spotifyData, undefined, 4));\r\n    else {\r\n        console.log(`Client ID : ${spotifyData.client_id}`);\r\n        console.log(`Client Secret : ${spotifyData.client_secret}`);\r\n        console.log(`Refresh Token : ${spotifyData.refresh_token}`);\r\n        console.log(`Market : ${spotifyData.market}`);\r\n        console.log(`\\nPaste above info in setToken function.`);\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Checks if spotify token is expired or not.\r\n *\r\n * Update token if returned false.\r\n * ```ts\r\n * if (play.is_expired()) {\r\n *      await play.refreshToken()\r\n * }\r\n * ```\r\n * @returns boolean\r\n */\r\nexport function is_expired(): boolean {\r\n    if (Date.now() >= (spotifyData.expiry as number)) return true;\r\n    else return false;\r\n}\r\n/**\r\n * type for Spotify Classes\r\n */\r\nexport type Spotify = SpotifyAlbum | SpotifyPlaylist | SpotifyTrack;\r\n/**\r\n * Function for searching songs on Spotify\r\n * @param query searching query\r\n * @param type \"album\" | \"playlist\" | \"track\"\r\n * @param limit max no of results\r\n * @returns Spotify type.\r\n */\r\nexport async function sp_search(\r\n    query: string,\r\n    type: 'album' | 'playlist' | 'track',\r\n    limit: number = 10\r\n): Promise<Spotify[]> {\r\n    const results: Spotify[] = [];\r\n    if (!spotifyData) throw new Error('Spotify Data is missing\\nDid you forget to do authorization ?');\r\n    if (query.length === 0) throw new Error('Pass some query to search.');\r\n    if (limit > 50 || limit < 0) throw new Error(`You crossed limit range of Spotify [ 0 - 50 ]`);\r\n    const response = await request(\r\n        `https://api.spotify.com/v1/search?type=${type}&q=${query}&limit=${limit}&market=${spotifyData.market}`,\r\n        {\r\n            headers: {\r\n                Authorization: `${spotifyData.token_type} ${spotifyData.access_token}`\r\n            }\r\n        }\r\n    ).catch((err: Error) => {\r\n        return err;\r\n    });\r\n    if (response instanceof Error) throw response;\r\n    const json_data = JSON.parse(response);\r\n    if (type === 'track') {\r\n        json_data.tracks.items.forEach((track: any) => {\r\n            results.push(new SpotifyTrack(track));\r\n        });\r\n    } else if (type === 'album') {\r\n        json_data.albums.items.forEach((album: any) => {\r\n            results.push(new SpotifyAlbum(album, spotifyData, true));\r\n        });\r\n    } else if (type === 'playlist') {\r\n        json_data.playlists.items.forEach((playlist: any) => {\r\n            results.push(new SpotifyPlaylist(playlist, spotifyData, true));\r\n        });\r\n    }\r\n    return results;\r\n}\r\n/**\r\n * Refreshes Token\r\n *\r\n * ```ts\r\n * if (play.is_expired()) {\r\n *      await play.refreshToken()\r\n * }\r\n * ```\r\n * @returns boolean\r\n */\r\nexport async function refreshToken(): Promise<boolean> {\r\n    const response = await request(`https://accounts.spotify.com/api/token`, {\r\n        headers: {\r\n            'Authorization': `Basic ${Buffer.from(`${spotifyData.client_id}:${spotifyData.client_secret}`).toString(\r\n                'base64'\r\n            )}`,\r\n            'Content-Type': 'application/x-www-form-urlencoded'\r\n        },\r\n        body: `grant_type=refresh_token&refresh_token=${spotifyData.refresh_token}`,\r\n        method: 'POST'\r\n    }).catch((err: Error) => {\r\n        return err;\r\n    });\r\n    if (response instanceof Error) return false;\r\n    const resp_json = JSON.parse(response);\r\n    spotifyData.access_token = resp_json.access_token;\r\n    spotifyData.expires_in = Number(resp_json.expires_in);\r\n    spotifyData.expiry = Date.now() + (resp_json.expires_in - 1) * 1000;\r\n    spotifyData.token_type = resp_json.token_type;\r\n    if (spotifyData.file) writeFileSync('.data/spotify.data', JSON.stringify(spotifyData, undefined, 4));\r\n    return true;\r\n}\r\n\r\nexport async function setSpotifyToken(options: SpotifyDataOptions) {\r\n    spotifyData = options;\r\n    spotifyData.file = false;\r\n    await refreshToken();\r\n}\r\n\r\nexport { SpotifyTrack, SpotifyAlbum, SpotifyPlaylist };\r\n","import { existsSync, readFileSync } from 'node:fs';\r\nimport { StreamType } from '../YouTube/stream';\r\nimport { request } from '../Request';\r\nimport { SoundCloudPlaylist, SoundCloudTrack, SoundCloudTrackFormat, SoundCloudStream } from './classes';\r\nlet soundData: SoundDataOptions;\r\nif (existsSync('.data/soundcloud.data')) {\r\n    soundData = JSON.parse(readFileSync('.data/soundcloud.data', 'utf-8'));\r\n}\r\n\r\ninterface SoundDataOptions {\r\n    client_id: string;\r\n}\r\n\r\nconst pattern = /^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?(api\\.soundcloud\\.com|soundcloud\\.com|snd\\.sc)\\/(.*)$/;\r\n/**\r\n * Gets info from a soundcloud url.\r\n *\r\n * ```ts\r\n * let sound = await play.soundcloud('soundcloud url')\r\n *\r\n * // sound.type === \"track\" | \"playlist\" | \"user\"\r\n *\r\n * if (sound.type === \"track\") {\r\n *      spot = spot as play.SoundCloudTrack\r\n *      // Code with SoundCloud track class.\r\n * }\r\n * ```\r\n * @param url soundcloud url\r\n * @returns A {@link SoundCloudTrack} or {@link SoundCloudPlaylist}\r\n */\r\nexport async function soundcloud(url: string): Promise<SoundCloud> {\r\n    if (!soundData) throw new Error('SoundCloud Data is missing\\nDid you forget to do authorization ?');\r\n    const url_ = url.trim();\r\n    if (!url_.match(pattern)) throw new Error('This is not a SoundCloud URL');\r\n\r\n    const data = await request(\r\n        `https://api-v2.soundcloud.com/resolve?url=${url_}&client_id=${soundData.client_id}`\r\n    ).catch((err: Error) => err);\r\n\r\n    if (data instanceof Error) throw data;\r\n\r\n    const json_data = JSON.parse(data);\r\n\r\n    if (json_data.kind !== 'track' && json_data.kind !== 'playlist')\r\n        throw new Error('This url is out of scope for play-dl.');\r\n\r\n    if (json_data.kind === 'track') return new SoundCloudTrack(json_data);\r\n    else return new SoundCloudPlaylist(json_data, soundData.client_id);\r\n}\r\n/**\r\n * Type of SoundCloud\r\n */\r\nexport type SoundCloud = SoundCloudTrack | SoundCloudPlaylist;\r\n/**\r\n * Function for searching in SoundCloud\r\n * @param query query to search\r\n * @param type 'tracks' | 'playlists' | 'albums'\r\n * @param limit max no. of results\r\n * @returns Array of SoundCloud type.\r\n */\r\nexport async function so_search(\r\n    query: string,\r\n    type: 'tracks' | 'playlists' | 'albums',\r\n    limit: number = 10\r\n): Promise<SoundCloud[]> {\r\n    const response = await request(\r\n        `https://api-v2.soundcloud.com/search/${type}?q=${query}&client_id=${soundData.client_id}&limit=${limit}`\r\n    );\r\n    const results: (SoundCloudPlaylist | SoundCloudTrack)[] = [];\r\n    const json_data = JSON.parse(response);\r\n    json_data.collection.forEach((x: any) => {\r\n        if (type === 'tracks') results.push(new SoundCloudTrack(x));\r\n        else results.push(new SoundCloudPlaylist(x, soundData.client_id));\r\n    });\r\n    return results;\r\n}\r\n/**\r\n * Main Function for creating a Stream of soundcloud\r\n * @param url soundcloud url\r\n * @param quality Quality to select from\r\n * @returns SoundCloud Stream\r\n */\r\nexport async function stream(url: string, quality?: number): Promise<SoundCloudStream> {\r\n    const data = await soundcloud(url);\r\n\r\n    if (data instanceof SoundCloudPlaylist) throw new Error(\"Streams can't be created from playlist urls\");\r\n\r\n    const HLSformats = parseHlsFormats(data.formats);\r\n    if (typeof quality !== 'number') quality = HLSformats.length - 1;\r\n    else if (quality <= 0) quality = 0;\r\n    else if (quality >= HLSformats.length) quality = HLSformats.length - 1;\r\n    const req_url = HLSformats[quality].url + '?client_id=' + soundData.client_id;\r\n    const s_data = JSON.parse(await request(req_url));\r\n    const type = HLSformats[quality].format.mime_type.startsWith('audio/ogg')\r\n        ? StreamType.OggOpus\r\n        : StreamType.Arbitrary;\r\n    return new SoundCloudStream(s_data.url, type);\r\n}\r\n/**\r\n * Gets Free SoundCloud Client ID.\r\n *\r\n * Use this in beginning of your code to add SoundCloud support.\r\n *\r\n * ```ts\r\n * play.getFreeClientID().then((clientID) => play.setToken({\r\n *      soundcloud : {\r\n *          client_id : clientID\r\n *      }\r\n * }))\r\n * ```\r\n * @returns client ID\r\n */\r\nexport async function getFreeClientID(): Promise<string> {\r\n    const data = await request('https://soundcloud.com/');\r\n    const splitted = data.split('<script crossorigin src=\"');\r\n    const urls: string[] = [];\r\n    splitted.forEach((r) => {\r\n        if (r.startsWith('https')) {\r\n            urls.push(r.split('\"')[0]);\r\n        }\r\n    });\r\n    const data2 = await request(urls[urls.length - 1]);\r\n    return data2.split(',client_id:\"')[1].split('\"')[0];\r\n}\r\n/**\r\n * Function for creating a Stream of soundcloud using a SoundCloud Track Class\r\n * @param data SoundCloud Track Class\r\n * @param quality Quality to select from\r\n * @returns SoundCloud Stream\r\n */\r\nexport async function stream_from_info(data: SoundCloudTrack, quality?: number): Promise<SoundCloudStream> {\r\n    const HLSformats = parseHlsFormats(data.formats);\r\n    if (typeof quality !== 'number') quality = HLSformats.length - 1;\r\n    else if (quality <= 0) quality = 0;\r\n    else if (quality >= HLSformats.length) quality = HLSformats.length - 1;\r\n    const req_url = HLSformats[quality].url + '?client_id=' + soundData.client_id;\r\n    const s_data = JSON.parse(await request(req_url));\r\n    const type = HLSformats[quality].format.mime_type.startsWith('audio/ogg')\r\n        ? StreamType.OggOpus\r\n        : StreamType.Arbitrary;\r\n    return new SoundCloudStream(s_data.url, type);\r\n}\r\n/**\r\n * Function to check client ID\r\n * @param id Client ID\r\n * @returns boolean\r\n */\r\nexport async function check_id(id: string): Promise<boolean> {\r\n    const response = await request(`https://api-v2.soundcloud.com/search?client_id=${id}&q=Rick+Roll&limit=0`).catch(\r\n        (err: Error) => {\r\n            return err;\r\n        }\r\n    );\r\n    if (response instanceof Error) return false;\r\n    else return true;\r\n}\r\n/**\r\n * Validates a soundcloud url\r\n * @param url soundcloud url\r\n * @returns\r\n * ```ts\r\n * false | 'track' | 'playlist'\r\n * ```\r\n */\r\nexport async function so_validate(url: string): Promise<false | 'track' | 'playlist' | 'search'> {\r\n    const url_ = url.trim();\r\n    if (!url_.startsWith('https')) return 'search';\r\n    if (!url_.match(pattern)) return false;\r\n    const data = await request(\r\n        `https://api-v2.soundcloud.com/resolve?url=${url_}&client_id=${soundData.client_id}`\r\n    ).catch((err: Error) => err);\r\n\r\n    if (data instanceof Error) return false;\r\n\r\n    const json_data = JSON.parse(data);\r\n    if (json_data.kind === 'track') return 'track';\r\n    else if (json_data.kind === 'playlist') return 'playlist';\r\n    else return false;\r\n}\r\n/**\r\n * Function to select only hls streams from SoundCloud format array\r\n * @param data SoundCloud Track Format data\r\n * @returns HLS Formats Array\r\n */\r\nfunction parseHlsFormats(data: SoundCloudTrackFormat[]) {\r\n    const result: SoundCloudTrackFormat[] = [];\r\n    data.forEach((format) => {\r\n        if (format.format.protocol === 'hls') result.push(format);\r\n    });\r\n    return result;\r\n}\r\n\r\nexport function setSoundCloudToken(options: SoundDataOptions) {\r\n    soundData = options;\r\n}\r\n\r\nexport { SoundCloudTrack, SoundCloudPlaylist, SoundCloudStream };\r\n","import { request, request_stream } from '../Request';\r\nimport { Readable } from 'node:stream';\r\nimport { IncomingMessage } from 'node:http';\r\nimport { StreamType } from '../YouTube/stream';\r\nimport { Timer } from '../YouTube/classes/LiveStream';\r\nimport { PlaylistJSON, SoundTrackJSON } from './constants';\r\n\r\nexport interface SoundCloudUser {\r\n    /**\r\n     * SoundCloud User Name\r\n     */\r\n    name: string;\r\n    /**\r\n     * SoundCloud User ID\r\n     */\r\n    id: string;\r\n    /**\r\n     * SoundCloud User URL\r\n     */\r\n    url: string;\r\n    /**\r\n     * SoundCloud Class type. == \"user\"\r\n     */\r\n    type: 'track' | 'playlist' | 'user';\r\n    /**\r\n     * SoundCloud User Verified status\r\n     */\r\n    verified: boolean;\r\n    /**\r\n     * SoundCloud User Description\r\n     */\r\n    description: string;\r\n    /**\r\n     * SoundCloud User First Name\r\n     */\r\n    first_name: string;\r\n    /**\r\n     * SoundCloud User Full Name\r\n     */\r\n    full_name: string;\r\n    /**\r\n     * SoundCloud User Last Name\r\n     */\r\n    last_name: string;\r\n    /**\r\n     * SoundCloud User thumbnail URL\r\n     */\r\n    thumbnail: string;\r\n}\r\n\r\nexport interface SoundCloudTrackDeprecated {\r\n    /**\r\n     * SoundCloud Track fetched status\r\n     */\r\n    fetched: boolean;\r\n    /**\r\n     * SoundCloud Track ID\r\n     */\r\n    id: number;\r\n    /**\r\n     * SoundCloud Class type. == \"track\"\r\n     */\r\n    type: 'track';\r\n}\r\n\r\nexport interface SoundCloudTrackFormat {\r\n    /**\r\n     * SoundCloud Track Format Url\r\n     */\r\n    url: string;\r\n    /**\r\n     * SoundCloud Track Format preset\r\n     */\r\n    preset: string;\r\n    /**\r\n     * SoundCloud Track Format Duration\r\n     */\r\n    duration: number;\r\n    /**\r\n     * SoundCloud Track Format data containing protocol and mime_type\r\n     */\r\n    format: {\r\n        protocol: string;\r\n        mime_type: string;\r\n    };\r\n    /**\r\n     * SoundCloud Track Format quality\r\n     */\r\n    quality: string;\r\n}\r\n/**\r\n * SoundCloud Track Class\r\n */\r\nexport class SoundCloudTrack {\r\n    /**\r\n     * SoundCloud Track Name\r\n     */\r\n    name: string;\r\n    /**\r\n     * SoundCloud Track ID\r\n     */\r\n    id: number;\r\n    /**\r\n     * SoundCloud Track url\r\n     */\r\n    url: string;\r\n    /**\r\n     * User friendly SoundCloud track URL\r\n     */\r\n    permalink: string;\r\n    /**\r\n     * SoundCloud Track fetched status\r\n     */\r\n    fetched: boolean;\r\n    /**\r\n     * SoundCloud Class type. === \"track\"\r\n     */\r\n    type: 'track' | 'playlist' | 'user';\r\n    /**\r\n     * SoundCloud Track Duration in seconds\r\n     */\r\n    durationInSec: number;\r\n    /**\r\n     * SoundCloud Track Duration in miili seconds\r\n     */\r\n    durationInMs: number;\r\n    /**\r\n     * SoundCloud Track formats data\r\n     */\r\n    formats: SoundCloudTrackFormat[];\r\n    /**\r\n     * SoundCloud Track Publisher Data\r\n     */\r\n    publisher: {\r\n        name: string;\r\n        id: number;\r\n        artist: string;\r\n        contains_music: boolean;\r\n        writer_composer: string;\r\n    } | null;\r\n    /**\r\n     * SoundCloud Track thumbnail\r\n     */\r\n    thumbnail: string;\r\n    /**\r\n     * SoundCloud Track user data\r\n     */\r\n    user: SoundCloudUser;\r\n    /**\r\n     * Constructor for SoundCloud Track Class\r\n     * @param data JSON parsed track html data\r\n     */\r\n    constructor(data: any) {\r\n        this.name = data.title;\r\n        this.id = data.id;\r\n        this.url = data.uri;\r\n        this.permalink = data.permalink_url;\r\n        this.fetched = true;\r\n        this.type = 'track';\r\n        this.durationInSec = Math.round(Number(data.duration) / 1000);\r\n        this.durationInMs = Number(data.duration);\r\n        if (data.publisher_metadata)\r\n            this.publisher = {\r\n                name: data.publisher_metadata.publisher,\r\n                id: data.publisher_metadata.id,\r\n                artist: data.publisher_metadata.artist,\r\n                contains_music: Boolean(data.publisher_metadata.contains_music) || false,\r\n                writer_composer: data.publisher_metadata.writer_composer\r\n            };\r\n        else this.publisher = null;\r\n        this.formats = data.media.transcodings;\r\n        this.user = {\r\n            name: data.user.username,\r\n            id: data.user.id,\r\n            type: 'user',\r\n            url: data.user.permalink_url,\r\n            verified: Boolean(data.user.verified) || false,\r\n            description: data.user.description,\r\n            first_name: data.user.first_name,\r\n            full_name: data.user.full_name,\r\n            last_name: data.user.last_name,\r\n            thumbnail: data.user.avatar_url\r\n        };\r\n        this.thumbnail = data.artwork_url;\r\n    }\r\n    /**\r\n     * Converts class to JSON\r\n     * @returns JSON parsed Data\r\n     */\r\n    toJSON(): SoundTrackJSON {\r\n        return {\r\n            name: this.name,\r\n            id: this.id,\r\n            url: this.url,\r\n            permalink: this.permalink,\r\n            fetched: this.fetched,\r\n            durationInMs: this.durationInMs,\r\n            durationInSec: this.durationInSec,\r\n            publisher: this.publisher,\r\n            formats: this.formats,\r\n            thumbnail: this.thumbnail,\r\n            user: this.user\r\n        };\r\n    }\r\n}\r\n/**\r\n * SoundCloud Playlist Class\r\n */\r\nexport class SoundCloudPlaylist {\r\n    /**\r\n     * SoundCloud Playlist Name\r\n     */\r\n    name: string;\r\n    /**\r\n     * SoundCloud Playlist ID\r\n     */\r\n    id: number;\r\n    /**\r\n     * SoundCloud Playlist URL\r\n     */\r\n    url: string;\r\n    /**\r\n     * SoundCloud Class type. == \"playlist\"\r\n     */\r\n    type: 'track' | 'playlist' | 'user';\r\n    /**\r\n     * SoundCloud Playlist Sub type. == \"album\" for soundcloud albums\r\n     */\r\n    sub_type: string;\r\n    /**\r\n     * SoundCloud Playlist Total Duration in seconds\r\n     */\r\n    durationInSec: number;\r\n    /**\r\n     * SoundCloud Playlist Total Duration in milli seconds\r\n     */\r\n    durationInMs: number;\r\n    /**\r\n     * SoundCloud Playlist user data\r\n     */\r\n    user: SoundCloudUser;\r\n    /**\r\n     * SoundCloud Playlist tracks [ It can be fetched or not fetched ]\r\n     */\r\n    tracks: SoundCloudTrack[] | SoundCloudTrackDeprecated[];\r\n    /**\r\n     * SoundCloud Playlist tracks number\r\n     */\r\n    tracksCount: number;\r\n    /**\r\n     * SoundCloud Client ID provided by user\r\n     * @private\r\n     */\r\n    private client_id: string;\r\n    /**\r\n     * Constructor for SoundCloud Playlist\r\n     * @param data JSON parsed SoundCloud playlist data\r\n     * @param client_id Provided SoundCloud Client ID\r\n     */\r\n    constructor(data: any, client_id: string) {\r\n        this.name = data.title;\r\n        this.id = data.id;\r\n        this.url = data.uri;\r\n        this.client_id = client_id;\r\n        this.type = 'playlist';\r\n        this.sub_type = data.set_type;\r\n        this.durationInSec = Math.round(Number(data.duration) / 1000);\r\n        this.durationInMs = Number(data.duration);\r\n        this.user = {\r\n            name: data.user.username,\r\n            id: data.user.id,\r\n            type: 'user',\r\n            url: data.user.permalink_url,\r\n            verified: Boolean(data.user.verified) || false,\r\n            description: data.user.description,\r\n            first_name: data.user.first_name,\r\n            full_name: data.user.full_name,\r\n            last_name: data.user.last_name,\r\n            thumbnail: data.user.avatar_url\r\n        };\r\n        this.tracksCount = data.track_count;\r\n        const tracks: any[] = [];\r\n        data.tracks.forEach((track: any) => {\r\n            if (track.title) {\r\n                tracks.push(new SoundCloudTrack(track));\r\n            } else\r\n                tracks.push({\r\n                    id: track.id,\r\n                    fetched: false,\r\n                    type: 'track'\r\n                });\r\n        });\r\n        this.tracks = tracks;\r\n    }\r\n    /**\r\n     * Fetches all unfetched songs in a playlist.\r\n     *\r\n     * For fetching songs and getting all songs, see `fetched_tracks` property.\r\n     * @returns playlist class\r\n     */\r\n    async fetch(): Promise<SoundCloudPlaylist> {\r\n        const work: any[] = [];\r\n        for (let i = 0; i < this.tracks.length; i++) {\r\n            if (!this.tracks[i].fetched) {\r\n                work.push(\r\n                    new Promise(async (resolve) => {\r\n                        const num = i;\r\n                        const data = await request(\r\n                            `https://api-v2.soundcloud.com/tracks/${this.tracks[i].id}?client_id=${this.client_id}`\r\n                        );\r\n\r\n                        this.tracks[num] = new SoundCloudTrack(JSON.parse(data));\r\n                        resolve('');\r\n                    })\r\n                );\r\n            }\r\n        }\r\n        await Promise.allSettled(work);\r\n        return this;\r\n    }\r\n    /**\r\n     * Get total no. of fetched tracks\r\n     * @see {@link SoundCloudPlaylist.all_tracks}\r\n     */\r\n    get total_tracks(): number {\r\n        let count = 0;\r\n        this.tracks.forEach((track) => {\r\n            if (track instanceof SoundCloudTrack) count++;\r\n            else return;\r\n        });\r\n        return count;\r\n    }\r\n    /**\r\n     * Fetches all the tracks in the playlist and returns them\r\n     *\r\n     * ```ts\r\n     * const playlist = await play.soundcloud('playlist url')\r\n     *\r\n     * const tracks = await playlist.all_tracks()\r\n     * ```\r\n     * @returns An array of {@link SoundCloudTrack}\r\n     */\r\n    async all_tracks(): Promise<SoundCloudTrack[]> {\r\n        await this.fetch();\r\n\r\n        return this.tracks as SoundCloudTrack[];\r\n    }\r\n    /**\r\n     * Converts Class to JSON data\r\n     * @returns JSON parsed data\r\n     */\r\n    toJSON(): PlaylistJSON {\r\n        return {\r\n            name: this.name,\r\n            id: this.id,\r\n            sub_type: this.sub_type,\r\n            url: this.url,\r\n            durationInMs: this.durationInMs,\r\n            durationInSec: this.durationInSec,\r\n            tracksCount: this.tracksCount,\r\n            user: this.user,\r\n            tracks: this.tracks\r\n        };\r\n    }\r\n}\r\n/**\r\n * SoundCloud Stream class\r\n */\r\nexport class SoundCloudStream {\r\n    /**\r\n     * Readable Stream through which data passes\r\n     */\r\n    stream: Readable;\r\n    /**\r\n     * Type of audio data that we recieved from normal youtube url.\r\n     */\r\n    type: StreamType;\r\n    /**\r\n     * Dash Url containing segment urls.\r\n     * @private\r\n     */\r\n    private url: string;\r\n    /**\r\n     * Total time of downloaded segments data.\r\n     * @private\r\n     */\r\n    private downloaded_time: number;\r\n    /**\r\n     * Timer for looping code every 5 minutes\r\n     * @private\r\n     */\r\n    private timer: Timer;\r\n    /**\r\n     * Total segments Downloaded so far\r\n     * @private\r\n     */\r\n    private downloaded_segments: number;\r\n    /**\r\n     * Incoming message that we recieve.\r\n     *\r\n     * Storing this is essential.\r\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\r\n     * @private\r\n     */\r\n    private request: IncomingMessage | null;\r\n    /**\r\n     * Array of segment time. Useful for calculating downloaded_time.\r\n     */\r\n    private time: number[];\r\n    /**\r\n     * Array of segment_urls in dash file.\r\n     */\r\n    private segment_urls: string[];\r\n    /**\r\n     * Constructor for SoundCloud Stream\r\n     * @param url Dash url containing dash file.\r\n     * @param type Stream Type\r\n     */\r\n    constructor(url: string, type: StreamType = StreamType.Arbitrary) {\r\n        this.stream = new Readable({ highWaterMark: 5 * 1000 * 1000, read() {} });\r\n        this.type = type;\r\n        this.url = url;\r\n        this.downloaded_time = 0;\r\n        this.request = null;\r\n        this.downloaded_segments = 0;\r\n        this.time = [];\r\n        this.timer = new Timer(() => {\r\n            this.timer.reuse();\r\n            this.start();\r\n        }, 280);\r\n        this.segment_urls = [];\r\n        this.stream.on('close', () => {\r\n            this.cleanup();\r\n        });\r\n        this.start();\r\n    }\r\n    /**\r\n     * Parses SoundCloud dash file.\r\n     * @private\r\n     */\r\n    private async parser() {\r\n        const response = await request(this.url).catch((err: Error) => {\r\n            return err;\r\n        });\r\n        if (response instanceof Error) throw response;\r\n        const array = response.split('\\n');\r\n        array.forEach((val) => {\r\n            if (val.startsWith('#EXTINF:')) {\r\n                this.time.push(parseFloat(val.replace('#EXTINF:', '')));\r\n            } else if (val.startsWith('https')) {\r\n                this.segment_urls.push(val);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    /**\r\n     * Starts looping of code for getting all segments urls data\r\n     */\r\n    private async start() {\r\n        if (this.stream.destroyed) {\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        this.time = [];\r\n        this.segment_urls = [];\r\n        this.downloaded_time = 0;\r\n        await this.parser();\r\n        this.segment_urls.splice(0, this.downloaded_segments);\r\n        this.loop();\r\n    }\r\n    /**\r\n     * Main Loop function for getting all segments urls data\r\n     */\r\n    private async loop() {\r\n        if (this.stream.destroyed) {\r\n            this.cleanup();\r\n            return;\r\n        }\r\n        if (this.time.length === 0 || this.segment_urls.length === 0) {\r\n            this.cleanup();\r\n            this.stream.push(null);\r\n            return;\r\n        }\r\n        this.downloaded_time += this.time.shift() as number;\r\n        this.downloaded_segments++;\r\n        const stream = await request_stream(this.segment_urls.shift() as string).catch((err: Error) => err);\r\n        if (stream instanceof Error) {\r\n            this.stream.emit('error', stream);\r\n            this.cleanup();\r\n            return;\r\n        }\r\n\r\n        this.request = stream;\r\n        stream.on('data', (c) => {\r\n            this.stream.push(c);\r\n        });\r\n        stream.on('end', () => {\r\n            if (this.downloaded_time >= 300) return;\r\n            else this.loop();\r\n        });\r\n        stream.once('error', (err) => {\r\n            this.stream.emit('error', err);\r\n        });\r\n    }\r\n    /**\r\n     * This cleans every used variable in class.\r\n     *\r\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\r\n     */\r\n    private cleanup() {\r\n        this.timer.destroy();\r\n        this.request?.destroy();\r\n        this.url = '';\r\n        this.downloaded_time = 0;\r\n        this.downloaded_segments = 0;\r\n        this.request = null;\r\n        this.time = [];\r\n        this.segment_urls = [];\r\n    }\r\n    /**\r\n     * Pauses timer.\r\n     * Stops running of loop.\r\n     *\r\n     * Useful if you don't want to get excess data to be stored in stream.\r\n     */\r\n    pause() {\r\n        this.timer.pause();\r\n    }\r\n    /**\r\n     * Resumes timer.\r\n     * Starts running of loop.\r\n     */\r\n    resume() {\r\n        this.timer.resume();\r\n    }\r\n}\r\n","import { URL } from 'node:url';\r\nimport { request, request_resolve_redirect } from '../Request';\r\nimport { DeezerAlbum, DeezerPlaylist, DeezerTrack } from './classes';\r\n\r\ninterface TypeData {\r\n    type: 'track' | 'playlist' | 'album' | 'search' | false;\r\n    id?: string;\r\n    error?: string;\r\n}\r\n\r\ninterface DeezerSearchOptions {\r\n    /**\r\n     * The type to search for `'track'`, `'playlist'` or `'album'`. Defaults to `'track'`.\r\n     */\r\n    type?: 'track' | 'playlist' | 'album';\r\n    /**\r\n     * The maximum number of results to return, maximum `100`, defaults to `10`.\r\n     */\r\n    limit?: number;\r\n    /**\r\n     * Whether the search should be fuzzy or only return exact matches. Defaults to `true`.\r\n     */\r\n    fuzzy?: boolean;\r\n}\r\n\r\ninterface DeezerAdvancedSearchOptions {\r\n    /**\r\n     * The maximum number of results to return, maximum `100`, defaults to `10`.\r\n     */\r\n    limit?: number;\r\n    /**\r\n     * The name of the artist.\r\n     */\r\n    artist?: string;\r\n    /**\r\n     * The title of the album.\r\n     */\r\n    album?: string;\r\n    /**\r\n     * The title of the track.\r\n     */\r\n    title?: string;\r\n    /**\r\n     * The label that released the track.\r\n     */\r\n    label?: string;\r\n    /**\r\n     * The minimum duration in seconds.\r\n     */\r\n    minDurationInSec?: number;\r\n    /**\r\n     * The maximum duration in seconds.\r\n     */\r\n    maxDurationInSec?: number;\r\n    /**\r\n     * The minimum BPM.\r\n     */\r\n    minBPM?: number;\r\n    /**\r\n     * The minimum BPM.\r\n     */\r\n    maxBPM?: number;\r\n}\r\n\r\nasync function internalValidate(url: string): Promise<TypeData> {\r\n    let urlObj;\r\n    try {\r\n        // will throw a TypeError if the input is not a valid URL so we need to catch it\r\n        urlObj = new URL(url);\r\n    } catch {\r\n        return { type: 'search' };\r\n    }\r\n\r\n    if (urlObj.protocol !== 'https:' && urlObj.protocol !== 'http:') {\r\n        return { type: 'search' };\r\n    }\r\n\r\n    let pathname = urlObj.pathname;\r\n    if (pathname.endsWith('/')) {\r\n        pathname = pathname.slice(0, -1);\r\n    }\r\n    const path = pathname.split('/');\r\n    switch (urlObj.hostname) {\r\n        case 'deezer.com':\r\n        case 'www.deezer.com': {\r\n            if (path.length === 4) {\r\n                const lang = path.splice(1, 1)[0];\r\n                if (!lang.match(/^[a-z]{2}$/)) {\r\n                    return { type: false };\r\n                }\r\n            } else if (path.length !== 3) {\r\n                return { type: false };\r\n            }\r\n\r\n            if ((path[1] === 'track' || path[1] === 'album' || path[1] === 'playlist') && path[2].match(/^\\d+$/)) {\r\n                return {\r\n                    type: path[1],\r\n                    id: path[2]\r\n                };\r\n            } else {\r\n                return { type: false };\r\n            }\r\n        }\r\n        case 'api.deezer.com': {\r\n            if (\r\n                path.length === 3 &&\r\n                (path[1] === 'track' || path[1] === 'album' || path[1] === 'playlist') &&\r\n                path[2].match(/^\\d+$/)\r\n            ) {\r\n                return {\r\n                    type: path[1],\r\n                    id: path[2]\r\n                };\r\n            } else {\r\n                return { type: false };\r\n            }\r\n        }\r\n        case 'deezer.page.link': {\r\n            if (path.length === 2 && path[1].match(/^[A-Za-z0-9]+$/)) {\r\n                const resolved = await request_resolve_redirect(url).catch((err) => err);\r\n\r\n                if (resolved instanceof Error) {\r\n                    return { type: false, error: resolved.message };\r\n                }\r\n\r\n                return await internalValidate(resolved);\r\n            } else {\r\n                return { type: false };\r\n            }\r\n        }\r\n        default:\r\n            return { type: 'search' };\r\n    }\r\n}\r\n\r\n/**\r\n * Shared type for Deezer tracks, playlists and albums\r\n */\r\nexport type Deezer = DeezerTrack | DeezerPlaylist | DeezerAlbum;\r\n\r\n/**\r\n * Fetches the information for a track, playlist or album on Deezer\r\n * @param url The track, playlist or album URL\r\n * @returns A {@link DeezerTrack}, {@link DeezerPlaylist} or {@link DeezerAlbum}\r\n * object depending on the provided URL.\r\n */\r\nexport async function deezer(url: string): Promise<Deezer> {\r\n    const typeData = await internalValidate(url.trim());\r\n\r\n    if (typeData.error) {\r\n        throw new Error(`This is not a Deezer track, playlist or album URL:\\n${typeData.error}`);\r\n    } else if (!typeData.type || typeData.type === 'search')\r\n        throw new Error('This is not a Deezer track, playlist or album URL');\r\n\r\n    const response = await request(`https://api.deezer.com/${typeData.type}/${typeData.id}`).catch((err: Error) => err);\r\n\r\n    if (response instanceof Error) throw response;\r\n\r\n    const jsonData = JSON.parse(response);\r\n\r\n    if (jsonData.error) {\r\n        throw new Error(`Deezer API Error: ${jsonData.error.type}: ${jsonData.error.message}`);\r\n    }\r\n\r\n    switch (typeData.type) {\r\n        case 'track':\r\n            return new DeezerTrack(jsonData, false);\r\n        case 'playlist':\r\n            return new DeezerPlaylist(jsonData, false);\r\n        case 'album':\r\n            return new DeezerAlbum(jsonData, false);\r\n    }\r\n}\r\n\r\n/**\r\n * Validates a Deezer URL\r\n * @param url The URL to validate\r\n * @returns The type of the URL either `'track'`, `'playlist'`, `'album'`, `'search'` or `false`.\r\n * `false` means that the provided URL was a wrongly formatted or an unsupported Deezer URL.\r\n */\r\nexport async function dz_validate(url: string): Promise<'track' | 'playlist' | 'album' | 'search' | false> {\r\n    const typeData = await internalValidate(url.trim());\r\n    return typeData.type;\r\n}\r\n\r\n/**\r\n * Searches Deezer for tracks, playlists or albums\r\n * @param query The search query\r\n * @param options Extra options to configure the search:\r\n *\r\n * * type?: The type to search for `'track'`, `'playlist'` or `'album'`. Defaults to `'track'`.\r\n * * limit?: The maximum number of results to return, maximum `100`, defaults to `10`.\r\n * * fuzzy?: Whether the search should be fuzzy or only return exact matches. Defaults to `true`.\r\n * @returns An array of tracks, playlists or albums\r\n */\r\nexport async function dz_search(query: string, options: DeezerSearchOptions): Promise<Deezer[]> {\r\n    let query_ = query.trim();\r\n\r\n    const type = options.type ?? 'track';\r\n    const limit = options.limit ?? 10;\r\n    const fuzzy = options.fuzzy ?? true;\r\n\r\n    if (query_.length === 0) throw new Error('A query is required to search.');\r\n    if (limit > 100) throw new Error('The maximum search limit for Deezer is 100');\r\n    if (limit < 1) throw new Error('The minimum search limit for Deezer is 1');\r\n    if (type !== 'track' && type !== 'album' && type != 'playlist')\r\n        throw new Error(`\"${type}\" is not a valid Deezer search type`);\r\n\r\n    query_ = encodeURIComponent(query_);\r\n    const response = await request(\r\n        `https://api.deezer.com/search/${type}/?q=${query_}&limit=${limit}${fuzzy ? '' : 'strict=on'}`\r\n    ).catch((err: Error) => err);\r\n\r\n    if (response instanceof Error) throw response;\r\n\r\n    const jsonData = JSON.parse(response);\r\n\r\n    if (jsonData.error) {\r\n        throw new Error(`Deezer API Error: ${jsonData.error.type}: ${jsonData.error.message}`);\r\n    }\r\n\r\n    let results: Deezer[] = [];\r\n    switch (type) {\r\n        case 'track':\r\n            results = jsonData.data.map((track: any) => new DeezerTrack(track, true));\r\n            break;\r\n        case 'playlist':\r\n            results = jsonData.data.map((playlist: any) => new DeezerPlaylist(playlist, true));\r\n            break;\r\n        case 'album':\r\n            results = jsonData.data.map((album: any) => new DeezerAlbum(album, true));\r\n            break;\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\n/**\r\n * Searches Deezer for tracks using the specified metadata.\r\n * @param options The metadata and limit for the search\r\n *\r\n * * limit?: The maximum number of results to return, maximum `100`, defaults to `10`.\r\n * * artist?: The name of the artist\r\n * * album?: The title of the album\r\n * * title?: The title of the track\r\n * * label?: The label that released the track\r\n * * minDurationInSec?: The minimum duration in seconds\r\n * * maxDurationInSec?: The maximum duration in seconds\r\n * * minBpm?: The minimum BPM\r\n * * maxBpm?: The minimum BPM\r\n * @returns An array of tracks matching the metadata\r\n */\r\nexport async function dz_advanced_track_search(options: DeezerAdvancedSearchOptions): Promise<DeezerTrack[]> {\r\n    const limit = options.limit ?? 10;\r\n\r\n    if (limit > 100) throw new Error('The maximum search limit for Deezer is 100');\r\n    if (limit < 1) throw new Error('The minimum search limit for Deezer is 1');\r\n\r\n    const metadata: string[] = [];\r\n    if (options.artist) metadata.push(`artist:\"${encodeURIComponent(options.artist.trim())}\"`);\r\n\r\n    if (options.album) metadata.push(`album:\"${encodeURIComponent(options.album.trim())}\"`);\r\n\r\n    if (options.title) metadata.push(`track:\"${encodeURIComponent(options.title.trim())}\"`);\r\n\r\n    if (options.label) metadata.push(`label:\"${encodeURIComponent(options.label.trim())}\"`);\r\n\r\n    if (!isNaN(Number(options.minDurationInSec))) metadata.push(`dur_min:${options.minDurationInSec}`);\r\n\r\n    if (!isNaN(Number(options.maxDurationInSec))) metadata.push(`dur_max:${options.maxDurationInSec}`);\r\n\r\n    if (!isNaN(Number(options.minBPM))) metadata.push(`bpm_min:${options.minBPM}`);\r\n\r\n    if (!isNaN(Number(options.maxBPM))) metadata.push(`bpm_max:${options.maxBPM}`);\r\n\r\n    if (metadata.length === 0) throw new Error('At least one type of metadata is required.');\r\n\r\n    const response = await request(`https://api.deezer.com/search/track/?q=${metadata.join(' ')}&limit=${limit}`).catch(\r\n        (err: Error) => err\r\n    );\r\n\r\n    if (response instanceof Error) throw response;\r\n\r\n    const jsonData = JSON.parse(response);\r\n\r\n    if (jsonData.error) {\r\n        throw new Error(`Deezer API Error: ${jsonData.error.type}: ${jsonData.error.message}`);\r\n    }\r\n\r\n    const results = jsonData.data.map((track: any) => new DeezerTrack(track, true));\r\n\r\n    return results;\r\n}\r\n\r\nexport { DeezerTrack, DeezerAlbum, DeezerPlaylist };\r\n","import { request } from '../Request';\r\n\r\n/**\r\n * Interface representing an image on Deezer\r\n * available in four sizes\r\n */\r\ninterface DeezerImage {\r\n    /**\r\n     * The largest version of the image\r\n     */\r\n    xl: string;\r\n    /**\r\n     * The second largest version of the image\r\n     */\r\n    big: string;\r\n    /**\r\n     * The second smallest version of the image\r\n     */\r\n    medium: string;\r\n    /**\r\n     * The smallest version of the image\r\n     */\r\n    small: string;\r\n}\r\n\r\n/**\r\n * Interface representing a Deezer genre\r\n */\r\ninterface DeezerGenre {\r\n    /**\r\n     * The name of the genre\r\n     */\r\n    name: string;\r\n    /**\r\n     * The thumbnail of the genre available in four sizes\r\n     */\r\n    picture: DeezerImage;\r\n}\r\n\r\n/**\r\n * Interface representing a Deezer user account\r\n */\r\ninterface DeezerUser {\r\n    /**\r\n     * The id of the user\r\n     */\r\n    id: number;\r\n    /**\r\n     * The name of the user\r\n     */\r\n    name: string;\r\n}\r\n\r\n/**\r\n * Class representing a Deezer track\r\n */\r\nexport class DeezerTrack {\r\n    /**\r\n     * The id of the track\r\n     */\r\n    id: number;\r\n    /**\r\n     * The title of the track\r\n     */\r\n    title: string;\r\n    /**\r\n     * A shorter version of the title\r\n     */\r\n    shortTitle: string;\r\n    /**\r\n     * The URL of the track on Deezer\r\n     */\r\n    url: string;\r\n    /**\r\n     * The duration of the track in seconds\r\n     */\r\n    durationInSec: number;\r\n    /**\r\n     * The rank of the track\r\n     */\r\n    rank: number;\r\n    /**\r\n     * `true` if the track contains any explicit lyrics\r\n     */\r\n    explicit: boolean;\r\n    /**\r\n     * URL to a file containing the first 30 seconds of the track\r\n     */\r\n    previewURL: string;\r\n    /**\r\n     * The artist of the track\r\n     */\r\n    artist: DeezerArtist;\r\n    /**\r\n     * The album that this track is in\r\n     */\r\n    album: DeezerTrackAlbum;\r\n    /**\r\n     * The type, always `'track'`, useful to determine what the deezer function returned\r\n     */\r\n    type: 'track' | 'playlist' | 'album';\r\n\r\n    /**\r\n     * Signifies that some properties are not populated\r\n     *\r\n     * Partial tracks can be populated by calling {@link DeezerTrack.fetch}.\r\n     *\r\n     * `true` for tracks in search results and `false` if the track was fetched directly or expanded.\r\n     */\r\n    partial: boolean;\r\n\r\n    /**\r\n     * The position of the track in the album\r\n     *\r\n     * `undefined` for partial tracks\r\n     *\r\n     * @see {@link DeezerTrack.partial}\r\n     */\r\n    trackPosition?: number;\r\n    /**\r\n     * The number of the disk the track is on\r\n     *\r\n     * `undefined` for partial tracks\r\n     *\r\n     * @see {@link DeezerTrack.partial}\r\n     */\r\n    diskNumber?: number;\r\n    /**\r\n     * The release date\r\n     *\r\n     * `undefined` for partial tracks\r\n     *\r\n     * @see {@link DeezerTrack.partial}\r\n     */\r\n    releaseDate?: Date;\r\n    /**\r\n     * The number of beats per minute\r\n     *\r\n     * `undefined` for partial tracks\r\n     *\r\n     * @see {@link DeezerTrack.partial}\r\n     */\r\n    bpm?: number;\r\n    /**\r\n     * The gain of the track\r\n     *\r\n     * `undefined` for partial tracks\r\n     *\r\n     * @see {@link DeezerTrack.partial}\r\n     */\r\n    gain?: number;\r\n    /**\r\n     * The artists that have contributed to the track\r\n     *\r\n     * `undefined` for partial tracks\r\n     *\r\n     * @see {@link DeezerTrack.partial}\r\n     */\r\n    contributors?: DeezerArtist[];\r\n\r\n    /**\r\n     * Creates a Deezer track from the data in an API response\r\n     * @param data the data to use to create the track\r\n     * @param partial Whether the track should be partial\r\n     * @see {@link DeezerTrack.partial}\r\n     */\r\n    constructor(data: any, partial: boolean) {\r\n        this.id = data.id;\r\n        this.title = data.title;\r\n        this.shortTitle = data.title_short;\r\n        this.url = data.link;\r\n        this.durationInSec = data.duration;\r\n        this.rank = data.rank;\r\n        this.explicit = data.explicit_lyrics;\r\n        this.previewURL = data.preview;\r\n        this.artist = new DeezerArtist(data.artist);\r\n        this.album = new DeezerTrackAlbum(data.album);\r\n        this.type = 'track';\r\n\r\n        this.partial = partial;\r\n\r\n        if (!partial) {\r\n            this.trackPosition = data.track_position;\r\n            this.diskNumber = data.disk_number;\r\n            this.releaseDate = new Date(data.release_date);\r\n            this.bpm = data.bpm;\r\n            this.gain = data.gain;\r\n            this.contributors = [];\r\n\r\n            data.contributors.forEach((contributor: any) => {\r\n                this.contributors?.push(new DeezerArtist(contributor));\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetches and populates the missing fields\r\n     *\r\n     * The property {@link partial} will be `false` if this method finishes successfully.\r\n     *\r\n     * @returns A promise with the same track this method was called on.\r\n     */\r\n    async fetch(): Promise<DeezerTrack> {\r\n        if (!this.partial) return this;\r\n\r\n        const response = await request(`https://api.deezer.com/track/${this.id}/`).catch((err: Error) => err);\r\n\r\n        if (response instanceof Error) throw response;\r\n        const jsonData = JSON.parse(response);\r\n\r\n        this.partial = false;\r\n\r\n        this.trackPosition = jsonData.track_position;\r\n        this.diskNumber = jsonData.disk_number;\r\n        this.releaseDate = new Date(jsonData.release_date);\r\n        this.bpm = jsonData.bpm;\r\n        this.gain = jsonData.gain;\r\n        this.contributors = [];\r\n\r\n        jsonData.contributors.forEach((contributor: any) => {\r\n            this.contributors?.push(new DeezerArtist(contributor));\r\n        });\r\n\r\n        return this;\r\n    }\r\n    /**\r\n     * Converts instances of this class to JSON data\r\n     * @returns JSON data.\r\n     */\r\n    toJSON() {\r\n        return {\r\n            id: this.id,\r\n            title: this.title,\r\n            shortTitle: this.shortTitle,\r\n            url: this.url,\r\n            durationInSec: this.durationInSec,\r\n            rank: this.rank,\r\n            explicit: this.explicit,\r\n            previewURL: this.previewURL,\r\n            artist: this.artist,\r\n            album: this.album,\r\n            type: this.type,\r\n            trackPosition: this.trackPosition,\r\n            diskNumber: this.diskNumber,\r\n            releaseDate: this.releaseDate,\r\n            bpm: this.bpm,\r\n            gain: this.gain,\r\n            contributors: this.contributors\r\n        };\r\n    }\r\n}\r\n/**\r\n * Class for Deezer Albums\r\n */\r\nexport class DeezerAlbum {\r\n    /**\r\n     * The id of the album\r\n     */\r\n    id: number;\r\n    /**\r\n     * The title of the album\r\n     */\r\n    title: string;\r\n    /**\r\n     * The URL to the album on Deezer\r\n     */\r\n    url: string;\r\n    /**\r\n     * The record type of the album (e.g. EP, ALBUM, etc ...)\r\n     */\r\n    recordType: string;\r\n    /**\r\n     * `true` if the album contains any explicit lyrics\r\n     */\r\n    explicit: boolean;\r\n    /**\r\n     * The artist of the album\r\n     */\r\n    artist: DeezerArtist;\r\n    /**\r\n     * The album cover available in four sizes\r\n     */\r\n    cover: DeezerImage;\r\n    /**\r\n     * The type, always `'album'`, useful to determine what the deezer function returned\r\n     */\r\n    type: 'track' | 'playlist' | 'album';\r\n    /**\r\n     * The number of tracks in the album\r\n     */\r\n    tracksCount: number;\r\n\r\n    /**\r\n     * Signifies that some properties are not populated\r\n     *\r\n     * Partial albums can be populated by calling {@link DeezerAlbum.fetch}.\r\n     *\r\n     * `true` for albums in search results and `false` if the album was fetched directly or expanded.\r\n     */\r\n    partial: boolean;\r\n\r\n    /**\r\n     * The **u**niversal **p**roduct **c**ode of the album\r\n     *\r\n     * `undefined` for partial albums\r\n     *\r\n     * @see {@link DeezerAlbum.partial}\r\n     */\r\n    upc?: string;\r\n    /**\r\n     * The duration of the album in seconds\r\n     *\r\n     * `undefined` for partial albums\r\n     *\r\n     * @see {@link DeezerAlbum.partial}\r\n     */\r\n    durationInSec?: number;\r\n    /**\r\n     * The number of fans the album has\r\n     *\r\n     * `undefined` for partial albums\r\n     *\r\n     * @see {@link DeezerAlbum.partial}\r\n     */\r\n    numberOfFans?: number;\r\n    /**\r\n     * The release date of the album\r\n     *\r\n     * `undefined` for partial albums\r\n     *\r\n     * @see {@link DeezerAlbum.partial}\r\n     */\r\n    releaseDate?: Date;\r\n    /**\r\n     * Whether the album is available\r\n     *\r\n     * `undefined` for partial albums\r\n     *\r\n     * @see {@link DeezerAlbum.partial}\r\n     */\r\n    available?: boolean;\r\n    /**\r\n     * The list of genres present in this album\r\n     *\r\n     * `undefined` for partial albums\r\n     *\r\n     * @see {@link DeezerAlbum.partial}\r\n     */\r\n    genres?: DeezerGenre[];\r\n    /**\r\n     * The contributors to the album\r\n     *\r\n     * `undefined` for partial albums\r\n     *\r\n     * @see {@link DeezerAlbum.partial}\r\n     */\r\n    contributors?: DeezerArtist[];\r\n\r\n    /**\r\n     * The list of tracks in the album\r\n     *\r\n     * empty (length === 0) for partial albums\r\n     *\r\n     * Use {@link DeezerAlbum.fetch} to populate the tracks and other properties\r\n     *\r\n     * @see {@link DeezerAlbum.partial}\r\n     */\r\n    tracks: DeezerTrack[];\r\n\r\n    /**\r\n     * Creates a Deezer album from the data in an API response\r\n     * @param data the data to use to create the album\r\n     * @param partial Whether the album should be partial\r\n     * @see {@link DeezerAlbum.partial}\r\n     */\r\n    constructor(data: any, partial: boolean) {\r\n        this.id = data.id;\r\n        this.title = data.title;\r\n        this.url = data.link;\r\n        this.recordType = data.record_type;\r\n        this.explicit = data.explicit_lyrics;\r\n        this.artist = new DeezerArtist(data.artist);\r\n        this.type = 'album';\r\n        this.tracksCount = data.nb_tracks;\r\n        this.contributors = [];\r\n        this.genres = [];\r\n        this.tracks = [];\r\n        this.cover = {\r\n            xl: data.cover_xl,\r\n            big: data.cover_big,\r\n            medium: data.cover_medium,\r\n            small: data.cover_small\r\n        };\r\n\r\n        this.partial = partial;\r\n\r\n        if (!partial) {\r\n            this.upc = data.upc;\r\n            this.durationInSec = data.duration;\r\n            this.numberOfFans = data.fans;\r\n            this.releaseDate = new Date(data.release_date);\r\n            this.available = data.available;\r\n\r\n            data.contributors.forEach((contributor: any) => {\r\n                this.contributors?.push(new DeezerArtist(contributor));\r\n            });\r\n\r\n            data.genres.data.forEach((genre: any) => {\r\n                this.genres?.push({\r\n                    name: genre.name,\r\n                    picture: {\r\n                        xl: `${genre.picture}?size=xl`,\r\n                        big: `${genre.picture}?size=big`,\r\n                        medium: `${genre.picture}?size=medium`,\r\n                        small: `${genre.picture}?size=small`\r\n                    }\r\n                });\r\n            });\r\n\r\n            const trackAlbum: any = {\r\n                id: this.id,\r\n                title: this.title,\r\n                cover_xl: this.cover.xl,\r\n                cover_big: this.cover.big,\r\n                cover_medium: this.cover.medium,\r\n                cover_small: this.cover.small,\r\n                release_date: data.release_date\r\n            };\r\n            data.tracks.data.forEach((track: any) => {\r\n                track.album = trackAlbum;\r\n                this.tracks.push(new DeezerTrack(track, true));\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetches and populates the missing fields including all tracks.\r\n     *\r\n     * The property {@link DeezerAlbum.partial} will be `false` if this method finishes successfully.\r\n     *\r\n     * @returns A promise with the same album this method was called on.\r\n     */\r\n    async fetch(): Promise<DeezerAlbum> {\r\n        if (!this.partial) return this;\r\n\r\n        const response = await request(`https://api.deezer.com/album/${this.id}/`).catch((err: Error) => err);\r\n\r\n        if (response instanceof Error) throw response;\r\n        const jsonData = JSON.parse(response);\r\n\r\n        this.partial = false;\r\n\r\n        this.upc = jsonData.upc;\r\n        this.durationInSec = jsonData.duration;\r\n        this.numberOfFans = jsonData.fans;\r\n        this.releaseDate = new Date(jsonData.release_date);\r\n        this.available = jsonData.available;\r\n        this.contributors = [];\r\n        this.genres = [];\r\n        this.tracks = [];\r\n\r\n        jsonData.contributors.forEach((contributor: any) => {\r\n            this.contributors?.push(new DeezerArtist(contributor));\r\n        });\r\n\r\n        jsonData.genres.data.forEach((genre: any) => {\r\n            this.genres?.push({\r\n                name: genre.name,\r\n                picture: {\r\n                    xl: `${genre.picture}?size=xl`,\r\n                    big: `${genre.picture}?size=big`,\r\n                    medium: `${genre.picture}?size=medium`,\r\n                    small: `${genre.picture}?size=small`\r\n                }\r\n            });\r\n        });\r\n\r\n        const trackAlbum: any = {\r\n            id: this.id,\r\n            title: this.title,\r\n            cover_xl: this.cover.xl,\r\n            cover_big: this.cover.big,\r\n            cover_medium: this.cover.medium,\r\n            cover_small: this.cover.small,\r\n            release_date: jsonData.release_date\r\n        };\r\n        jsonData.tracks.data.forEach((track: any) => {\r\n            track.album = trackAlbum;\r\n            this.tracks.push(new DeezerTrack(track, true));\r\n        });\r\n\r\n        return this;\r\n    }\r\n    /**\r\n     * Fetches all the tracks in the album and returns them\r\n     *\r\n     * ```ts\r\n     * const album = await play.deezer('album url')\r\n     *\r\n     * const tracks = await album.all_tracks()\r\n     * ```\r\n     * @returns An array of {@link DeezerTrack}\r\n     */\r\n    async all_tracks(): Promise<DeezerTrack[]> {\r\n        await this.fetch();\r\n\r\n        return this.tracks as DeezerTrack[];\r\n    }\r\n    /**\r\n     * Converts instances of this class to JSON data\r\n     * @returns JSON data.\r\n     */\r\n    toJSON() {\r\n        return {\r\n            id: this.id,\r\n            title: this.title,\r\n            url: this.url,\r\n            recordType: this.recordType,\r\n            explicit: this.explicit,\r\n            artist: this.artist,\r\n            cover: this.cover,\r\n            type: this.type,\r\n            upc: this.upc,\r\n            tracksCount: this.tracksCount,\r\n            durationInSec: this.durationInSec,\r\n            numberOfFans: this.numberOfFans,\r\n            releaseDate: this.releaseDate,\r\n            available: this.available,\r\n            genres: this.genres,\r\n            contributors: this.contributors,\r\n            tracks: this.tracks.map((track) => track.toJSON())\r\n        };\r\n    }\r\n}\r\n/**\r\n * Class for Deezer Playlists\r\n */\r\nexport class DeezerPlaylist {\r\n    /**\r\n     * The id of the playlist\r\n     */\r\n    id: number;\r\n    /**\r\n     * The title of the playlist\r\n     */\r\n    title: string;\r\n    /**\r\n     * Whether the playlist is public or private\r\n     */\r\n    public: boolean;\r\n    /**\r\n     * The URL of the playlist on Deezer\r\n     */\r\n    url: string;\r\n    /**\r\n     * Cover picture of the playlist available in four sizes\r\n     */\r\n    picture: DeezerImage;\r\n    /**\r\n     * The date of the playlist's creation\r\n     */\r\n    creationDate: Date;\r\n    /**\r\n     * The type, always `'playlist'`, useful to determine what the deezer function returned\r\n     */\r\n    type: 'track' | 'playlist' | 'album';\r\n    /**\r\n     * The Deezer user that created the playlist\r\n     */\r\n    creator: DeezerUser;\r\n    /**\r\n     * The number of tracks in the playlist\r\n     */\r\n    tracksCount: number;\r\n\r\n    /**\r\n     * Signifies that some properties are not populated\r\n     *\r\n     * Partial playlists can be populated by calling {@link DeezerPlaylist.fetch}.\r\n     *\r\n     * `true` for playlists in search results and `false` if the album was fetched directly or expanded.\r\n     */\r\n    partial: boolean;\r\n\r\n    /**\r\n     * Description of the playlist\r\n     *\r\n     * `undefined` for partial playlists\r\n     *\r\n     * @see {@link DeezerPlaylist.partial}\r\n     */\r\n    description?: string;\r\n    /**\r\n     * Duration of the playlist in seconds\r\n     *\r\n     * `undefined` for partial playlists\r\n     *\r\n     * @see {@link DeezerPlaylist.partial}\r\n     */\r\n    durationInSec?: number;\r\n    /**\r\n     * `true` if the playlist is the loved tracks playlist\r\n     *\r\n     * `undefined` for partial playlists\r\n     *\r\n     * @see {@link DeezerPlaylist.partial}\r\n     */\r\n    isLoved?: boolean;\r\n    /**\r\n     * Whether multiple users have worked on the playlist\r\n     *\r\n     * `undefined` for partial playlists\r\n     *\r\n     * @see {@link DeezerPlaylist.partial}\r\n     */\r\n    collaborative?: boolean;\r\n    /**\r\n     * The number of fans the playlist has\r\n     *\r\n     * `undefined` for partial playlists\r\n     *\r\n     * @see {@link DeezerPlaylist.partial}\r\n     */\r\n    fans?: number;\r\n\r\n    /**\r\n     * The list of tracks in the playlist\r\n     *\r\n     * empty (length === 0) for partial and non public playlists\r\n     *\r\n     * Use {@link DeezerPlaylist.fetch} to populate the tracks and other properties\r\n     *\r\n     * @see {@link DeezerPlaylist.partial}\r\n     * @see {@link DeezerPlaylist.public}\r\n     */\r\n    tracks: DeezerTrack[];\r\n\r\n    /**\r\n     * Creates a Deezer playlist from the data in an API response\r\n     * @param data the data to use to create the playlist\r\n     * @param partial Whether the playlist should be partial\r\n     * @see {@link DeezerPlaylist.partial}\r\n     */\r\n    constructor(data: any, partial: boolean) {\r\n        this.id = data.id;\r\n        this.title = data.title;\r\n        this.public = data.public;\r\n        this.url = data.link;\r\n        this.creationDate = new Date(data.creation_date);\r\n        this.type = 'playlist';\r\n        this.tracksCount = data.nb_tracks;\r\n        this.tracks = [];\r\n\r\n        this.picture = {\r\n            xl: data.picture_xl,\r\n            big: data.picture_big,\r\n            medium: data.picture_medium,\r\n            small: data.picture_small\r\n        };\r\n\r\n        if (data.user) {\r\n            this.creator = {\r\n                id: data.user.id,\r\n                name: data.user.name\r\n            };\r\n        } else {\r\n            this.creator = {\r\n                id: data.creator.id,\r\n                name: data.creator.name\r\n            };\r\n        }\r\n\r\n        this.partial = partial;\r\n\r\n        if (!partial) {\r\n            this.description = data.description;\r\n            this.durationInSec = data.duration;\r\n            this.isLoved = data.is_loved_track;\r\n            this.collaborative = data.collaborative;\r\n            this.fans = data.fans;\r\n\r\n            if (this.public) {\r\n                this.tracks = data.tracks.data.map((track: any) => {\r\n                    return new DeezerTrack(track, true);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetches and populates the missing fields, including all tracks.\r\n     *\r\n     * The property {@link DeezerPlaylist.partial} will be `false` if this method finishes successfully.\r\n     *\r\n     * @returns A promise with the same playlist this method was called on.\r\n     */\r\n    async fetch(): Promise<DeezerPlaylist> {\r\n        if (!this.partial && (this.tracks.length === this.tracksCount || !this.public)) {\r\n            return this;\r\n        }\r\n\r\n        if (this.partial) {\r\n            const response = await request(`https://api.deezer.com/playlist/${this.id}/`).catch((err: Error) => err);\r\n\r\n            if (response instanceof Error) throw response;\r\n            const jsonData = JSON.parse(response);\r\n\r\n            this.partial = false;\r\n\r\n            this.description = jsonData.description;\r\n            this.durationInSec = jsonData.duration;\r\n            this.isLoved = jsonData.is_loved_track;\r\n            this.collaborative = jsonData.collaborative;\r\n            this.fans = jsonData.fans;\r\n\r\n            if (this.public) {\r\n                this.tracks = jsonData.tracks.data.map((track: any) => {\r\n                    return new DeezerTrack(track, true);\r\n                });\r\n            }\r\n        }\r\n\r\n        const currentTracksCount = this.tracks.length;\r\n        if (this.public && currentTracksCount !== this.tracksCount) {\r\n            let missing = this.tracksCount - currentTracksCount;\r\n\r\n            if (missing > 1000) missing = 1000;\r\n\r\n            const promises: Promise<DeezerTrack[]>[] = [];\r\n            for (let i = 1; i <= Math.ceil(missing / 100); i++) {\r\n                promises.push(\r\n                    new Promise(async (resolve, reject) => {\r\n                        const response = await request(\r\n                            `https://api.deezer.com/playlist/${this.id}/tracks?limit=100&index=${i * 100}`\r\n                        ).catch((err) => reject(err));\r\n\r\n                        if (typeof response !== 'string') return;\r\n                        const jsonData = JSON.parse(response);\r\n                        const tracks = jsonData.data.map((track: any) => {\r\n                            return new DeezerTrack(track, true);\r\n                        });\r\n\r\n                        resolve(tracks);\r\n                    })\r\n                );\r\n            }\r\n\r\n            const results = await Promise.allSettled(promises);\r\n            const newTracks: DeezerTrack[] = [];\r\n\r\n            for (const result of results) {\r\n                if (result.status === 'fulfilled') {\r\n                    newTracks.push(...result.value);\r\n                } else {\r\n                    throw result.reason;\r\n                }\r\n            }\r\n\r\n            this.tracks.push(...newTracks);\r\n        }\r\n\r\n        return this;\r\n    }\r\n    /**\r\n     * Fetches all the tracks in the playlist and returns them\r\n     *\r\n     * ```ts\r\n     * const playlist = await play.deezer('playlist url')\r\n     *\r\n     * const tracks = await playlist.all_tracks()\r\n     * ```\r\n     * @returns An array of {@link DeezerTrack}\r\n     */\r\n    async all_tracks(): Promise<DeezerTrack[]> {\r\n        await this.fetch();\r\n\r\n        return this.tracks as DeezerTrack[];\r\n    }\r\n    /**\r\n     * Converts instances of this class to JSON data\r\n     * @returns JSON data.\r\n     */\r\n    toJSON() {\r\n        return {\r\n            id: this.id,\r\n            title: this.title,\r\n            public: this.public,\r\n            url: this.url,\r\n            picture: this.picture,\r\n            creationDate: this.creationDate,\r\n            type: this.type,\r\n            creator: this.creator,\r\n            tracksCount: this.tracksCount,\r\n            description: this.description,\r\n            durationInSec: this.durationInSec,\r\n            isLoved: this.isLoved,\r\n            collaborative: this.collaborative,\r\n            fans: this.fans,\r\n            tracks: this.tracks.map((track) => track.toJSON())\r\n        };\r\n    }\r\n}\r\n\r\nclass DeezerTrackAlbum {\r\n    id: number;\r\n    title: string;\r\n    url: string;\r\n    cover: DeezerImage;\r\n    releaseDate?: Date;\r\n\r\n    constructor(data: any) {\r\n        this.id = data.id;\r\n        this.title = data.title;\r\n        this.url = `https://www.deezer.com/album/${data.id}/`;\r\n        this.cover = {\r\n            xl: data.cover_xl,\r\n            big: data.cover_big,\r\n            medium: data.cover_medium,\r\n            small: data.cover_small\r\n        };\r\n\r\n        if (data.release_date) this.releaseDate = new Date(data.release_date);\r\n    }\r\n}\r\n/**\r\n * Class representing a Deezer artist\r\n */\r\nclass DeezerArtist {\r\n    /**\r\n     * The id of the artist\r\n     */\r\n    id: number;\r\n    /**\r\n     * The name of the artist\r\n     */\r\n    name: string;\r\n    /**\r\n     * The URL of the artist on Deezer\r\n     */\r\n    url: string;\r\n\r\n    /**\r\n     * The picture of the artist available in four sizes\r\n     */\r\n    picture?: DeezerImage;\r\n    /**\r\n     * The of the artist on the track\r\n     */\r\n    role?: string;\r\n\r\n    constructor(data: any) {\r\n        this.id = data.id;\r\n        this.name = data.name;\r\n\r\n        this.url = data.link ? data.link : `https://www.deezer.com/artist/${data.id}/`;\r\n\r\n        if (data.picture_xl)\r\n            this.picture = {\r\n                xl: data.picture_xl,\r\n                big: data.picture_big,\r\n                medium: data.picture_medium,\r\n                small: data.picture_small\r\n            };\r\n\r\n        if (data.role) this.role = data.role;\r\n    }\r\n}\r\n","import { setUserAgent } from './Request/useragent';\r\nimport { setSoundCloudToken } from './SoundCloud';\r\nimport { setSpotifyToken } from './Spotify';\r\nimport { setCookieToken } from './YouTube/utils/cookie';\r\n\r\ninterface tokenOptions {\r\n    spotify?: {\r\n        client_id: string;\r\n        client_secret: string;\r\n        refresh_token: string;\r\n        market: string;\r\n    };\r\n    soundcloud?: {\r\n        client_id: string;\r\n    };\r\n    youtube?: {\r\n        cookie: string;\r\n    };\r\n    useragent?: string[];\r\n}\r\n/**\r\n * Sets\r\n *\r\n *  i> YouTube :- cookies.\r\n *\r\n *  ii> SoundCloud :- client ID.\r\n *\r\n *  iii> Spotify :- client ID, client secret, refresh token, market.\r\n *\r\n *  iv> Useragents :- array of string.\r\n *\r\n * locally in memory.\r\n *\r\n * Example :\r\n * ```ts\r\n * play.setToken({\r\n *      youtube : {\r\n *          cookie : \"Your Cookies\"\r\n *      }\r\n * }) // YouTube Cookies\r\n *\r\n * await play.setToken({\r\n *      spotify : {\r\n *          client_id: 'ID',\r\n            client_secret: 'secret',\r\n            refresh_token: 'token',\r\n            market: 'US'\r\n *      }\r\n * }) // Await this only when setting data for spotify\r\n * \r\n * play.setToken({\r\n *      useragent: ['Your User-agent']\r\n * }) // Use this to avoid 429 errors.\r\n * ```\r\n * @param options {@link tokenOptions}\r\n */\r\nexport async function setToken(options: tokenOptions) {\r\n    if (options.spotify) await setSpotifyToken(options.spotify);\r\n    if (options.soundcloud) setSoundCloudToken(options.soundcloud);\r\n    if (options.youtube) setCookieToken(options.youtube);\r\n    if (options.useragent) setUserAgent(options.useragent);\r\n}\r\n","import {\r\n    playlist_info,\r\n    video_basic_info,\r\n    video_info,\r\n    decipher_info,\r\n    yt_validate,\r\n    extractID,\r\n    YouTube,\r\n    YouTubeStream,\r\n    YouTubeChannel,\r\n    YouTubePlayList,\r\n    YouTubeVideo,\r\n    InfoData\r\n} from './YouTube';\r\nimport {\r\n    spotify,\r\n    sp_validate,\r\n    refreshToken,\r\n    is_expired,\r\n    SpotifyAlbum,\r\n    SpotifyPlaylist,\r\n    SpotifyTrack,\r\n    Spotify,\r\n    SpotifyAuthorize,\r\n    sp_search\r\n} from './Spotify';\r\nimport {\r\n    soundcloud,\r\n    so_validate,\r\n    SoundCloud,\r\n    SoundCloudStream,\r\n    getFreeClientID,\r\n    SoundCloudPlaylist,\r\n    SoundCloudTrack,\r\n    check_id,\r\n    so_search,\r\n    stream as so_stream,\r\n    stream_from_info as so_stream_info\r\n} from './SoundCloud';\r\nimport {\r\n    deezer,\r\n    dz_validate,\r\n    dz_advanced_track_search,\r\n    Deezer,\r\n    DeezerTrack,\r\n    DeezerPlaylist,\r\n    DeezerAlbum,\r\n    dz_search\r\n} from './Deezer';\r\nimport { setToken } from './token';\r\n\r\nenum AudioPlayerStatus {\r\n    Idle = 'idle',\r\n    Buffering = 'buffering',\r\n    Paused = 'paused',\r\n    Playing = 'playing',\r\n    AutoPaused = 'autopaused'\r\n}\r\n\r\ninterface SearchOptions {\r\n    limit?: number;\r\n    source?: {\r\n        youtube?: 'video' | 'playlist' | 'channel';\r\n        spotify?: 'album' | 'playlist' | 'track';\r\n        soundcloud?: 'tracks' | 'playlists' | 'albums';\r\n        deezer?: 'track' | 'playlist' | 'album';\r\n    };\r\n    fuzzy?: boolean;\r\n    language?: string;\r\n    /**\r\n     * !!! Before enabling this for public servers, please consider using Discord features like NSFW channels as not everyone in your server wants to see NSFW images. !!!\r\n     * Unblurred images will likely have different dimensions than specified in the {@link YouTubeThumbnail} objects.\r\n     */\r\n    unblurNSFWThumbnails?: boolean;\r\n}\r\n\r\nimport { createInterface } from 'node:readline';\r\nimport { existsSync, mkdirSync, writeFileSync } from 'node:fs';\r\nimport { stream as yt_stream, StreamOptions, stream_from_info as yt_stream_info } from './YouTube/stream';\r\nimport { yt_search } from './YouTube/search';\r\nimport { EventEmitter } from 'stream';\r\n\r\nasync function stream(url: string, options: { seek?: number } & StreamOptions): Promise<YouTubeStream>;\r\nasync function stream(url: string, options?: StreamOptions): Promise<YouTubeStream | SoundCloudStream>;\r\n/**\r\n * Creates a Stream [ YouTube or SoundCloud ] class from a url for playing.\r\n *\r\n * Example\r\n * ```ts\r\n * const source = await play.stream('youtube video URL') // YouTube Video Stream\r\n *\r\n * const source = await play.stream('soundcloud track URL') // SoundCloud Track Stream\r\n *\r\n * const source = await play.stream('youtube video URL', { seek : 45 }) // Seeks 45 seconds (approx.) in YouTube Video Stream\r\n *\r\n * const resource = createAudioResource(source.stream, {\r\n *      inputType : source.type\r\n * }) // Use discordjs voice createAudioResource function.\r\n * ```\r\n * @param url Video / Track URL\r\n * @param options\r\n *\r\n *  - `number` seek : No of seconds to seek in stream.\r\n *  - `string` language : Sets language of searched content [ YouTube search only. ], e.g. \"en-US\"\r\n *  - `number` quality : Quality number. [ 0 = Lowest, 1 = Medium, 2 = Highest ]\r\n *  - `boolean` htmldata : given data is html data or not\r\n *  - `number` precache : No of segments of data to store before looping [YouTube Live Stream only]. [ Defaults to 3 ]\r\n *  - `boolean` discordPlayerCompatibility : Conversion of Webm to Opus [ Defaults to false ]\r\n * @returns A {@link YouTubeStream} or {@link SoundCloudStream} Stream to play\r\n */\r\nasync function stream(url: string, options: StreamOptions = {}): Promise<YouTubeStream | SoundCloudStream> {\r\n    const url_ = url.trim();\r\n    if (url_.length === 0) throw new Error('Stream URL has a length of 0. Check your url again.');\r\n    if (options.htmldata) return await yt_stream(url_, options);\r\n    if (url_.indexOf('spotify') !== -1) {\r\n        throw new Error(\r\n            'Streaming from Spotify is not supported. Please use search() to find a similar track on YouTube or SoundCloud instead.'\r\n        );\r\n    }\r\n    if (url_.indexOf('deezer') !== -1) {\r\n        throw new Error(\r\n            'Streaming from Deezer is not supported. Please use search() to find a similar track on YouTube or SoundCloud instead.'\r\n        );\r\n    }\r\n    if (url_.indexOf('soundcloud') !== -1) return await so_stream(url_, options.quality);\r\n    else return await yt_stream(url_, options);\r\n}\r\n\r\nasync function search(query: string, options: { source: { deezer: 'album' } } & SearchOptions): Promise<DeezerAlbum[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { deezer: 'playlist' } } & SearchOptions\r\n): Promise<DeezerPlaylist[]>;\r\nasync function search(query: string, options: { source: { deezer: 'track' } } & SearchOptions): Promise<DeezerTrack[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { soundcloud: 'albums' } } & SearchOptions\r\n): Promise<SoundCloudPlaylist[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { soundcloud: 'playlists' } } & SearchOptions\r\n): Promise<SoundCloudPlaylist[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { soundcloud: 'tracks' } } & SearchOptions\r\n): Promise<SoundCloudTrack[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { spotify: 'album' } } & SearchOptions\r\n): Promise<SpotifyAlbum[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { spotify: 'playlist' } } & SearchOptions\r\n): Promise<SpotifyPlaylist[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { spotify: 'track' } } & SearchOptions\r\n): Promise<SpotifyTrack[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { youtube: 'channel' } } & SearchOptions\r\n): Promise<YouTubeChannel[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { youtube: 'playlist' } } & SearchOptions\r\n): Promise<YouTubePlayList[]>;\r\nasync function search(\r\n    query: string,\r\n    options: { source: { youtube: 'video' } } & SearchOptions\r\n): Promise<YouTubeVideo[]>;\r\nasync function search(query: string, options: { limit: number } & SearchOptions): Promise<YouTubeVideo[]>;\r\nasync function search(query: string, options?: SearchOptions): Promise<YouTubeVideo[]>;\r\n/**\r\n * Searches through a particular source and gives respective info.\r\n * \r\n * Example\r\n * ```ts\r\n * const searched = await play.search('Rick Roll', { source : { youtube : \"video\" } }) // YouTube Video Search\r\n * \r\n * const searched = await play.search('Rick Roll', { limit : 1 }) // YouTube Video Search but returns only 1 video.\r\n * \r\n * const searched = await play.search('Rick Roll', { source : { spotify : \"track\" } }) // Spotify Track Search\r\n * \r\n * const searched = await play.search('Rick Roll', { source : { soundcloud : \"tracks\" } }) // SoundCloud Track Search\r\n * \r\n * const searched = await play.search('Rick Roll', { source : { deezer : \"track\" } }) // Deezer Track Search\r\n * ```\r\n * @param query string to search.\r\n * @param options\r\n * \r\n *  - `number` limit : No of searches you want to have.\r\n *  - `string` language : Sets language of searched content [ YouTube search only. ], e.g. \"en-US\"\r\n *  - `boolean` unblurNSFWThumbnails : Unblurs NSFW thumbnails. Defaults to `false` [ YouTube search only. ]\r\n *              !!! Before enabling this for public servers, please consider using Discord features like NSFW channels as not everyone in your server wants to see NSFW images. !!!\r\n *              Unblurred images will likely have different dimensions than specified in the {@link YouTubeThumbnail} objects.\r\n *  - `boolean` fuzzy : Whether the search should be fuzzy or only return exact matches. Defaults to `true`. [ for `Deezer` Only ]\r\n *  - `Object` source : Contains type of source and type of result you want to have\r\n * ```ts\r\n *      - youtube : 'video' | 'playlist' | 'channel';\r\n        - spotify : 'album' | 'playlist' | 'track';\r\n        - soundcloud : 'tracks' | 'playlists' | 'albums';\r\n        - deezer : 'track' | 'playlist' | 'album';\r\n    ```\r\n * @returns Array of {@link YouTube} or {@link Spotify} or {@link SoundCloud} or {@link Deezer} type\r\n */\r\nasync function search(\r\n    query: string,\r\n    options: SearchOptions = {}\r\n): Promise<YouTube[] | Spotify[] | SoundCloud[] | Deezer[]> {\r\n    if (!options.source) options.source = { youtube: 'video' };\r\n    const query_ = encodeURIComponent(query.trim());\r\n    if (options.source.youtube)\r\n        return await yt_search(query_, {\r\n            limit: options.limit,\r\n            type: options.source.youtube,\r\n            language: options.language,\r\n            unblurNSFWThumbnails: options.unblurNSFWThumbnails\r\n        });\r\n    else if (options.source.spotify) return await sp_search(query_, options.source.spotify, options.limit);\r\n    else if (options.source.soundcloud) return await so_search(query_, options.source.soundcloud, options.limit);\r\n    else if (options.source.deezer)\r\n        return await dz_search(query_, { limit: options.limit, type: options.source.deezer, fuzzy: options.fuzzy });\r\n    else throw new Error('Not possible to reach Here LOL. Easter Egg of play-dl if someone get this.');\r\n}\r\n\r\nasync function stream_from_info(info: SoundCloudTrack, options?: StreamOptions): Promise<SoundCloudStream>;\r\nasync function stream_from_info(info: InfoData, options?: StreamOptions): Promise<YouTubeStream>;\r\n/**\r\n * Creates a Stream [ YouTube or SoundCloud ] class from video or track info for playing.\r\n *\r\n * Example\r\n * ```ts\r\n * const info = await video_info('youtube URL')\r\n * const source = await play.stream_from_info(info) // YouTube Video Stream\r\n *\r\n * const soundInfo = await play.soundcloud('SoundCloud URL')\r\n * const source = await play.stream_from_info(soundInfo) // SoundCloud Track Stream\r\n *\r\n * const source = await play.stream_from_info(info, { seek : 45 }) // Seeks 45 seconds (approx.) in YouTube Video Stream\r\n *\r\n * const resource = createAudioResource(source.stream, {\r\n *      inputType : source.type\r\n * }) // Use discordjs voice createAudioResource function.\r\n * ```\r\n * @param info YouTube video info OR SoundCloud track Class\r\n * @param options\r\n *\r\n *  - `number` seek : No of seconds to seek in stream.\r\n *  - `string` language : Sets language of searched content [ YouTube search only. ], e.g. \"en-US\"\r\n *  - `number` quality : Quality number. [ 0 = Lowest, 1 = Medium, 2 = Highest ]\r\n *  - `boolean` htmldata : given data is html data or not\r\n *  - `number` precache : No of segments of data to store before looping [YouTube Live Stream only]. [ Defaults to 3 ]\r\n *  - `boolean` discordPlayerCompatibility : Conversion of Webm to Opus[ Defaults to false ]\r\n * @returns A {@link YouTubeStream} or {@link SoundCloudStream} Stream to play\r\n */\r\nasync function stream_from_info(\r\n    info: InfoData | SoundCloudTrack,\r\n    options: StreamOptions = {}\r\n): Promise<YouTubeStream | SoundCloudStream> {\r\n    if (info instanceof SoundCloudTrack) return await so_stream_info(info, options.quality);\r\n    else return await yt_stream_info(info, options);\r\n}\r\n/**\r\n * Validates url that play-dl supports.\r\n *\r\n * - `so` - SoundCloud\r\n * - `sp` - Spotify\r\n * - `dz` - Deezer\r\n * - `yt` - YouTube\r\n * @param url URL\r\n * @returns\r\n * ```ts\r\n * 'so_playlist' / 'so_track' | 'sp_track' | 'sp_album' | 'sp_playlist' | 'dz_track' | 'dz_playlist' | 'dz_album' | 'yt_video' | 'yt_playlist' | 'search' | false\r\n * ```\r\n */\r\nasync function validate(\r\n    url: string\r\n): Promise<\r\n    | 'so_playlist'\r\n    | 'so_track'\r\n    | 'sp_track'\r\n    | 'sp_album'\r\n    | 'sp_playlist'\r\n    | 'dz_track'\r\n    | 'dz_playlist'\r\n    | 'dz_album'\r\n    | 'yt_video'\r\n    | 'yt_playlist'\r\n    | 'search'\r\n    | false\r\n> {\r\n    let check;\r\n    const url_ = url.trim();\r\n    if (!url_.startsWith('https')) return 'search';\r\n    if (url_.indexOf('spotify') !== -1) {\r\n        check = sp_validate(url_);\r\n        return check !== false ? (('sp_' + check) as 'sp_track' | 'sp_album' | 'sp_playlist') : false;\r\n    } else if (url_.indexOf('soundcloud') !== -1) {\r\n        check = await so_validate(url_);\r\n        return check !== false ? (('so_' + check) as 'so_playlist' | 'so_track') : false;\r\n    } else if (url_.indexOf('deezer') !== -1) {\r\n        check = await dz_validate(url_);\r\n        return check !== false ? (('dz_' + check) as 'dz_track' | 'dz_playlist' | 'dz_album') : false;\r\n    } else {\r\n        check = yt_validate(url_);\r\n        return check !== false ? (('yt_' + check) as 'yt_video' | 'yt_playlist') : false;\r\n    }\r\n}\r\n/**\r\n * Authorization interface for Spotify, SoundCloud and YouTube.\r\n *\r\n * Either stores info in `.data` folder or shows relevant data to be used in `setToken` function.\r\n *\r\n * ```ts\r\n * const play = require('play-dl')\r\n *\r\n * play.authorization()\r\n * ```\r\n *\r\n * Just run the above command and you will get a interface asking some questions.\r\n */\r\nfunction authorization(): void {\r\n    const ask = createInterface({\r\n        input: process.stdin,\r\n        output: process.stdout\r\n    });\r\n    ask.question('Do you want to save data in a file ? (Yes / No): ', (msg) => {\r\n        let file: boolean;\r\n        if (msg.toLowerCase() === 'yes') file = true;\r\n        else if (msg.toLowerCase() === 'no') file = false;\r\n        else {\r\n            console.log(\"That option doesn't exist. Try again...\");\r\n            ask.close();\r\n            return;\r\n        }\r\n        ask.question('Choose your service - sc (for SoundCloud) / sp (for Spotify)  / yo (for YouTube): ', (msg) => {\r\n            if (msg.toLowerCase().startsWith('sp')) {\r\n                let client_id: string, client_secret: string, redirect_url: string, market: string;\r\n                ask.question('Start by entering your Client ID : ', (id) => {\r\n                    client_id = id;\r\n                    ask.question('Now enter your Client Secret : ', (secret) => {\r\n                        client_secret = secret;\r\n                        ask.question('Enter your Redirect URL now : ', (url) => {\r\n                            redirect_url = url;\r\n                            console.log(\r\n                                '\\nIf you would like to know your region code visit : \\nhttps://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements \\n'\r\n                            );\r\n                            ask.question('Enter your region code (2-letter country code) : ', (mar) => {\r\n                                if (mar.length === 2) market = mar;\r\n                                else {\r\n                                    console.log(\r\n                                        \"That doesn't look like a valid region code, IN will be selected as default.\"\r\n                                    );\r\n                                    market = 'IN';\r\n                                }\r\n                                console.log(\r\n                                    '\\nNow open your browser and paste the below url, then authorize it and copy the redirected url. \\n'\r\n                                );\r\n                                console.log(\r\n                                    `https://accounts.spotify.com/authorize?client_id=${client_id}&response_type=code&redirect_uri=${encodeURI(\r\n                                        redirect_url\r\n                                    )} \\n`\r\n                                );\r\n                                ask.question('Paste the url which you just copied : ', async (url) => {\r\n                                    if (!existsSync('.data')) mkdirSync('.data');\r\n                                    const spotifyData = {\r\n                                        client_id,\r\n                                        client_secret,\r\n                                        redirect_url,\r\n                                        authorization_code: url.split('code=')[1],\r\n                                        market\r\n                                    };\r\n                                    const check = await SpotifyAuthorize(spotifyData, file);\r\n                                    if (check === false) throw new Error('Failed to get access token.');\r\n                                    ask.close();\r\n                                });\r\n                            });\r\n                        });\r\n                    });\r\n                });\r\n            } else if (msg.toLowerCase().startsWith('sc')) {\r\n                if (!file) {\r\n                    console.log('You already had a client ID, just paste that in setToken function.');\r\n                    ask.close();\r\n                    return;\r\n                }\r\n                ask.question('Client ID : ', async (id) => {\r\n                    let client_id = id;\r\n                    if (!client_id) {\r\n                        console.log(\"You didn't provide a client ID. Try again...\");\r\n                        ask.close();\r\n                        return;\r\n                    }\r\n                    if (!existsSync('.data')) mkdirSync('.data');\r\n                    console.log('Validating your client ID, hold on...');\r\n                    if (await check_id(client_id)) {\r\n                        console.log('Client ID has been validated successfully.');\r\n                        writeFileSync('.data/soundcloud.data', JSON.stringify({ client_id }, undefined, 4));\r\n                    } else console.log(\"That doesn't look like a valid client ID. Retry with a correct client ID.\");\r\n                    ask.close();\r\n                });\r\n            } else if (msg.toLowerCase().startsWith('yo')) {\r\n                if (!file) {\r\n                    console.log('You already had cookie, just paste that in setToken function.');\r\n                    ask.close();\r\n                    return;\r\n                }\r\n                ask.question('Cookies : ', (cook: string) => {\r\n                    if (!cook || cook.length === 0) {\r\n                        console.log(\"You didn't provide a cookie. Try again...\");\r\n                        ask.close();\r\n                        return;\r\n                    }\r\n                    if (!existsSync('.data')) mkdirSync('.data');\r\n                    console.log('Cookies has been added successfully.');\r\n                    let cookie: Object = {};\r\n                    cook.split(';').forEach((x) => {\r\n                        const arr = x.split('=');\r\n                        if (arr.length <= 1) return;\r\n                        const key = arr.shift()?.trim() as string;\r\n                        const value = arr.join('=').trim();\r\n                        Object.assign(cookie, { [key]: value });\r\n                    });\r\n                    writeFileSync('.data/youtube.data', JSON.stringify({ cookie }, undefined, 4));\r\n                    ask.close();\r\n                });\r\n            } else {\r\n                console.log(\"That option doesn't exist. Try again...\");\r\n                ask.close();\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Attaches paused, playing, autoPaused Listeners to discordjs voice AudioPlayer.\r\n *\r\n * Useful if you don't want extra data to be downloaded by play-dl.\r\n * @param player discordjs voice AudioPlayer\r\n * @param resource A {@link YouTubeStream} or {@link SoundCloudStream}\r\n */\r\nfunction attachListeners(player: EventEmitter, resource: YouTubeStream | SoundCloudStream) {\r\n    // cleanup existing listeners if they are still registered\r\n    type listenerType = (...args: any[]) => void;\r\n\r\n    const listeners = player.listeners(AudioPlayerStatus.Idle);\r\n    for (const cleanup of listeners) {\r\n        if ((cleanup as any).__playDlAttachedListener) {\r\n            cleanup();\r\n            player.removeListener(AudioPlayerStatus.Idle, cleanup as listenerType);\r\n        }\r\n    }\r\n\r\n    const pauseListener = () => resource.pause();\r\n    const resumeListener = () => resource.resume();\r\n    const idleListener = () => {\r\n        player.removeListener(AudioPlayerStatus.Paused, pauseListener);\r\n        player.removeListener(AudioPlayerStatus.AutoPaused, pauseListener);\r\n        player.removeListener(AudioPlayerStatus.Playing, resumeListener);\r\n    };\r\n    pauseListener.__playDlAttachedListener = true;\r\n    resumeListener.__playDlAttachedListener = true;\r\n    idleListener.__playDlAttachedListener = true;\r\n    player.on(AudioPlayerStatus.Paused, pauseListener);\r\n    player.on(AudioPlayerStatus.AutoPaused, pauseListener);\r\n    player.on(AudioPlayerStatus.Playing, resumeListener);\r\n    player.once(AudioPlayerStatus.Idle, idleListener);\r\n}\r\n\r\n// Export Main Commands\r\nexport {\r\n    DeezerAlbum,\r\n    DeezerPlaylist,\r\n    DeezerTrack,\r\n    SoundCloudPlaylist,\r\n    SoundCloudStream,\r\n    SoundCloudTrack,\r\n    SpotifyAlbum,\r\n    SpotifyPlaylist,\r\n    SpotifyTrack,\r\n    YouTubeChannel,\r\n    YouTubePlayList,\r\n    YouTubeVideo,\r\n    attachListeners,\r\n    authorization,\r\n    decipher_info,\r\n    deezer,\r\n    dz_advanced_track_search,\r\n    dz_validate,\r\n    extractID,\r\n    getFreeClientID,\r\n    is_expired,\r\n    playlist_info,\r\n    refreshToken,\r\n    search,\r\n    setToken,\r\n    so_validate,\r\n    soundcloud,\r\n    spotify,\r\n    sp_validate,\r\n    stream,\r\n    stream_from_info,\r\n    validate,\r\n    video_basic_info,\r\n    video_info,\r\n    yt_validate,\r\n    InfoData\r\n};\r\n\r\n// Export Types\r\nexport { Deezer, YouTube, SoundCloud, Spotify, YouTubeStream };\r\n\r\n// Export Default\r\nexport default {\r\n    DeezerAlbum,\r\n    DeezerPlaylist,\r\n    DeezerTrack,\r\n    SoundCloudPlaylist,\r\n    SoundCloudStream,\r\n    SoundCloudTrack,\r\n    SpotifyAlbum,\r\n    SpotifyPlaylist,\r\n    SpotifyTrack,\r\n    YouTubeChannel,\r\n    YouTubePlayList,\r\n    YouTubeVideo,\r\n    attachListeners,\r\n    authorization,\r\n    decipher_info,\r\n    deezer,\r\n    dz_advanced_track_search,\r\n    dz_validate,\r\n    extractID,\r\n    getFreeClientID,\r\n    is_expired,\r\n    playlist_info,\r\n    refreshToken,\r\n    search,\r\n    setToken,\r\n    so_validate,\r\n    soundcloud,\r\n    spotify,\r\n    sp_validate,\r\n    stream,\r\n    stream_from_info,\r\n    validate,\r\n    video_basic_info,\r\n    video_info,\r\n    yt_validate\r\n};\r\n"],"mappings":"iFACA,sCACA,gCACA,2FCHA,6EAEA,GAAI,GACJ,AAAI,GAAW,oBAAoB,GAC/B,GAAc,KAAK,MAAM,GAAa,qBAAsB,OAAO,CAAC,EACpE,EAAY,KAAO,IAQhB,aAA0C,CAC7C,GAAI,GAAS,GACb,GAAI,EAAC,GAAa,OAClB,QAAW,CAAC,EAAK,IAAU,QAAO,QAAQ,EAAY,MAAM,EACxD,GAAU,GAAG,KAAO,KAExB,MAAO,GACX,CAPgB,mBAST,YAAmB,EAAa,EAAwB,CAC3D,MAAK,IAAa,OAClB,GAAM,EAAI,KAAK,EACf,EAAQ,EAAM,KAAK,EACnB,OAAO,OAAO,EAAY,OAAQ,EAAG,GAAM,CAAM,CAAC,EAC3C,IAJ0B,EAKrC,CANgB,kBAQT,aAAwB,CAC3B,AAAI,EAAY,QAAU,EAAY,MAClC,GAAc,qBAAsB,KAAK,UAAU,EAAa,OAAW,CAAC,CAAC,CACrF,CAHgB,qBAKT,YAAwB,EAA6B,CACxD,GAAI,GAAO,EAAQ,OACf,EAAiB,CAAC,EACtB,EAAK,MAAM,GAAG,EAAE,QAAQ,AAAC,GAAM,CAC3B,GAAM,GAAM,EAAE,MAAM,GAAG,EACvB,GAAI,EAAI,QAAU,EAAG,OACrB,GAAM,GAAM,EAAI,MAAM,GAAG,KAAK,EACxB,EAAQ,EAAI,KAAK,GAAG,EAAE,KAAK,EACjC,OAAO,OAAO,EAAQ,EAAG,GAAM,CAAM,CAAC,CAC1C,CAAC,EACD,EAAc,CAAE,QAAO,EACvB,EAAY,KAAO,EACvB,CAZgB,uBA0BT,YAAuB,EAA4B,CACtD,AAAI,CAAC,GAAa,QAClB,GAAW,QAAQ,AAAC,GAAc,CAC9B,EAAE,MAAM,GAAG,EAAE,QAAQ,AAAC,GAAM,CACxB,GAAM,GAAM,EAAE,MAAM,GAAG,EACvB,GAAI,EAAI,QAAU,EAAG,OACrB,GAAM,GAAM,EAAI,MAAM,GAAG,KAAK,EACxB,EAAQ,EAAI,KAAK,GAAG,EAAE,KAAK,EACjC,GAAU,EAAK,CAAK,CACxB,CAAC,CACL,CAAC,EACD,GAAa,EACjB,CAZgB,2tCC3DT,YAAsB,EAAuB,CAChD,EAAW,KAAK,GAAG,CAAK,CAC5B,CAFgB,qBAIhB,YAAsB,EAAa,EAAqB,CACpD,SAAM,KAAK,KAAK,CAAG,EACnB,EAAM,KAAK,MAAM,CAAG,EACb,KAAK,MAAM,KAAK,OAAO,EAAK,GAAM,EAAM,EAAE,EAAI,CACzD,CAJS,qBAMF,aAA8B,CACjC,GAAM,GAAS,GAAa,EAAG,EAAW,OAAS,CAAC,EACpD,MAAO,GAAW,EACtB,CAHgB,2BFQT,WAAwB,EAAiB,EAAuB,CAAE,OAAQ,KAAM,EAA6B,CAChH,MAAO,IAAI,SAAQ,MAAO,EAAS,IAAW,CAC1C,GAAI,GAAM,KAAM,GAAa,EAAS,CAAO,EAAE,MAAM,AAAC,GAAe,CAAG,EACxE,GAAI,YAAe,OAAO,CACtB,EAAO,CAAG,EACV,MACJ,CACA,AAAI,OAAO,EAAI,UAAU,GAAK,KAAO,OAAO,EAAI,UAAU,EAAI,KAC1D,GAAM,KAAM,GAAe,EAAI,QAAQ,SAAoB,CAAO,GAEtE,EAAQ,CAAG,CACf,CAAC,CACL,CAZgB,sBAmBhB,YAAyB,EAAiB,EAAuB,CAAE,OAAQ,KAAM,EAA6B,CAC1G,MAAO,IAAI,SAAQ,MAAO,EAAS,IAAW,CAC1C,GAAI,GAAM,KAAM,GAAa,EAAS,CAAO,EAAE,MAAM,AAAC,GAAe,CAAG,EACxE,GAAI,YAAe,OAAO,CACtB,EAAO,CAAG,EACV,MACJ,CACA,GAAI,OAAO,EAAI,UAAU,GAAK,KAAO,OAAO,EAAI,UAAU,EAAI,IAC1D,EAAM,KAAM,IAAgB,EAAI,QAAQ,SAAoB,CAAO,UAC5D,OAAO,EAAI,UAAU,EAAI,IAAK,CACrC,EAAO,GAAI,OAAM,OAAO,EAAI,6BAA6B,CAAC,EAC1D,MACJ,CACA,EAAQ,CAAG,CACf,CAAC,CACL,CAfS,wBAsBF,WAAiB,EAAiB,EAAuB,CAAE,OAAQ,KAAM,EAAoB,CAChG,MAAO,IAAI,SAAQ,MAAO,EAAS,IAAW,CAC1C,GAAI,GAAgB,GACpB,GAAI,EAAQ,QAAS,CACjB,GAAI,GAAO,GAAW,EACtB,AAAI,MAAO,IAAS,UAAY,EAAQ,SACpC,QAAO,OAAO,EAAQ,QAAS,CAAE,OAAQ,CAAK,CAAC,EAC/C,EAAgB,GAExB,CACA,GAAI,EAAQ,UAAW,CACnB,GAAM,GAAU,CAAC,EACjB,OAAW,KAAU,QAAO,QAAQ,EAAQ,SAAS,EACjD,EAAQ,KAAK,EAAO,KAAK,GAAG,CAAC,EAGjC,GAAI,EAAQ,SAAW,EAAG,CACtB,AAAK,EAAQ,SAAS,GAAQ,QAAU,CAAC,GACzC,GAAM,GAAkB,EAAgB,KAAK,EAAQ,QAAQ,SAAW,GACxE,OAAO,OAAO,EAAQ,QAAS,CAAE,OAAQ,GAAG,EAAQ,KAAK,IAAI,IAAI,GAAkB,CAAC,CACxF,CACJ,CACA,AAAI,EAAQ,SACR,GAAQ,QAAU,IACX,EAAQ,QACX,kBAAmB,oBACnB,aAAc,GAAmB,CACrC,GAEJ,GAAM,GAAM,KAAM,IAAgB,EAAS,CAAO,EAAE,MAAM,AAAC,GAAe,CAAG,EAC7E,GAAI,YAAe,OAAO,CACtB,EAAO,CAAG,EACV,MACJ,CACA,GAAI,EAAI,SAAW,EAAI,QAAQ,cAAe,CAC1C,GAAI,EAAQ,UACR,OAAW,KAAU,GAAI,QAAQ,cAAe,CAC5C,GAAM,GAAQ,EAAO,MAAM,GAAG,EAAE,GAAG,KAAK,EAAE,MAAM,GAAG,EACnD,EAAQ,UAAU,EAAM,MAAM,GAAe,EAAM,KAAK,GAAG,CAC/D,CAEJ,AAAI,GACA,GAAc,EAAI,QAAQ,aAAa,CAE/C,CACA,GAAM,GAAiB,CAAC,EACpB,EACE,EAAW,EAAI,QAAQ,oBAC7B,AAAI,IAAa,OAAQ,EAAU,GAAa,EAC3C,AAAI,IAAa,KAAM,EAAU,GAAuB,EACpD,IAAa,WAAW,GAAU,GAAc,GAEzD,AAAI,EACA,GAAI,KAAK,CAAO,EAChB,EAAQ,YAAY,OAAO,EAC3B,EAAQ,GAAG,OAAQ,AAAC,GAAM,EAAK,KAAK,CAAC,CAAC,EACtC,EAAQ,GAAG,MAAO,IAAM,EAAQ,EAAK,KAAK,EAAE,CAAC,CAAC,GAE9C,GAAI,YAAY,OAAO,EACvB,EAAI,GAAG,OAAQ,AAAC,GAAM,EAAK,KAAK,CAAC,CAAC,EAClC,EAAI,GAAG,MAAO,IAAM,EAAQ,EAAK,KAAK,EAAE,CAAC,CAAC,EAElD,CAAC,CACL,CA/DgB,eAiET,WAAkC,EAA8B,CACnE,MAAO,IAAI,SAAQ,MAAO,EAAS,IAAW,CAC1C,GAAI,GAAM,KAAM,GAAa,EAAK,CAAE,OAAQ,MAAO,CAAC,EAAE,MAAM,AAAC,GAAe,CAAG,EAC/E,GAAI,YAAe,OAAO,CACtB,EAAO,CAAG,EACV,MACJ,CACA,GAAM,GAAa,OAAO,EAAI,UAAU,EACxC,GAAI,EAAa,IACb,EAAQ,CAAG,UACJ,EAAa,IAAK,CACzB,GAAM,GAAW,KAAM,GAAyB,EAAI,QAAQ,QAAkB,EAAE,MAAM,AAAC,GAAQ,CAAG,EAClG,GAAI,YAAoB,OAAO,CAC3B,EAAO,CAAQ,EACf,MACJ,CAEA,EAAQ,CAAQ,CACpB,KACI,GAAO,GAAI,OAAM,GAAG,EAAI,eAAe,EAAI,kBAAkB,GAAK,CAAC,CAE3E,CAAC,CACL,CAtBgB,gCAwBT,YAAgC,EAA8B,CACjE,MAAO,IAAI,SAAQ,MAAO,EAAS,IAAW,CAC1C,GAAI,GAAM,KAAM,GAAa,EAAK,CAAE,OAAQ,MAAO,CAAC,EAAE,MAAM,AAAC,GAAe,CAAG,EAC/E,GAAI,YAAe,OAAO,CACtB,EAAO,CAAG,EACV,MACJ,CACA,GAAM,GAAa,OAAO,EAAI,UAAU,EACxC,GAAI,EAAa,IACb,EAAQ,OAAO,EAAI,QAAQ,iBAAiB,CAAC,UACtC,EAAa,IAAK,CACzB,GAAM,GAAS,KAAM,GAAyB,EAAI,QAAQ,QAAkB,EAAE,MAAM,AAAC,GAAQ,CAAG,EAChG,GAAI,YAAkB,OAAO,CACzB,EAAO,CAAM,EACb,MACJ,CAEA,GAAM,GAAO,KAAM,IAAuB,CAAM,EAAE,MAAM,AAAC,GAAQ,CAAG,EACpE,GAAI,YAAgB,OAAO,CACvB,EAAO,CAAI,EACX,MACJ,CAEA,EAAQ,CAAI,CAChB,KACI,GACI,GAAI,OAAM,4CAA4C,EAAI,eAAe,EAAI,kBAAkB,GAAK,CACxG,CAER,CAAC,CACL,CA9BgB,+BAsChB,WAAsB,EAAiB,EAAuB,CAAC,EAA6B,CACxF,MAAO,IAAI,SAAQ,CAAC,EAAS,IAAW,CACpC,GAAM,GAAI,GAAI,IAAI,CAAO,EACzB,EAAQ,SAAW,MACnB,GAAM,GAA8B,CAChC,KAAM,EAAE,SACR,KAAM,EAAE,SAAW,EAAE,OACrB,QAAS,EAAQ,SAAW,CAAC,EAC7B,OAAQ,EAAQ,MACpB,EAEM,EAAM,GAAa,EAAa,CAAO,EAC7C,EAAI,GAAG,QAAS,AAAC,GAAQ,CACrB,EAAO,CAAG,CACd,CAAC,EACG,EAAQ,SAAW,QAAQ,EAAI,MAAM,EAAQ,IAAI,EACrD,EAAI,IAAI,CACZ,CAAC,CACL,CAlBS,oBG5LT,wCCAA,sDAWA,GAAM,GAAS,mBACT,GAAiB,wCACjB,GAAiB,wCACjB,GAAW,MAAM,MAAkB,MACnC,EAAS,MAAM,KAAU,MACzB,GAAU,SAAS,QAAa,SAChC,GAAW,YACX,GAAmB,sDACnB,GAAiB,kDACjB,GAAkB,8CAClB,GACF,oHAGE,GAAa,GAAI,QACnB,QAAQ,gBAAqB,IAAS,MAAoB,IAAS,MAAkB,IAAS,MAAmB,IAAS,sBAC9H,EACM,GAAkB,GAAI,QACxB,GACI,eAAe,8BAAwC,wBAAmC,MAC3F,uCACsB,UAE7B,EACM,GAAiB,GAAI,QAAO,WAAW,KAAU,KAAoB,GAAG,EACxE,GAAe,GAAI,QAAO,WAAW,KAAU,KAAkB,GAAG,EACpE,GAAgB,GAAI,QAAO,WAAW,KAAU,KAAmB,GAAG,EACtE,GAAc,GAAI,QAAO,WAAW,KAAU,KAAiB,GAAG,EAMxE,YAAmB,EAAc,CAC7B,GAAM,GAAkB,GAAgB,KAAK,CAAI,EAC3C,EAAgB,GAAW,KAAK,CAAI,EAC1C,GAAI,CAAC,GAAmB,CAAC,EAAe,MAAO,MAE/C,GAAM,GAAS,EAAc,GAAG,QAAQ,MAAO,KAAK,EAC9C,EAAc,EAAc,GAAG,QAAQ,MAAO,KAAK,EACnD,EAAgB,EAAgB,GAAG,QAAQ,MAAO,KAAK,EAEzD,EAAS,GAAe,KAAK,CAAW,EACtC,EAAa,GAAU,EAAO,GAAG,QAAQ,MAAO,KAAK,EAAE,QAAQ,kBAAmB,EAAE,EAE1F,EAAS,GAAa,KAAK,CAAW,EACtC,GAAM,GAAW,GAAU,EAAO,GAAG,QAAQ,MAAO,KAAK,EAAE,QAAQ,kBAAmB,EAAE,EAExF,EAAS,GAAc,KAAK,CAAW,EACvC,GAAM,GAAY,GAAU,EAAO,GAAG,QAAQ,MAAO,KAAK,EAAE,QAAQ,kBAAmB,EAAE,EAEzF,EAAS,GAAY,KAAK,CAAW,EACrC,GAAM,GAAU,GAAU,EAAO,GAAG,QAAQ,MAAO,KAAK,EAAE,QAAQ,kBAAmB,EAAE,EAEjF,EAAO,IAAI,CAAC,EAAY,EAAU,EAAW,CAAO,EAAE,KAAK,GAAG,KAC9D,EAAQ,UAAU,UAAe,SAAY,aAAgB,uBAC7D,EAAiB,GAAI,QAAO,EAAO,GAAG,EACtC,EAAS,CAAC,EAChB,KAAQ,GAAS,EAAe,KAAK,CAAa,KAAO,MAErD,OADY,EAAO,IAAM,EAAO,IAAM,EAAO,QAEpC,GACD,EAAO,KAAK,KAAK,EAAO,IAAI,EAC5B,UACC,GACD,EAAO,KAAK,IAAI,EAChB,UACC,GACD,EAAO,KAAK,KAAK,EAAO,IAAI,EAC5B,UACC,GACD,EAAO,KAAK,KAAK,EAAO,IAAI,EAC5B,MAGZ,MAAO,EACX,CA3CS,kBAkDT,YAA2B,EAAkB,EAAmB,CAC5D,GAAI,GAAM,EAAU,MAAM,EAAE,EACtB,EAAM,EAAO,OACnB,OAAS,GAAI,EAAG,EAAI,EAAK,IAAK,CAC1B,GAAI,GAAQ,EAAO,GACf,EACJ,OAAQ,EAAM,MAAM,EAAG,CAAC,OACf,KACD,EAAM,SAAS,EAAM,MAAM,CAAC,CAAC,EAC7B,GAAc,EAAK,CAAG,EACtB,UACC,KACD,EAAI,QAAQ,EACZ,UACC,KACD,EAAM,SAAS,EAAM,MAAM,CAAC,CAAC,EAC7B,EAAM,EAAI,MAAM,CAAG,EACnB,UACC,KACD,EAAM,SAAS,EAAM,MAAM,CAAC,CAAC,EAC7B,EAAI,OAAO,EAAG,CAAG,EACjB,MAEZ,CACA,MAAO,GAAI,KAAK,EAAE,CACtB,CAzBS,0BA+BT,YAAuB,EAAiB,EAAkB,CACtD,GAAM,GAAQ,EAAM,GACpB,EAAM,GAAK,EAAM,GACjB,EAAM,GAAY,CACtB,CAJS,sBAWT,YAAsB,EAAuB,EAAa,CACtD,GAAI,CAAC,EAAO,IAAK,OAEjB,GAAM,GAAc,mBAAmB,EAAO,GAAG,EAE3C,EAAa,GAAI,IAAI,CAAW,EACtC,EAAW,aAAa,IAAI,aAAc,KAAK,EAE3C,GACA,EAAW,aAAa,IAAI,EAAO,IAAM,YAAa,CAAG,EAE7D,EAAO,IAAM,EAAW,SAAS,CACrC,CAZS,qBAmBT,kBAAsC,EAA0B,EAA+C,CAC3G,GAAM,GAAO,KAAM,GAAQ,CAAW,EAChC,EAAS,GAAU,CAAI,EAC7B,SAAQ,QAAQ,AAAC,GAAW,CACxB,GAAM,GAAS,EAAO,iBAAmB,EAAO,OAChD,GAAI,EAAQ,CACR,GAAM,GAAS,OAAO,YAAY,GAAI,IAAgB,CAAM,CAAC,EAC7D,OAAO,OAAO,EAAQ,CAAM,EAC5B,MAAO,GAAO,gBACd,MAAO,GAAO,MAClB,CACA,GAAI,GAAU,EAAO,EAAG,CACpB,GAAM,GAAM,GAAkB,EAAQ,EAAO,CAAC,EAC9C,GAAa,EAAQ,CAAG,EACxB,MAAO,GAAO,EACd,MAAO,GAAO,EAClB,CACJ,CAAC,EACM,CACX,CAnBsB,wBC1If,WAAqB,CAqCxB,YAAY,EAAY,CAAC,EAAG,CACxB,GAAI,CAAC,EAAM,KAAM,IAAI,OAAM,0BAA0B,KAAK,YAAY,0BAA0B,EAChG,KAAK,KAAO,UACZ,KAAK,KAAO,EAAK,MAAQ,KACzB,KAAK,SAAW,CAAC,CAAC,EAAK,UAAY,GACnC,KAAK,OAAS,CAAC,CAAC,EAAK,QAAU,GAC/B,KAAK,GAAK,EAAK,IAAM,KACrB,KAAK,IAAM,EAAK,KAAO,KACvB,KAAK,MAAQ,EAAK,OAAS,CAAC,CAAE,IAAK,KAAM,MAAO,EAAG,OAAQ,CAAE,CAAC,EAC9D,KAAK,YAAc,EAAK,aAAe,IAC3C,CAOA,QAAQ,EAAU,CAAE,KAAM,CAAE,EAAuB,CAC/C,GAAI,MAAO,GAAQ,MAAS,UAAY,EAAQ,KAAO,EAAG,KAAM,IAAI,OAAM,mBAAmB,EAC7F,GAAI,CAAC,KAAK,QAAQ,IAAI,IAAK,OAC3B,GAAM,GAAM,KAAK,QAAQ,IAAI,IAAI,MAAM,IAAI,EAAE,GAAG,MAAM,IAAI,EAAE,GAC5D,MAAO,MAAK,QAAQ,IAAI,IAAI,QAAQ,KAAK,MAAS,KAAK,EAAQ,QAAQ,CAC3E,CAKA,UAAmB,CACf,MAAO,MAAK,MAAQ,EACxB,CAKA,QAAsB,CAClB,MAAO,CACH,KAAM,KAAK,KACX,SAAU,KAAK,SACf,OAAQ,KAAK,OACb,GAAI,KAAK,GACT,IAAK,KAAK,IACV,MAAO,KAAK,MACZ,KAAM,KAAK,KACX,YAAa,KAAK,WACtB,CACJ,CACJ,EAnFO,sBCjBA,WAAuB,CAK1B,YAAY,EAAW,CACnB,KAAK,IAAM,EAAK,IAChB,KAAK,MAAQ,EAAK,MAClB,KAAK,OAAS,EAAK,MACvB,CAEA,QAAS,CACL,MAAO,CACH,IAAK,KAAK,IACV,MAAO,KAAK,MACZ,OAAQ,KAAK,MACjB,CACJ,CACJ,EAlBO,wBC0HA,WAAmB,CAuFtB,YAAY,EAAW,CACnB,GAAI,CAAC,EAAM,KAAM,IAAI,OAAM,oBAAoB,KAAK,YAAY,mBAAmB,EAEnF,KAAK,GAAK,EAAK,IAAM,OACrB,KAAK,IAAM,mCAAmC,KAAK,KACnD,KAAK,KAAO,QACZ,KAAK,MAAQ,EAAK,OAAS,OAC3B,KAAK,YAAc,EAAK,aAAe,OACvC,KAAK,YAAc,EAAK,cAAgB,OACxC,KAAK,cAAiB,GAAK,SAAW,EAAI,EAAI,EAAK,WAAa,EAChE,KAAK,WAAa,EAAK,YAAc,OACrC,KAAK,OAAS,EAAK,QAAU,OAC7B,KAAK,SAAW,EAAK,SACrB,KAAK,MAAQ,SAAS,EAAK,KAAK,GAAK,EACrC,GAAM,GAAa,CAAC,EACpB,OAAW,KAAS,GAAK,WACrB,EAAW,KAAK,GAAI,GAAiB,CAAK,CAAC,EAE/C,KAAK,WAAa,GAAc,CAAC,EACjC,KAAK,QAAU,GAAI,GAAe,EAAK,OAAO,GAAK,CAAC,EACpD,KAAK,MAAQ,EAAK,OAAS,EAC3B,KAAK,KAAO,CAAC,CAAC,EAAK,KACnB,KAAK,QAAU,CAAC,CAAC,EAAK,QACtB,KAAK,KAAO,EAAK,MAAQ,CAAC,EAC1B,KAAK,kBAAoB,EAAK,mBAAqB,OACnD,KAAK,MAAQ,EAAK,OAAS,CAAC,EAC5B,KAAK,SAAW,EAAK,UAAY,CAAC,CACtC,CAKA,UAAmB,CACf,MAAO,MAAK,KAAO,EACvB,CAKA,QAAuB,CACnB,MAAO,CACH,GAAI,KAAK,GACT,IAAK,KAAK,IACV,MAAO,KAAK,MACZ,YAAa,KAAK,YAClB,cAAe,KAAK,cACpB,YAAa,KAAK,YAClB,WAAY,KAAK,WACjB,UAAW,KAAK,WAAW,KAAK,WAAW,OAAS,GAAG,OAAO,GAAK,KAAK,WACxE,QAAS,KAAK,QACd,MAAO,KAAK,MACZ,KAAM,KAAK,KACX,MAAO,KAAK,MACZ,KAAM,KAAK,KACX,QAAS,KAAK,QACd,kBAAmB,KAAK,kBACxB,MAAO,KAAK,MACZ,SAAU,KAAK,QACnB,CACJ,CACJ,EAnJO,oBCrHP,GAAM,IAAW,kDAIV,OAAsB,CAkEzB,YAAY,EAAW,EAAe,GAAO,CAdrC,mBAIJ,CAAC,EAWD,GAAI,CAAC,EAAM,KAAM,IAAI,OAAM,0BAA0B,KAAK,YAAY,0BAA0B,EAChG,KAAK,QAAU,EACf,KAAK,eAAiB,GAAI,KAC1B,KAAK,KAAO,WACZ,AAAI,EAAc,KAAK,cAAc,CAAI,EACpC,KAAK,QAAQ,CAAI,CAC1B,CAKQ,QAAQ,EAAW,CACvB,KAAK,GAAK,EAAK,IAAM,OACrB,KAAK,IAAM,EAAK,KAAO,OACvB,KAAK,MAAQ,EAAK,OAAS,OAC3B,KAAK,WAAa,EAAK,YAAc,EACrC,KAAK,WAAa,EAAK,YAAc,OACrC,KAAK,MAAQ,EAAK,OAAS,EAC3B,KAAK,KAAO,EAAK,MAAQ,OACzB,KAAK,QAAU,GAAI,GAAe,EAAK,OAAO,GAAK,OACnD,KAAK,UAAY,EAAK,UAAY,GAAI,GAAiB,EAAK,SAAS,EAAI,OACzE,KAAK,OAAS,EAAK,QAAU,CAAC,EAC9B,KAAK,UACL,KAAK,eAAe,IAAI,GAAG,KAAK,UAAW,KAAK,MAAwB,EACxE,KAAK,cAAc,IAAM,EAAK,cAAc,KAAO,OACnD,KAAK,cAAc,MAAQ,EAAK,cAAc,OAAS,OACvD,KAAK,cAAc,cAAgB,EAAK,cAAc,eAAiB,kBAC3E,CAKQ,cAAc,EAAW,CAC7B,KAAK,GAAK,EAAK,IAAM,OACrB,KAAK,IAAM,KAAK,GAAK,yCAAyC,KAAK,KAAO,OAC1E,KAAK,MAAQ,EAAK,OAAS,OAC3B,KAAK,UAAY,GAAI,GAAiB,EAAK,SAAS,GAAK,OACzD,KAAK,QAAU,EAAK,SAAW,OAC/B,KAAK,OAAS,CAAC,EACf,KAAK,WAAa,EAAK,QAAU,EACjC,KAAK,KAAO,OACZ,KAAK,WAAa,OAClB,KAAK,MAAQ,CACjB,MAQM,MAAK,EAAQ,IAAmC,CAClD,GAAI,CAAC,KAAK,eAAiB,CAAC,KAAK,cAAc,MAAO,MAAO,CAAC,EAE9D,GAAM,GAAW,KAAM,GAAQ,GAAG,KAAW,KAAK,cAAc,wBAAyB,CACrF,OAAQ,OACR,KAAM,KAAK,UAAU,CACjB,aAAc,KAAK,cAAc,MACjC,QAAS,CACL,OAAQ,CACJ,iBAAkB,EAClB,GAAI,KACJ,GAAI,KACJ,WAAY,MACZ,cAAe,KAAK,cAAc,aACtC,EACA,KAAM,CAAC,EACP,QAAS,CAAC,CACd,CACJ,CAAC,CACL,CAAC,EAEK,EACF,KAAK,MAAM,CAAQ,GAAG,0BAA0B,IAAI,+BAA+B,kBACvF,GAAI,CAAC,EAAU,MAAO,CAAC,EAEvB,GAAM,GAAkB,GAAkB,EAAU,CAAK,EACzD,YAAK,eAAe,IAAI,GAAG,KAAK,UAAW,CAAe,EAC1D,KAAK,cAAc,MAAQ,EAAqB,CAAQ,EACjD,CACX,MAUM,OAAM,EAAM,IAAoC,CAElD,GAAI,CADiB,KAAK,cAAc,MACrB,MAAO,MAG1B,IAFI,EAAM,GAAG,GAAM,KAEZ,MAAO,MAAK,cAAc,OAAU,UAAY,KAAK,cAAc,MAAM,QAAQ,CACpF,KAAK,UACL,GAAM,GAAM,KAAM,MAAK,KAAK,EAG5B,GAFA,GAAO,EAAI,OACP,GAAO,GACP,CAAC,EAAI,OAAQ,KACrB,CAEA,MAAO,KACX,CAiBA,KAAK,EAAgC,CACjC,GAAI,CAAC,EAAQ,KAAM,IAAI,OAAM,6BAA6B,EAC1D,GAAI,CAAC,KAAK,eAAe,IAAI,GAAG,GAAQ,EAAG,KAAM,IAAI,OAAM,8BAA8B,EACzF,MAAO,MAAK,eAAe,IAAI,GAAG,GAAQ,CAC9C,IAKI,cAAc,CACd,MAAO,MAAK,eAAe,IAC/B,IAMI,eAAe,CACf,GAAM,GAAsB,KAAK,YACjC,MAAQ,GAAc,GAAK,IAAO,KAAK,eAAe,IAAI,GAAG,GAAa,EAAqB,MACnG,MAYM,aAAsC,CACxC,KAAM,MAAK,MAAM,EAEjB,GAAM,GAAS,CAAC,EAEhB,OAAW,KAAQ,MAAK,eAAe,OAAO,EAAG,EAAO,KAAK,GAAG,CAAI,EAEpE,MAAO,EACX,CAKA,QAAuB,CACnB,MAAO,CACH,GAAI,KAAK,GACT,MAAO,KAAK,MACZ,UAAW,KAAK,WAAW,OAAO,GAAK,KAAK,UAC5C,QAAS,KAAK,QACd,IAAK,KAAK,IACV,OAAQ,KAAK,MACjB,CACJ,CACJ,EAnPO,uBCJP,sDAaA,GAAM,GAAmB,wBACnB,GAAsB,sCACtB,EAAkB,0CAClB,GACF,iIACE,GACF,0JAkBG,WAAqB,EAAsD,CAC9E,GAAM,GAAO,EAAI,KAAK,EACtB,GAAI,EAAK,QAAQ,OAAO,IAAM,GAC1B,GAAI,EAAK,WAAW,OAAO,EACvB,GAAI,EAAK,MAAM,EAAa,EAAG,CAC3B,GAAI,GAOJ,MANA,AAAI,GAAK,SAAS,WAAW,EAAG,EAAK,EAAK,MAAM,WAAW,EAAE,GAAG,MAAM,WAAW,EAAE,GAC9E,AAAI,EAAK,SAAS,oBAAoB,EACvC,EAAK,EAAK,MAAM,oBAAoB,EAAE,GAAG,MAAM,WAAW,EAAE,GAC3D,AAAI,EAAK,SAAS,qBAAqB,EACxC,EAAK,EAAK,MAAM,qBAAqB,EAAE,GAAG,MAAM,WAAW,EAAE,GAC5D,EAAK,EAAK,MAAM,UAAU,EAAE,IAAI,MAAM,WAAW,EAAE,GACpD,GAAI,MAAM,CAAgB,EAAU,QAC5B,EAChB,KAAO,OAAO,OAEd,OAAI,GAAK,MAAM,CAAgB,EAAU,QAChC,EAAK,MAAM,EAAmB,EAAU,WACrC,aAGhB,OAAK,GAAK,MAAM,EAAgB,EACpB,WAD8B,EAAY,EAAK,QAAQ,oBAAqB,EAAE,CAAC,CAGnG,CAxBgB,mBAgChB,YAAwB,EAAiC,CACrD,GAAI,EAAQ,WAAW,UAAU,GAAK,EAAQ,MAAM,EAAa,EAAG,CAChE,GAAI,GAWJ,GAVA,AAAI,EAAQ,SAAS,WAAW,EAC5B,EAAK,EAAQ,MAAM,WAAW,EAAE,GAAG,MAAM,WAAW,EAAE,GACnD,AAAI,EAAQ,SAAS,oBAAoB,EAC5C,EAAK,EAAQ,MAAM,oBAAoB,EAAE,GAAG,MAAM,WAAW,EAAE,GAC5D,AAAI,EAAQ,SAAS,qBAAqB,EAC7C,EAAK,EAAQ,MAAM,qBAAqB,EAAE,GAAG,MAAM,WAAW,EAAE,GAEhE,EAAM,GAAQ,MAAM,UAAU,EAAE,IAAM,EAAQ,MAAM,KAAK,EAAE,IAAI,MAAM,WAAW,EAAE,GAGlF,EAAG,MAAM,CAAgB,EAAG,MAAO,EAC3C,SAAW,EAAQ,MAAM,CAAgB,EACrC,MAAO,GAGX,MAAO,EACX,CAnBS,uBAyBF,YAAmB,EAAqB,CAC3C,GAAM,GAAQ,EAAY,CAAG,EAC7B,GAAI,CAAC,GAAS,IAAU,SAAU,KAAM,IAAI,OAAM,oDAAoD,EACtG,GAAM,GAAO,EAAI,KAAK,EACtB,GAAI,EAAK,WAAW,OAAO,EACvB,GAAI,EAAK,QAAQ,OAAO,IAAM,GAAI,CAC9B,GAAM,GAAW,GAAe,CAAI,EACpC,GAAI,CAAC,EAAU,KAAM,IAAI,OAAM,oDAAoD,EACnF,MAAO,EACX,KACI,OAAO,GAAK,MAAM,OAAO,EAAE,GAAG,MAAM,GAAG,EAAE,OAE1C,OAAO,EAClB,CAbgB,kBA8BhB,kBAAuC,EAAa,EAAuB,CAAC,EAAsB,CAC9F,GAAI,MAAO,IAAQ,SAAU,KAAM,IAAI,OAAM,uDAAuD,EACpG,GAAM,GAAO,EAAI,KAAK,EAClB,EACE,EAAY,CAAC,EACnB,GAAI,EAAQ,SACR,EAAO,MACJ,CACH,GAAM,GAAW,GAAe,CAAI,EACpC,GAAI,CAAC,EAAU,KAAM,IAAI,OAAM,iCAAiC,EAChE,GAAM,GAAU,mCAAmC,mBACnD,EAAO,KAAM,GAAQ,EAAS,CAC1B,QAAS,CACL,kBAAmB,EAAQ,UAAY,aAC3C,EACA,QAAS,GACT,WACJ,CAAC,CACL,CACA,GAAI,EAAK,QAAQ,uEAAuE,IAAM,GAC1F,KAAM,IAAI,OAAM,wDAAwD,EAC5E,GAAM,GAAc,EACf,MAAM,gCAAgC,IAAI,IACzC,MAAM,aAAY,EAAE,GACrB,MAAM,+BAA+B,EAAE,GAC5C,GAAI,CAAC,EAAa,KAAM,IAAI,OAAM,4CAA4C,EAC9E,GAAM,GAAe,EAChB,MAAM,sBAAsB,IAAI,IAC/B,MAAM,aAAY,EAAE,GACrB,MAAM,uBAAuB,EAAE,GACpC,GAAI,CAAC,EAAc,KAAM,IAAI,OAAM,qCAAqC,EACxE,GAAM,GAAkB,KAAK,MAAM,CAAW,EACxC,EAAmB,KAAK,MAAM,CAAY,EAC1C,EAAM,EAAgB,aAExB,EAAoB,GACpB,EAAW,GACf,GAAI,EAAgB,kBAAkB,SAAW,KAC7C,GAAI,EAAgB,kBAAkB,SAAW,yBAA0B,CACvE,GAAI,EAAQ,SACR,KAAM,IAAI,OACN,gFAAgF,EAAI,SACxF,EACJ,EAAoB,GACpB,GAAM,GACF,EAAiB,OAAO,sBAAsB,cAAc,sBAAsB,YAC7E,eAAe,QAAQ,kBAChC,AAAI,GACA,OAAO,OAAO,EAAW,CACrB,mBAAoB,EAAQ,cAC5B,QAAS,EAAQ,aACrB,CAAC,EAGL,GAAM,GAAgB,KAAM,IAAuB,EAAI,QAAS,EAAW,EAAM,EAAI,EACrF,EAAgB,cAAgB,EAAc,cAC9C,EAAiB,SAAS,0BAA0B,iBAAmB,EAAc,aACzF,SAAW,EAAgB,kBAAkB,SAAW,sBAAuB,EAAW,OAEtF,MAAM,IAAI,OACN;AAAA,EACI,EAAgB,kBAAkB,YAAY,4BAA4B,OAAO,YACjF,EAAgB,kBAAkB,YAAY,mBAAmB,OAAO,YACxE,EAAgB,kBAAkB,QAE1C,EAER,GAAM,GACF,EAAiB,SAAS,0BAA0B,SAAS,SAAS,SAAS,IAAI,4BAC7E,OAAO,mBACX,EAAQ,GAAW,SAAS,IAAI,uBAAuB,OAAO,YAAY,EAC1E,EAAc,0BAA0B,EAAK,MAAM,WAAW,EAAE,GAAG,MAAM,GAAG,EAAE,KAC9E,EAAoB,CAAC,EAC3B,EAAiB,SAAS,0BAA0B,iBAAiB,iBAAiB,QAAQ,QAC1F,AAAC,GAAa,CACV,AAAI,EAAI,sBACJ,EAAQ,KAAK,mCAAmC,EAAI,qBAAqB,SAAS,EAClF,EAAI,qBAAqB,UACzB,EAAI,oBAAoB,SAAS,QAAQ,AAAC,GAAW,CACjD,AAAI,EAAE,sBACF,EAAQ,KAAK,mCAAmC,EAAE,qBAAqB,SAAS,CACxF,CAAC,CACT,CACJ,EACA,GAAM,GAAc,EAAgB,YAAY,0BAC1C,GAAY,EAAiB,iBAAiB,KAAK,AAAC,GAAc,GAAM,oCAAoC,iBAAmB,yCAAyC,GAAG,mCAAmC,QAAQ,qCAAqC,MAC5P,KAAK,AAAC,GAAY,EAAG,oCAAoC,GAAG,qCAAqC,gBAEhG,GAAe,CAAC,EACtB,AAAI,IACA,GAAU,QAAQ,AAAC,GAAW,CAC1B,GAAI,CAAC,EAAE,uBAAwB,OAC/B,GAAM,GAAM,EAAE,uBAER,GAAO,EAAI,aAAa,qBAAqB,MAAM,YAAc,EAAI,aAAa,qBAAqB,MAAM,MAAM,KAAK,AAAC,GAAU,EAAE,IAAI,GAAG,KAC5I,GAAW,EAAI,UAAU,IAAI,AAAC,GAAc,CAAC,EAAK,gBAAgB,MAAM,WAAW,YAAY,EAAK,GAAK,gBAAgB,kBAAoB,EAAK,gBAAgB,kBAAkB,MAAM,IAAI,AAAC,IAAU,GAAE,IAAI,EAAE,KAAK,EAAE,GAAM,EAAK,gBAAgB,iBAAiB,YAAc,EAAK,gBAAgB,kBAAkB,YAAc,EAAE,CAAC,EAC1U,GAAW,OAAO,YAAY,IAAY,CAAC,CAAC,EAC5C,GAAK,EAAI,aAAa,qBAAqB,oBAAoB,cAAc,SAC5E,EAAI,UAAU,KAAK,AAAC,GAAW,EAAE,gBAAgB,MAAM,WAAW,YAAY,GAAK,MAAM,GAAG,gBAAgB,gBAAgB,MAAM,KAAK,AAAC,GAAW,EAAE,kBAAkB,GAAG,mBAAmB,eAAe,QAEnN,GAAM,KAAK,CAAC,QAAM,IAAK,GAAK,mCAAmC,KAAO,QAAS,EAAQ,CAAC,CAC5F,CAAC,EAEL,GAAM,IACF,EAAiB,eAAe,sBAAsB,4BAA4B,2BAA2B,WAAW,8BAA8B,WAAW,KAC7J,AAAC,GAAW,EAAE,MAAQ,sBAC1B,GAAG,OAAO,SACR,GAA2B,CAAC,EAClC,GAAI,GACA,OAAW,CAAE,oBAAqB,IAC9B,GAAS,KAAK,CACV,MAAO,EAAgB,MAAM,WAC7B,UAAW,GAAa,EAAgB,qBAAuB,GAAI,EACnE,QAAS,EAAgB,qBAAuB,IAChD,WAAY,EAAgB,UAAU,UAC1C,CAAC,EAGT,GAAI,IACJ,GAAI,EACA,GAAI,EAAY,qBAAqB,eACjC,GAAe,GAAI,MAAK,EAAY,qBAAqB,cAAc,MACtE,CACD,GAAM,GACF,EAAgB,kBAAkB,kBAAkB,0BAA0B,aACzE,+BAA+B,mBACxC,GAAe,GAAI,MAAK,SAAS,CAAS,EAAI,GAAI,CACtD,CAGJ,GAAM,IAAe,EAAiB,SAAS,0BAA0B,QAAQ,QAAQ,SACpF,KAAK,AAAC,GAAiB,EAAQ,wBAAwB,GACtD,yBAAyB,aAAa,aAAa,iBAAiB,KAClE,AAAC,GAAgB,EAAO,sBAAsB,YAAY,WAAa,QAAU,EAAO,oCAAoC,WAAW,sBAAsB,YAAY,WAAa,MAC1L,EAEE,GAAgB,GAAI,GAAa,CACnC,GAAI,EAAI,QACR,MAAO,EAAI,MACX,YAAa,EAAI,iBACjB,SAAU,OAAO,EAAI,aAAa,EAClC,aAAc,GAAa,EAAI,aAAa,EAC5C,WAAY,EAAY,YACxB,OAAQ,EAAY,sBAAsB,eAC1C,SAAU,GACV,WAAY,EAAI,UAAU,WAC1B,QAAS,CACL,KAAM,EAAI,OACV,GAAI,EAAI,UACR,IAAK,mCAAmC,EAAI,YAC5C,SAAU,QAAQ,GAAO,SAAS,UAAU,CAAC,EAC7C,OAAQ,QAAQ,GAAO,SAAS,QAAQ,CAAC,EACzC,MAAO,GAAW,WAAW,YAAc,MAC/C,EACA,MAAO,EAAI,UACX,KAAM,EAAI,SACV,MAAO,SACH,IAAc,sBAAsB,YAAY,eAAe,kBAAkB,MAAM,QAAQ,OAAQ,EAAE,GACzG,IAAc,oCAAoC,WAAW,sBAAsB,YAAY,eAAe,kBAAkB,MAAM,QAAQ,OAAQ,EAAE,GAAK,CACjK,EACA,KAAM,EAAI,cACV,QAAS,EAAI,UACb,oBACA,SACA,WACJ,CAAC,EACG,EAAS,CAAC,EACd,MAAK,IACD,GAAO,KAAK,GAAI,EAAgB,cAAc,SAAW,CAAC,CAAE,EAC5D,EAAO,KAAK,GAAI,EAAgB,cAAc,iBAAmB,CAAC,CAAE,EAKhE,EAAkB,CAAM,EAAE,SAAW,GAAK,CAAC,EAAQ,UACnD,GAAS,KAAM,IAAkB,EAAI,QAAS,EAAW,CAAI,IAQ9D,CACH,eANmB,CACnB,OAAQ,GAAc,KACtB,gBAAiB,EAAgB,eAAe,iBAAmB,KACnE,eAAgB,EAAgB,eAAe,gBAAkB,IACrE,EAGI,cACA,SACA,iBACA,eAAgB,CACpB,CACJ,CA9LsB,yBA0MtB,iBAAwC,EAAa,EAAuB,CAAC,EAA4B,CACrG,GAAI,MAAO,IAAQ,SAAU,KAAM,IAAI,OAAM,uDAAuD,EACpG,GAAI,GACE,EAAY,CAAC,EACnB,GAAI,EAAQ,SACR,EAAO,MACJ,CACH,GAAM,GAAW,GAAe,CAAG,EACnC,GAAI,CAAC,EAAU,KAAM,IAAI,OAAM,iCAAiC,EAChE,GAAM,GAAU,mCAAmC,mBACnD,EAAO,KAAM,GAAQ,EAAS,CAC1B,QAAS,CAAE,kBAAmB,gBAAiB,EAC/C,QAAS,GACT,WACJ,CAAC,CACL,CACA,GAAI,EAAK,QAAQ,uEAAuE,IAAM,GAC1F,KAAM,IAAI,OAAM,wDAAwD,EAC5E,GAAM,GAAc,EACf,MAAM,gCAAgC,IAAI,IACzC,MAAM,aAAY,EAAE,GACrB,MAAM,+BAA+B,EAAE,GAC5C,GAAI,CAAC,EAAa,KAAM,IAAI,OAAM,4CAA4C,EAC9E,GAAM,GAAkB,KAAK,MAAM,CAAW,EAC1C,EAAW,GACf,GAAI,EAAgB,kBAAkB,SAAW,KAC7C,GAAI,EAAgB,kBAAkB,SAAW,yBAA0B,CACvE,GAAI,EAAQ,SACR,KAAM,IAAI,OACN,gFAAgF,EAAgB,aAAa,SACjH,EAEJ,GAAM,GAAe,EAChB,MAAM,sBAAsB,IAAI,IAC/B,MAAM,aAAY,EAAE,GACrB,MAAM,uBAAuB,EAAE,GACpC,GAAI,CAAC,EAAc,KAAM,IAAI,OAAM,qCAAqC,EAExE,GAAM,GACF,KAAK,MAAM,CAAY,EAAE,OAAO,sBAAsB,cAAc,sBAAsB,YACrF,eAAe,QAAQ,kBAChC,AAAI,GACA,OAAO,OAAO,EAAW,CACrB,mBAAoB,EAAQ,cAC5B,QAAS,EAAQ,aACrB,CAAC,EAGL,GAAM,GAAgB,KAAM,IACxB,EAAgB,aAAa,QAC7B,EACA,EACA,EACJ,EACA,EAAgB,cAAgB,EAAc,aAClD,SAAW,EAAgB,kBAAkB,SAAW,sBAAuB,EAAW,OAEtF,MAAM,IAAI,OACN;AAAA,EACI,EAAgB,kBAAkB,YAAY,4BAA4B,OAAO,YACjF,EAAgB,kBAAkB,YAAY,mBAAmB,OAAO,YACxE,EAAgB,kBAAkB,QAE1C,EAER,GAAM,GAAc,0BAA0B,EAAK,MAAM,WAAW,EAAE,GAAG,MAAM,GAAG,EAAE,KAC9E,EAAW,OAAO,EAAgB,aAAa,aAAa,EAC5D,EAAgB,CAClB,IAAK,mCAAmC,EAAgB,aAAa,UACrE,cAAgB,GAAW,EAAI,EAAI,IAAa,CACpD,EACI,EAAS,CAAC,EACd,AAAK,GACD,GAAO,KAAK,GAAI,EAAgB,cAAc,SAAW,CAAC,CAAE,EAC5D,EAAO,KAAK,GAAI,EAAgB,cAAc,iBAAmB,CAAC,CAAE,EAKhE,EAAkB,CAAM,EAAE,SAAW,GAAK,CAAC,EAAQ,UACnD,GAAS,KAAM,IAAkB,EAAgB,aAAa,QAAS,EAAW,CAAI,IAI9F,GAAM,GAAiB,CACnB,OAAQ,EAAgB,aAAa,cACrC,gBAAiB,EAAgB,eAAe,iBAAmB,KACnE,eAAgB,EAAgB,eAAe,gBAAkB,IACrE,EACA,MAAO,MAAM,GACT,CACI,iBACA,cACA,SACA,eACJ,EACA,EACJ,CACJ,CAlGsB,yBAwGtB,YAAsB,EAAyB,CAC3C,GAAM,GAAI,OAAO,CAAO,EAClB,EAAI,KAAK,MAAM,EAAI,IAAI,EACvB,EAAI,KAAK,MAAO,EAAI,KAAQ,EAAE,EAC9B,EAAI,KAAK,MAAO,EAAI,KAAQ,EAAE,EAE9B,EAAW,EAAI,EAAK,GAAI,GAAK,IAAI,IAAM,GAAK,IAAM,GAClD,EAAW,EAAI,EAAK,GAAI,GAAK,IAAI,IAAM,GAAK,IAAM,MAClD,EAAW,EAAI,EAAK,EAAI,GAAK,IAAI,IAAM,EAAK,KAClD,MAAO,GAAW,EAAW,CACjC,CAVS,qBA8BT,kBAAiC,EAAa,EAAuB,CAAC,EAAsB,CACxF,GAAM,GAAO,KAAM,IAAiB,EAAI,KAAK,EAAG,CAAO,EACvD,MAAO,MAAM,GAAc,CAAI,CACnC,CAHsB,mBAUtB,iBACI,EACA,EAAsB,GACZ,CACV,MACI,GAAK,eAAe,SAAW,IAC/B,EAAK,eAAe,kBAAoB,MACxC,EAAK,cAAc,gBAAkB,GAG9B,EAAK,OAAO,OAAS,GAAM,GAAK,OAAO,GAAG,iBAAmB,EAAK,OAAO,GAAG,SAC/E,IAAY,GAAK,OAAS,EAAkB,EAAK,MAAM,GAC3D,EAAK,OAAS,KAAM,IAAgB,EAAK,OAAQ,EAAK,WAAW,GAC1D,CAEf,CAfsB,qBAkCtB,kBAAoC,EAAa,EAA2B,CAAC,EAA6B,CACtG,GAAI,CAAC,GAAO,MAAO,IAAQ,SAAU,KAAM,IAAI,OAAM,mCAAmC,MAAO,KAAM,EACrG,GAAI,GAAO,EAAI,KAAK,EAEpB,GADK,EAAK,WAAW,OAAO,GAAG,GAAO,yCAAyC,KAC3E,EAAK,QAAQ,OAAO,IAAM,GAAI,KAAM,IAAI,OAAM,4BAA4B,EAE9E,GAAI,EAAK,SAAS,mBAAmB,EAAG,CACpC,GAAM,GAAS,GAAI,IAAI,CAAI,EAC3B,EAAO,SAAW,kBAClB,EAAO,EAAO,SAAS,CAC3B,CAEA,GAAM,GAAO,KAAM,GAAQ,EAAM,CAC7B,QAAS,CACL,kBAAmB,EAAQ,UAAY,aAC3C,CACJ,CAAC,EACD,GAAI,EAAK,QAAQ,uEAAuE,IAAM,GAC1F,KAAM,IAAI,OAAM,wDAAwD,EAC5E,GAAM,GAAW,KAAK,MAClB,EACK,MAAM,sBAAsB,EAAE,GAC9B,MAAM,aAAY,EAAE,GACpB,MAAM,uBAAuB,EAAE,EACxC,EACA,GAAI,EAAS,OACT,GAAI,EAAS,OAAO,GAAG,yBAAyB,OAAS,QACrD,GAAI,CAAC,EAAQ,WACT,KAAM,IAAI,OACN;AAAA,EAA+B,EAAS,OAAO,GAAG,wBAAwB,KAAK,YACnF,MACD,MAAI,GAAS,OAAO,GAAG,eAAe,OAAS,QAC5C,GAAI,OAAM;AAAA,EAA+B,EAAS,OAAO,GAAG,cAAc,KAAK,KAAK,GAAG,MAAM,EAC5F,GAAI,OAAM;AAAA,uBAAoD,EAE7E,MAAI,GAAK,QAAQ,UAAU,IAAM,IAAM,EAAK,QAAQ,WAAW,IAAM,GAC1D,GAAiB,EAAU,EAAM,CAAI,EAClC,GAAkB,EAAU,CAAI,CAClD,CAtCsB,sBA6Cf,YAA2B,EAAW,EAAQ,IAA0B,CAC3E,GAAM,GAAS,CAAC,EAEhB,OAAS,GAAI,EAAG,EAAI,EAAK,QACjB,IAAU,EAAO,OADQ,IAAK,CAElC,GAAM,GAAO,EAAK,GAAG,sBACrB,AAAI,CAAC,GAAQ,CAAC,EAAK,iBAEnB,EAAO,KACH,GAAI,GAAa,CACb,GAAI,EAAK,QACT,SAAU,SAAS,EAAK,aAAa,GAAK,EAC1C,aAAc,EAAK,YAAY,YAAc,OAC7C,WAAY,EAAK,UAAU,WAC3B,MAAO,EAAK,MAAM,KAAK,GAAG,KAC1B,SAAU,EAAK,mBAAmB,UAC5B,GAAI,MAAK,SAAS,EAAK,kBAAkB,SAAS,EAAI,GAAI,EAC1D,OACN,QAAS,CACL,GAAI,EAAK,gBAAgB,KAAK,GAAG,mBAAmB,eAAe,UAAY,OAC/E,KAAM,EAAK,gBAAgB,KAAK,GAAG,MAAQ,OAC3C,IAAK,0BACD,EAAK,gBAAgB,KAAK,GAAG,mBAAmB,eAAe,kBAC/D,EAAK,gBAAgB,KAAK,GAAG,mBAAmB,gBAAgB,mBAAmB,MAEvF,KAAM,MACV,CACJ,CAAC,CACL,CACJ,CACA,MAAO,EACX,CA/BgB,0BAqCT,WAA8B,EAAmB,CACpD,MAAO,GAAK,KAAK,AAAC,GAAW,OAAO,KAAK,CAAC,EAAE,KAAO,0BAA0B,GAAG,yBAC3E,sBAAsB,qBAAqB,KACpD,CAHgB,4BAKhB,kBACI,EACA,EACA,EACA,EACoD,CACpD,GAAM,GACF,EAAK,MAAM,sBAAsB,EAAE,IAAI,MAAM,GAAG,EAAE,IAClD,EAAK,MAAM,oBAAoB,EAAE,IAAI,MAAM,GAAG,EAAE,IAChD,EACE,EACF,EAAK,MAAM,gBAAgB,EAAE,IAAI,MAAM,GAAG,EAAE,GAAG,WAAW,UAAW,GAAG,GACxE,EAAK,MAAM,gBAAgB,EAAE,IAAI,MAAM,GAAG,EAAE,GAAG,WAAW,UAAW,GAAG,EAC5E,GAAI,CAAC,EACD,KAAM,IAAI,OAAM,iFAAiF,IAAU,EAE/G,GAAM,GAAuB,KAAM,GAAQ,sDAAsD,sBAA4B,CACzH,OAAQ,OACR,KAAM,KAAK,UAAU,CACjB,QAAS,CACL,OAAQ,CACJ,iBAAkB,EAClB,GAAI,KACJ,GAAI,KACJ,WAAY,MACZ,cACI,EAAK,MAAM,sCAAsC,EAAE,IAAI,MAAM,GAAG,EAAE,IAClE,EAAK,MAAM,sCAAsC,EAAE,IAAI,MAAM,GAAG,EAAE,IAClE,gBACR,EACA,KAAM,CAAC,EACP,QAAS,CAAC,CACd,EACA,aAAc,CACV,YAAa,CACT,IAAK,WAAW,GACpB,CACJ,EACA,eAAgB,EACpB,CAAC,EACD,QAAS,GACT,WACJ,CAAC,EAEK,EAAW,KAAK,MAAM,CAAoB,EAAE,QAAQ,GAAG,eAAe,SAEtE,EAAY,KAAM,GAAQ,2BAA2B,EAAS,YAAY,YAAa,CACzF,OAAQ,OACR,QAAS,CACL,eAAgB,mCACpB,EACA,KAAM,GAAI,IAAgB,CACtB,CAAC,UAAW,KAAK,UAAU,CAAQ,CAAC,EACpC,CAAC,gBAAiB,CAAY,CAClC,CAAC,EAAE,SAAS,EACZ,QAAS,GACT,WACJ,CAAC,EAED,GAAI,EAAU,SAAS,+BAA+B,EAClD,KAAM,IAAI,OAAM,2DAA2D,GAAS,EAExF,GAAM,GAAgB,KAAK,MAAM,CAAS,EAE1C,GAAI,EAAc,GAAG,eAAe,kBAAkB,SAAW,KAC7D,KAAM,IAAI,OACN,qFAAqF;AAAA,EACjF,EAAc,GAAG,eAAe,kBAAkB,YAAY,4BAA4B,OACrF,YACL,EAAc,GAAG,eAAe,kBAAkB,YAAY,mBAAmB,OAAO,YAEhG,EAEJ,GAAM,GAAgB,EAAc,GAAG,eAAe,cAEtD,MAAI,GACO,CACH,gBACA,cAAe,EAAc,GAAG,SAAS,SAAS,0BAA0B,gBAChF,EAEG,CAAE,eAAc,CAC3B,CAlFe,+BAoFf,kBAAiC,EAAiB,EAAsC,EAA8B,CAClH,GAAM,GACF,EAAK,MAAM,sBAAsB,EAAE,IAAI,MAAM,GAAG,EAAE,IAClD,EAAK,MAAM,oBAAoB,EAAE,IAAI,MAAM,GAAG,EAAE,IAChD,EAEE,EAAW,KAAM,GAAQ,kDAAkD,sBAA4B,CACzG,OAAQ,OACR,KAAM,KAAK,UAAU,CACjB,QAAS,CACL,OAAQ,CACJ,WAAY,UACZ,cAAe,QACf,GAAI,KACJ,SAAU,MACV,iBAAkB,CACtB,CACJ,EACA,QAAS,EACT,gBAAiB,CAAE,uBAAwB,CAAE,gBAAiB,kBAAmB,CAAE,EACnF,eAAgB,GAChB,YAAa,EACjB,CAAC,EACD,QAAS,GACT,WACJ,CAAC,EAED,MAAO,MAAK,MAAM,CAAQ,EAAE,cAAc,OAC9C,CA5Be,0BA8Bf,YAA0B,EAAe,EAAW,EAA8B,CAC9E,GAAM,GAAmB,EAAS,SAAS,0BAA0B,UAAU,SAC/E,GAAI,CAAC,EACD,KAAM,IAAI,OAAM,2DAA2D,EAE/E,GAAM,GAAS,GAAuB,EAAiB,QAAQ,EACzD,EACF,EAAK,MAAM,sBAAsB,EAAE,IAAI,MAAM,GAAG,EAAE,IAClD,EAAK,MAAM,oBAAoB,EAAE,IAAI,MAAM,GAAG,EAAE,IAChD,EAEE,EAAa,EAAiB,YAC9B,EAAU,EAAiB,iBAAiB,OAAO,GACnD,EAAQ,EAAiB,SAAS,IAAI,uBAAuB,MAAM,YAAY,EAErF,MAAO,IAAI,GAAgB,CACvB,aAAc,CACV,IAAK,EACL,MAAO,EAAqB,EAAiB,QAAQ,EACrD,cACI,EAAK,MAAM,sCAAsC,EAAE,IAAI,MAAM,GAAG,EAAE,IAClE,EAAK,MAAM,sCAAsC,EAAE,IAAI,MAAM,GAAG,EAAE,IAClE,gBACR,EACA,GAAI,EAAiB,YAAc,GACnC,MAAO,EAAiB,OAAS,GACjC,WAAY,SAAS,CAAU,GAAK,EACpC,OAAQ,EACR,IAAK,EACL,QAAS,CACL,GAAI,GAAS,oBAAoB,gBAAgB,UAAY,KAC7D,KAAM,GAAS,MAAQ,KACvB,IAAK,0BACD,GAAS,oBAAoB,gBAAgB,kBAC7C,GAAS,oBAAoB,iBAAiB,oBAAoB,MAEtE,SAAU,QAAQ,GAAO,SAAS,UAAU,CAAC,EAC7C,OAAQ,QAAQ,GAAO,SAAS,QAAQ,CAAC,CAC7C,CACJ,CAAC,CACL,CAxCS,yBA0CT,YAA2B,EAAe,EAA4B,CAClE,GAAM,GACF,EAAS,SAAS,+BAA+B,KAAK,GAAG,YAAY,QAAQ,oBAAoB,SAAS,GACrG,oBAAoB,SAAS,GAAG,0BAA0B,SAC7D,EAAmB,EAAS,QAAQ,wBAAwB,MAE5D,EACF,EAAK,MAAM,sBAAsB,EAAE,IAAI,MAAM,GAAG,EAAE,IAClD,EAAK,MAAM,oBAAoB,EAAE,IAAI,MAAM,GAAG,EAAE,IAChD,EACE,EAAS,GAAkB,EAAW,GAAG,EAEzC,EAAO,EAAiB,GAAG,mCACjC,GAAI,CAAC,EAAK,MAAM,MAAQ,CAAC,EAAK,MAAM,KAAK,OAAQ,KAAM,IAAI,OAAM,gCAAgC,EAEjG,GAAM,GAAS,EAAiB,IAAI,qCAAqC,WACnE,EAAQ,EAAK,MAAM,SAAW,EAAI,EAAK,MAAM,GAAG,WAAW,QAAQ,MAAO,EAAE,EAAI,EAChF,EACF,EAAK,MACA,KAAK,AAAC,GAAW,QAAU,IAAK,EAAE,KAAQ,KAAK,AAAC,GAAW,EAAE,KAAK,YAAY,EAAE,SAAS,aAAa,CAAC,CAAC,GACvG,KAAK,IAAI,GAAG,MAAQ,KACxB,EAAc,EAAK,MAAM,GAAG,KAAK,GAAG,KAAK,QAAQ,MAAO,EAAE,GAAK,EAoCrE,MAlCY,IAAI,GAAgB,CAC5B,aAAc,CACV,IAAK,EACL,MAAO,EAAqB,CAAS,EACrC,cACI,EAAK,MAAM,sCAAsC,EAAE,IAAI,MAAM,GAAG,EAAE,IAClE,EAAK,MAAM,sCAAsC,EAAE,IAAI,MAAM,GAAG,EAAE,IAClE,gBACR,EACA,GAAI,EAAK,MAAM,KAAK,GAAG,mBAAmB,cAAc,WACxD,MAAO,EAAK,MAAM,KAAK,GAAG,KAC1B,WAAY,SAAS,CAAW,GAAK,EACrC,WAAY,EACZ,MAAO,SAAS,CAAK,GAAK,EAC1B,OAAQ,EACR,IAAK,yCAAyC,EAAK,MAAM,KAAK,GAAG,mBAAmB,cAAc,aAClG,KAAM,0BAA0B,EAAK,MAAM,KAAK,GAAG,mBAAmB,gBAAgB,mBAAmB,MACzG,QAAS,EACH,CACI,KAAM,EAAO,mBAAmB,MAAM,KAAK,GAAG,KAC9C,GAAI,EAAO,mBAAmB,MAAM,KAAK,GAAG,mBAAmB,eAAe,SAC9E,IAAK,0BACD,EAAO,mBAAmB,mBAAmB,gBAAgB,mBAAmB,KAChF,EAAO,mBAAmB,mBAAmB,eAAe,mBAEhE,MAAO,EAAO,mBAAmB,UAAU,YAAc,CAAC,CAC9D,EACA,CAAC,EACP,UAAW,EAAK,kBAAkB,gCAAgC,UAAU,WAAW,OACjF,EAAK,kBAAkB,+BAA+B,UAAU,WAC5D,EAAK,kBAAkB,+BAA+B,UAAU,WAAW,OAAS,GAExF,IACV,CAAC,CAEL,CA1DS,0BA4DT,YAAgC,EAAW,EAAQ,IAA0B,CACzE,GAAM,GAAyB,CAAC,EAEhC,OAAS,GAAI,EAAG,EAAI,EAAK,QACjB,IAAU,EAAO,OADQ,IAAK,CAElC,GAAM,GAAO,EAAK,GAAG,2BACrB,GAAI,CAAC,GAAQ,CAAC,EAAK,gBAAiB,SACpC,GAAM,GAAe,EAAK,gBAAgB,KAAK,GAE/C,EAAO,KACH,GAAI,GAAa,CACb,GAAI,EAAK,QACT,SAAU,GAAc,EAAK,YAAY,UAAU,GAAK,EACxD,aAAc,EAAK,YAAY,YAAc,OAC7C,WAAY,EAAK,UAAU,WAC3B,MAAO,EAAK,MAAM,WAClB,SACI,EAAK,kBAAkB,GAAG,oCAAoC,QAAU,YAAc,OAC1F,QAAS,CACL,GAAI,EAAa,mBAAmB,eAAe,UAAY,OAC/D,KAAM,EAAa,MAAQ,OAC3B,IAAK,0BACD,EAAa,mBAAmB,eAAe,kBAC/C,EAAa,mBAAmB,gBAAgB,mBAAmB,MAEvE,KAAM,MACV,CACJ,CAAC,CACL,CACJ,CAEA,MAAO,EACX,CAhCS,+BAkCT,YAAuB,EAAsB,CACzC,GAAI,CAAC,EAAM,MAAO,GAClB,GAAM,GAAQ,EAAK,MAAM,GAAG,EAE5B,OAAQ,EAAM,YACL,GACD,MAAO,UAAS,EAAM,EAAE,EAAI,GAAK,SAAS,EAAM,EAAE,MAEjD,GACD,MAAO,UAAS,EAAM,EAAE,EAAI,GAAK,GAAK,SAAS,EAAM,EAAE,EAAI,GAAK,SAAS,EAAM,EAAE,UAGjF,MAAO,GAEnB,CAdS,sBNz0BT,gCAKO,YAAiB,CA0DpB,YAAY,EAAkB,EAAkB,EAAmB,EAAmB,CAClF,KAAK,OAAS,GAAI,IAAS,CAAE,cAAe,EAAI,IAAO,IAAM,MAAO,CAAC,CAAE,CAAC,EACxE,KAAK,KAAO,YACZ,KAAK,SAAW,EAChB,KAAK,SAAW,EAChB,KAAK,SAAW,GAChB,KAAK,SAAW,EAChB,KAAK,UAAY,EACjB,KAAK,SAAW,GAAY,EAC5B,KAAK,WAAa,GAAI,GAAM,IAAM,CAC9B,KAAK,aAAa,EAClB,KAAK,WAAW,MAAM,CAC1B,EAAG,IAAI,EACP,KAAK,OAAO,GAAG,QAAS,IAAM,CAC1B,KAAK,QAAQ,CACjB,CAAC,EACD,KAAK,gBAAgB,CACzB,CAMQ,SAAU,CACd,KAAK,cAAc,QAAQ,EAC3B,KAAK,WAAW,QAAQ,EACxB,KAAK,SAAS,QAAQ,EACtB,KAAK,UAAY,GACjB,KAAK,QAAU,OACf,KAAK,SAAW,GAChB,KAAK,SAAW,GAChB,KAAK,SAAW,CACpB,MAMc,eAAe,CACzB,GAAM,GAAO,KAAM,GAAkB,KAAK,SAAS,EACnD,MAAI,GAAK,eAAe,iBAAiB,MAAK,SAAW,EAAK,eAAe,iBACtE,KAAK,gBAAgB,CAChC,MAMc,kBAAkB,CAE5B,GAAM,GAAc,AADH,MAAM,GAAQ,KAAK,QAAQ,GAEvC,MAAM,uBAAuB,EAAE,GAC/B,MAAM,kBAAkB,EAAE,GAC1B,MAAM,mBAAmB,EAI9B,GAHI,EAAY,EAAY,OAAS,KAAO,IAAI,EAAY,IAAI,EAChE,KAAK,SAAW,EAAY,EAAY,OAAS,GAAG,MAAM,WAAW,EAAE,GAAG,MAAM,YAAY,EAAE,GAC9F,KAAM,GAAe,WAAW,GAAI,IAAI,KAAK,QAAQ,EAAE,mBAAmB,EACtE,KAAK,WAAa,EAAG,CACrB,GAAM,GAAO,EAAY,EAAY,OAAS,GACzC,MAAM,eAAe,EAAE,GACvB,MAAM,gBAAgB,EAAE,GACxB,WAAW,sBAAuB,EAAE,EACpC,MAAM,KAAK,EAChB,AAAI,EAAK,EAAK,OAAS,KAAO,IAAI,EAAK,IAAI,EACvC,EAAK,OAAS,KAAK,UAAU,EAAK,OAAO,EAAG,EAAK,OAAS,KAAK,QAAQ,EAC3E,KAAK,SAAW,OAAO,EAAK,GAAG,MAAM,KAAK,EAAE,GAAG,MAAM,GAAG,EAAE,EAAE,EAC5D,KAAK,WAAW,EAAK,MAAM,CAC/B,CACJ,MAKc,YAAW,EAAa,CAClC,OAAS,GAAI,EAAG,GAAK,EAAK,IACtB,KAAM,IAAI,SAAQ,KAAO,IAAY,CACjC,GAAM,GAAS,KAAM,GAAe,KAAK,SAAW,MAAQ,KAAK,QAAQ,EAAE,MAAM,AAAC,GAAe,CAAG,EACpG,GAAI,YAAkB,OAAO,CACzB,KAAK,OAAO,KAAK,QAAS,CAAM,EAChC,MACJ,CACA,KAAK,QAAU,EACf,EAAO,GAAG,OAAQ,AAAC,GAAM,CACrB,KAAK,OAAO,KAAK,CAAC,CACtB,CAAC,EACD,EAAO,GAAG,MAAO,IAAM,CACnB,KAAK,WACL,EAAQ,EAAE,CACd,CAAC,EACD,EAAO,KAAK,QAAS,AAAC,GAAQ,CAC1B,KAAK,OAAO,KAAK,QAAS,CAAG,CACjC,CAAC,CACL,CAAC,EAEL,KAAK,aAAe,GAAI,GAAM,IAAM,CAChC,KAAK,KAAK,EACV,KAAK,cAAc,MAAM,CAC7B,EAAG,KAAK,QAAQ,CACpB,CAMQ,MAAO,CACX,MAAO,IAAI,SAAQ,KAAO,IAAY,CAClC,GAAM,GAAS,KAAM,GAAe,KAAK,SAAW,MAAQ,KAAK,QAAQ,EAAE,MAAM,AAAC,GAAe,CAAG,EACpG,GAAI,YAAkB,OAAO,CACzB,KAAK,OAAO,KAAK,QAAS,CAAM,EAChC,MACJ,CACA,KAAK,QAAU,EACf,EAAO,GAAG,OAAQ,AAAC,GAAM,CACrB,KAAK,OAAO,KAAK,CAAC,CACtB,CAAC,EACD,EAAO,GAAG,MAAO,IAAM,CACnB,KAAK,WACL,EAAQ,EAAE,CACd,CAAC,EACD,EAAO,KAAK,QAAS,AAAC,GAAQ,CAC1B,KAAK,OAAO,KAAK,QAAS,CAAG,CACjC,CAAC,CACL,CAAC,CACL,CAIA,OAAQ,CAAC,CAIT,QAAS,CAAC,CACd,EA9LO,mBAkMA,YAAa,CAqDhB,YACI,EACA,EACA,EACA,EACA,EACA,EACF,CACE,KAAK,OAAS,GAAI,IAAS,CAAE,cAAe,EAAI,IAAO,IAAM,MAAO,CAAC,CAAE,CAAC,EACxE,KAAK,IAAM,EACX,KAAK,QAAU,EAAQ,QACvB,KAAK,KAAO,EACZ,KAAK,YAAc,EACnB,KAAK,UAAY,EACjB,KAAK,cAAgB,KAAK,KAAK,EAAgB,CAAQ,EACvD,KAAK,eAAiB,EACtB,KAAK,QAAU,KACf,KAAK,MAAQ,GAAI,GAAM,IAAM,CACzB,KAAK,MAAM,MAAM,EACjB,KAAK,KAAK,CACd,EAAG,GAAG,EACN,KAAK,OAAO,GAAG,QAAS,IAAM,CAC1B,KAAK,MAAM,QAAQ,EACnB,KAAK,QAAQ,CACjB,CAAC,EACD,KAAK,KAAK,CACd,MAIc,QAAQ,CAClB,GAAM,GAAO,KAAM,GAAkB,KAAK,SAAS,EAC7C,EAAc,EAAkB,EAAK,MAAM,EACjD,KAAK,IAAM,EAAY,KAAK,SAAS,GACzC,CAMQ,SAAU,CACd,KAAK,SAAS,QAAQ,EACtB,KAAK,QAAU,KACf,KAAK,IAAM,EACf,MAMc,OAAO,CACjB,GAAI,KAAK,OAAO,UAAW,CACvB,KAAK,MAAM,QAAQ,EACnB,KAAK,QAAQ,EACb,MACJ,CACA,GAAM,GAAc,KAAK,YAAc,KAAK,cAAgB,IACtD,EAAS,KAAM,GAAe,KAAK,IAAK,CAC1C,QAAS,CACL,MAAO,SAAS,KAAK,eAAe,GAAO,KAAK,eAAiB,GAAK,GAC1E,CACJ,CAAC,EAAE,MAAM,AAAC,GAAe,CAAG,EAC5B,GAAI,YAAkB,OAAO,CACzB,KAAK,OAAO,KAAK,QAAS,CAAM,EAChC,KAAK,YAAc,EACnB,KAAK,cAAgB,EACrB,KAAK,QAAQ,EACb,MACJ,CACA,GAAI,OAAO,EAAO,UAAU,GAAK,IAAK,CAClC,KAAK,QAAQ,EACb,KAAM,MAAK,MAAM,EACjB,KAAK,MAAM,MAAM,EACjB,KAAK,KAAK,EACV,MACJ,CACA,KAAK,QAAU,EACf,EAAO,GAAG,OAAQ,AAAC,GAAM,CACrB,KAAK,OAAO,KAAK,CAAC,CACtB,CAAC,EAED,EAAO,KAAK,QAAS,SAAY,CAC7B,KAAK,QAAQ,EACb,KAAM,MAAK,MAAM,EACjB,KAAK,MAAM,MAAM,EACjB,KAAK,KAAK,CACd,CAAC,EAED,EAAO,GAAG,OAAQ,AAAC,GAAe,CAC9B,KAAK,aAAe,EAAM,MAC9B,CAAC,EAED,EAAO,GAAG,MAAO,IAAM,CACnB,AAAI,GAAO,KAAK,gBACZ,MAAK,MAAM,QAAQ,EACnB,KAAK,OAAO,KAAK,IAAI,EACrB,KAAK,QAAQ,EAErB,CAAC,CACL,CAOA,OAAQ,CACJ,KAAK,MAAM,MAAM,CACrB,CAKA,QAAS,CACL,KAAK,MAAM,OAAO,CACtB,CACJ,EAzKO,eA+KA,WAAY,CAkCf,YAAY,EAAsB,EAAc,CAC5C,KAAK,SAAW,EAChB,KAAK,WAAa,EAClB,KAAK,UAAY,EACjB,KAAK,OAAS,GACd,KAAK,UAAY,GACjB,KAAK,WAAa,QAAQ,OAAO,EAAE,GACnC,KAAK,MAAQ,WAAW,KAAK,SAAU,KAAK,WAAa,GAAI,CACjE,CAKA,OAAQ,CACJ,MAAI,CAAC,KAAK,QAAU,CAAC,KAAK,UACtB,MAAK,OAAS,GACd,aAAa,KAAK,KAAK,EACvB,KAAK,UAAY,KAAK,UAAa,SAAQ,OAAO,EAAE,GAAK,KAAK,YACvD,IACG,EAClB,CAKA,QAAS,CACL,MAAI,MAAK,QAAU,CAAC,KAAK,UACrB,MAAK,OAAS,GACd,KAAK,WAAa,QAAQ,OAAO,EAAE,GACnC,KAAK,MAAQ,WAAW,KAAK,SAAU,KAAK,UAAY,GAAI,EACrD,IACG,EAClB,CAKA,OAAQ,CACJ,MAAK,MAAK,UAOI,GANV,cAAa,KAAK,KAAK,EACvB,KAAK,UAAY,KAAK,WACtB,KAAK,OAAS,GACd,KAAK,WAAa,QAAQ,OAAO,EAAE,GACnC,KAAK,MAAQ,WAAW,KAAK,SAAU,KAAK,WAAa,GAAI,EACtD,GAEf,CAMA,SAAU,CACN,aAAa,KAAK,KAAK,EACvB,KAAK,UAAY,GACjB,KAAK,SAAW,IAAM,CAAC,EACvB,KAAK,WAAa,EAClB,KAAK,UAAY,EACjB,KAAK,OAAS,GACd,KAAK,WAAa,CACtB,CACJ,EA/FO,aO3XP,4DACA,sCAmBA,GAAM,IAAmB,OAAO,KAAK,EAAY,EAE1C,gBAAyB,GAAO,CAenC,YAAY,EAAa,EAA4B,CACjD,MAAM,CAAO,EACb,KAAK,MAAQ,eACb,KAAK,OAAS,EACd,KAAK,OAAS,GAAI,IAClB,KAAK,UAAY,GACjB,KAAK,aAAe,GACpB,KAAK,UAAY,GACjB,KAAK,YAAc,EACnB,KAAK,UAAY,EACjB,KAAK,OAAS,EACd,KAAK,IAAM,EACX,KAAK,KAAO,KAAK,MAAM,EAAM,EAAE,EAAI,EACvC,IAEY,cAAsB,CAC9B,GAAI,GAAI,EACR,KAAO,EAAI,GACF,KAAM,EAAI,EAAM,KAAK,MAAO,KAAK,SAD5B,IACV,CAEJ,MAAO,EAAE,CACb,CAEQ,YAAsB,CAC1B,GAAI,CAAC,KAAK,MAAO,MAAO,GACxB,GAAM,GAAS,KAAK,YACpB,GAAI,KAAK,MAAM,OAAS,KAAK,OAAS,EAAQ,MAAO,GACrD,GAAI,GAAQ,KAAK,MAAM,KAAK,QAAY,IAAM,EAAI,GAAW,EAC7D,OAAS,GAAI,KAAK,OAAS,EAAG,EAAI,KAAK,OAAS,EAAQ,IAAK,EAAS,IAAS,GAAK,KAAK,MAAM,GAC/F,YAAK,UAAY,EACjB,KAAK,YAAc,EACZ,EACX,CAEA,SAAU,CACN,KAAK,OAAS,EACd,KAAK,MAAQ,OACb,KAAK,UAAY,MACrB,CAEA,OAAQ,CAAC,CAET,KAAK,EAAwC,CACzC,GAAI,GAAgB,EAChB,EAAW,EACX,EAAa,MAAK,IAAM,KAAK,MAAQ,KAAQ,EAEjD,GADA,EAAY,KAAK,MAAM,EAAY,EAAE,EAAI,GACrC,CAAC,KAAK,OAAO,QAAQ,KAAM,MAAO,IAAI,OAAM,sBAAsB,EAEtE,OAAS,GAAI,EAAG,EAAI,KAAK,OAAO,QAAQ,KAAK,OAAQ,IAAK,CACtD,GAAM,GAAO,KAAK,OAAO,QAAQ,KAAK,GACtC,GAAI,KAAK,MAAO,EAAK,KAAkB,GAAI,IAAM,KAAK,KAAM,CACxD,EAAW,EAAK,SAChB,EAAiB,MAAK,OAAO,QAAQ,KAAK,EAAI,IAAI,UAAY,GAAkB,EAAW,EAC3F,KACJ,KAAO,SACX,CACA,MAAI,KAAkB,EAAU,EACzB,KAAK,OAAS,KAAK,MAAM,EAAY,EAAY,GAAO,GAAgB,IAAI,CACvF,CAEA,OAAO,EAAe,EAAmB,EAAgD,CACrF,AAAI,KAAK,UACL,MAAK,MAAQ,OAAO,OAAO,CAAC,KAAK,UAAW,CAAK,CAAC,EAClD,KAAK,UAAY,QACd,KAAK,MAAQ,EAEpB,GAAI,GAEJ,AAAI,KAAK,QAAU,eAA8B,EAAM,KAAK,SAAS,EAChE,AAAK,KAAK,UACV,EAAM,KAAK,QAAQ,EADE,EAAM,KAAK,gBAAgB,EAGrD,AAAI,EAAK,EAAS,CAAG,EAChB,EAAS,CAClB,CAEQ,UAA8B,CAClC,GAAI,CAAC,KAAK,MAAO,MAAO,IAAI,OAAM,kBAAkB,EAEpD,KAAO,KAAK,MAAM,OAAS,KAAK,QAAQ,CACpC,GAAM,GAAY,KAAK,OACjB,EAAK,KAAK,YAChB,GAAI,KAAK,MAAM,OAAS,KAAK,OAAS,EAAI,MAE1C,GAAM,GAAS,KAAK,YAAY,KAAK,MAAM,MAAM,KAAK,OAAQ,KAAK,OAAS,CAAE,EAAE,SAAS,KAAK,CAAC,EAG/F,GAFA,KAAK,QAAU,EAEX,CAAC,KAAK,WAAW,EAAG,CACpB,KAAK,OAAS,EACd,KACJ,CACA,GAAI,CAAC,EAAQ,CACT,KAAK,QAAU,KAAK,UAAY,KAAK,YACrC,QACJ,CAEA,GAAI,CAAC,KAAK,UACN,GAAI,EAAO,OAAS,OAAQ,KAAK,UAAY,OACxC,OAAO,IAAI,OAAM,4CAA4C,EAEtE,GAAM,GAAO,KAAK,MAAM,MACpB,KAAK,OAAS,KAAK,UACnB,KAAK,OAAS,KAAK,UAAY,KAAK,WACxC,EACM,EAAQ,KAAK,OAAO,MAAM,EAAQ,CAAI,EAC5C,GAAI,YAAiB,OAAO,MAAO,GAanC,GATI,EAAO,OAAS,YAAY,MAAK,OAAS,GAG1C,EAAO,OAAS,sBAChB,KAAK,OAAO,QAAQ,KAAM,OAAS,GACnC,KAAK,OAAU,KAAK,OAAO,QAAQ,KAAM,GAAG,EAAE,EAAG,KAAkB,KAEnE,KAAK,KAAK,cAAc,EAExB,EAAO,OAAS,EAAiB,CACjC,KAAK,QAAU,KAAK,UACpB,QACJ,CAEA,GAAI,KAAK,MAAM,OAAS,KAAK,OAAS,KAAK,UAAY,KAAK,YAAa,CACrE,KAAK,OAAS,EACd,KACJ,KAAO,MAAK,QAAU,KAAK,UAAY,KAAK,WAChD,CACA,KAAK,UAAY,KAAK,MAAM,MAAM,KAAK,MAAM,EAC7C,KAAK,OAAS,CAClB,CAEQ,SAA6B,CACjC,GAAI,CAAC,KAAK,MAAO,MAAO,IAAI,OAAM,kBAAkB,EAEpD,KAAO,KAAK,MAAM,OAAS,KAAK,QAAQ,CACpC,GAAM,GAAY,KAAK,OACjB,EAAK,KAAK,YAChB,GAAI,KAAK,MAAM,OAAS,KAAK,OAAS,EAAI,MAE1C,GAAM,GAAS,KAAK,YAAY,KAAK,MAAM,MAAM,KAAK,OAAQ,KAAK,OAAS,CAAE,EAAE,SAAS,KAAK,CAAC,EAG/F,GAFA,KAAK,QAAU,EAEX,CAAC,KAAK,WAAW,EAAG,CACpB,KAAK,OAAS,EACd,KACJ,CACA,GAAI,CAAC,EAAQ,CACT,KAAK,QAAU,KAAK,UAAY,KAAK,YACrC,QACJ,CAEA,GAAM,GAAO,KAAK,MAAM,MACpB,KAAK,OAAS,KAAK,UACnB,KAAK,OAAS,KAAK,UAAY,KAAK,WACxC,EACM,EAAQ,KAAK,OAAO,MAAM,EAAQ,CAAI,EAC5C,GAAI,YAAiB,OAAO,MAAO,GAEnC,GAAI,EAAO,OAAS,EAAiB,CACjC,KAAK,QAAU,KAAK,UACpB,QACJ,CAEA,GAAI,KAAK,MAAM,OAAS,KAAK,OAAS,KAAK,UAAY,KAAK,YAAa,CACrE,KAAK,OAAS,EACd,KACJ,KAAO,MAAK,QAAU,KAAK,UAAY,KAAK,YAE5C,GAAI,EAAO,OAAS,cAAe,CAC/B,GAAM,GAAQ,KAAK,OAAO,QAAQ,OAAQ,KAAK,OAAO,YACtD,GAAI,CAAC,GAAS,EAAM,YAAc,EAAG,MAAO,IAAI,OAAM,mCAAmC,EACzF,AAAK,GAAK,GAAK,MAAS,EAAM,aAAa,KAAK,KAAK,EAAK,MAAM,CAAC,CAAC,CACtE,CACJ,CACA,KAAK,UAAY,KAAK,MAAM,MAAM,KAAK,MAAM,EAC7C,KAAK,OAAS,CAClB,CAEQ,iBAAqC,CACzC,GAAI,KAAK,MAAQ,EACb,YAAK,UAAY,GACV,KAAK,QAAQ,EAExB,GAAI,CAAC,KAAK,MAAO,MAAO,IAAI,OAAM,kBAAkB,EACpD,KAAK,OAAS,EACd,GAAI,GAAgB,GACpB,KAAO,CAAC,GAAiB,KAAK,OAAS,KAAK,MAAM,QAAQ,CAEtD,GADA,KAAK,OAAS,KAAK,MAAM,QAAQ,KAAM,KAAK,OAAQ,KAAK,EACrD,KAAK,SAAW,GAAI,MAAO,IAAI,OAAM,+BAA+B,EAExE,GADA,KAAK,SACD,CAAC,KAAK,WAAW,EAAG,MAAO,IAAI,OAAM,mDAAmD,EAC5F,GAAI,KAAK,OAAS,KAAK,YAAc,KAAK,YAAc,KAAK,MAAM,OAAQ,SAC3E,GAAM,GAAO,KAAK,MAAM,MACpB,KAAK,OAAS,KAAK,UACnB,KAAK,OAAS,KAAK,UAAY,KAAK,WACxC,EACM,EAAQ,KAAK,OAAO,QAAQ,OAAQ,KAAK,OAAO,YACtD,GAAI,CAAC,GAAS,EAAM,YAAc,EAAG,MAAO,IAAI,OAAM,mCAAmC,EACzF,GAAK,GAAK,GAAK,MAAS,EAAM,YAC1B,KAAK,QAAU,KAAK,UAAY,KAAK,YACrC,KAAK,KAAK,EAAK,MAAM,CAAC,CAAC,EACvB,EAAgB,OACb,SACX,CACA,MAAK,GACL,MAAK,UAAY,GACV,KAAK,QAAQ,GAFO,GAAI,OAAM,8CAA8C,CAGvF,CAEQ,YAAY,EAAgB,CAChC,MAAI,IAAiB,SAAS,CAAM,EAAU,GAAa,GAC/C,EAChB,CAEA,SAAS,EAAqB,EAA+C,CACzE,KAAK,QAAQ,EACb,EAAS,CAAK,CAClB,CAEA,OAAO,EAAgD,CACnD,KAAK,QAAQ,EACb,EAAS,CACb,CACJ,EAhPO,mBCZA,YAAiB,CA2DpB,YACI,EACA,EACA,EACA,EACA,EACA,EACA,EACF,CACE,KAAK,OAAS,GAAI,IAAW,EAAQ,KAAO,CACxC,cAAe,EAAI,IAAO,IAC1B,mBAAoB,EACxB,CAAC,EACD,KAAK,IAAM,EACX,KAAK,QAAU,EAAQ,QACvB,KAAK,KAAO,OACZ,KAAK,YAAc,EACnB,KAAK,UAAY,EACjB,KAAK,cAAgB,AAAU,KAAK,KAAf,EAAoB,EAAU,EAAe,EAAgB,CAA9B,EACpD,KAAK,cAAgB,EACrB,KAAK,eAAiB,EACtB,KAAK,QAAU,KACf,KAAK,MAAQ,GAAI,GAAM,IAAM,CACzB,KAAK,MAAM,MAAM,EACjB,KAAK,KAAK,CACd,EAAG,GAAG,EACN,KAAK,OAAO,GAAG,QAAS,IAAM,CAC1B,KAAK,MAAM,QAAQ,EACnB,KAAK,QAAQ,CACjB,CAAC,EACD,KAAK,KAAK,CACd,MAOc,OAAsB,CAChC,GAAM,GAAQ,KAAM,IAAI,SAAQ,MAAO,EAAK,IAAQ,CAChD,GAAK,KAAK,OAAO,aA8BV,EAAI,EAAE,MA9BkB,CAC3B,GAAM,GAAS,KAAM,GAAe,KAAK,IAAK,CAC1C,QAAS,CACL,MAAO,WAAW,KAAK,eAC3B,CACJ,CAAC,EAAE,MAAM,AAAC,GAAe,CAAG,EAE5B,GAAI,YAAkB,OAAO,CACzB,EAAI,CAAM,EACV,MACJ,CACA,GAAI,OAAO,EAAO,UAAU,GAAK,IAAK,CAClC,EAAI,GAAG,EACP,MACJ,CACA,KAAK,QAAU,EACf,EAAO,KAAK,KAAK,OAAQ,CAAE,IAAK,EAAM,CAAC,EAGvC,EAAO,KAAK,MAAO,IAAM,CACrB,KAAK,OAAO,MAAQ,eACpB,EAAI,EAAE,CACV,CAAC,EAED,KAAK,OAAO,KAAK,eAAgB,IAAM,CACnC,EAAO,OAAO,KAAK,MAAM,EACzB,EAAO,QAAQ,EACf,KAAK,OAAO,MAAQ,eACpB,EAAI,EAAE,CACV,CAAC,CACL,CACJ,CAAC,EAAE,MAAM,AAAC,GAAQ,CAAG,EACrB,GAAI,YAAiB,OAAO,CACxB,KAAK,OAAO,KAAK,QAAS,CAAK,EAC/B,KAAK,YAAc,EACnB,KAAK,cAAgB,EACrB,KAAK,QAAQ,EACb,MACJ,SAAW,IAAU,IACjB,YAAM,MAAK,MAAM,EACjB,KAAK,MAAM,MAAM,EACV,KAAK,KAAK,EAErB,GAAM,GAAQ,KAAK,OAAO,KAAK,KAAK,cAAc,EAClD,GAAI,YAAiB,OAAO,CACxB,KAAK,OAAO,KAAK,QAAS,CAAK,EAC/B,KAAK,YAAc,EACnB,KAAK,cAAgB,EACrB,KAAK,QAAQ,EACb,MACJ,CAEA,KAAK,OAAO,UAAY,GACxB,KAAK,YAAc,EACnB,KAAK,MAAM,MAAM,EACjB,KAAK,KAAK,CACd,MAIc,QAAQ,CAClB,GAAM,GAAO,KAAM,GAAkB,KAAK,SAAS,EAC7C,EAAc,EAAkB,EAAK,MAAM,EACjD,KAAK,IAAM,EAAY,KAAK,SAAS,GACzC,CAMQ,SAAU,CACd,KAAK,SAAS,QAAQ,EACtB,KAAK,QAAU,KACf,KAAK,IAAM,EACf,MAMc,OAAO,CACjB,GAAI,KAAK,OAAO,UAAW,CACvB,KAAK,MAAM,QAAQ,EACnB,KAAK,QAAQ,EACb,MACJ,CACA,GAAM,GAAc,KAAK,YAAc,KAAK,cAAgB,IACtD,EAAS,KAAM,GAAe,KAAK,IAAK,CAC1C,QAAS,CACL,MAAO,SAAS,KAAK,eAAe,GAAO,KAAK,eAAiB,GAAK,GAC1E,CACJ,CAAC,EAAE,MAAM,AAAC,GAAe,CAAG,EAC5B,GAAI,YAAkB,OAAO,CACzB,KAAK,OAAO,KAAK,QAAS,CAAM,EAChC,KAAK,YAAc,EACnB,KAAK,cAAgB,EACrB,KAAK,QAAQ,EACb,MACJ,CACA,GAAI,OAAO,EAAO,UAAU,GAAK,IAAK,CAClC,KAAK,QAAQ,EACb,KAAM,MAAK,MAAM,EACjB,KAAK,MAAM,MAAM,EACjB,KAAK,KAAK,EACV,MACJ,CACA,KAAK,QAAU,EACf,EAAO,KAAK,KAAK,OAAQ,CAAE,IAAK,EAAM,CAAC,EAEvC,EAAO,KAAK,QAAS,SAAY,CAC7B,KAAK,QAAQ,EACb,KAAM,MAAK,MAAM,EACjB,KAAK,MAAM,MAAM,EACjB,KAAK,KAAK,CACd,CAAC,EAED,EAAO,GAAG,OAAQ,AAAC,GAAe,CAC9B,KAAK,aAAe,EAAM,MAC9B,CAAC,EAED,EAAO,GAAG,MAAO,IAAM,CACnB,AAAI,GAAO,KAAK,gBACZ,MAAK,MAAM,QAAQ,EACnB,KAAK,OAAO,IAAI,EAChB,KAAK,QAAQ,EAErB,CAAC,CACL,CAOA,OAAQ,CACJ,KAAK,MAAM,MAAM,CACrB,CAKA,QAAS,CACL,KAAK,MAAM,OAAO,CACtB,CACJ,EAnPO,mBCLP,gCAwBO,WAA2B,EAAgB,CAC9C,GAAM,GAAgB,CAAC,EACvB,SAAQ,QAAQ,AAAC,GAAW,CACxB,GAAM,GAAO,EAAO,SACpB,AAAI,EAAK,WAAW,OAAO,GACvB,GAAO,MAAQ,EAAK,MAAM,UAAU,EAAE,GAAG,MAAM,GAAG,EAAE,GACpD,EAAO,UAAY,EAAK,MAAM,QAAQ,EAAE,GAAG,MAAM,GAAG,EAAE,GACtD,EAAO,KAAK,CAAM,EAE1B,CAAC,EACM,CACX,CAXgB,yBAsBhB,kBAA6B,EAAa,EAAyB,CAAC,EAA2B,CAC3F,GAAM,GAAO,KAAM,GAAkB,EAAK,CAAE,SAAU,EAAQ,SAAU,SAAU,EAAQ,QAAS,CAAC,EACpG,MAAO,MAAM,IAAiB,EAAM,CAAO,CAC/C,CAHsB,eAUtB,kBACI,EACA,EAAyB,CAAC,EACJ,CACtB,GAAI,EAAK,OAAO,SAAW,EACvB,KAAM,IAAI,OAAM,8EAA8E,EAClG,GAAI,EAAQ,SAAW,CAAC,OAAO,UAAU,EAAQ,OAAO,EACpD,KAAM,IAAI,OAAM,oCAAoC,EAExD,GAAM,GAAe,CAAC,EACtB,GACI,EAAK,eAAe,SAAW,IAC/B,EAAK,eAAe,kBAAoB,MACxC,EAAK,cAAc,gBAAkB,EAErC,MAAO,IAAI,IACP,EAAK,eAAe,gBACpB,EAAK,OAAO,EAAK,OAAO,OAAS,GAAG,kBACpC,EAAK,cAAc,IACnB,EAAQ,QACZ,EAGJ,GAAM,GAAc,EAAkB,EAAK,MAAM,EACjD,AAAI,MAAO,GAAQ,SAAY,SAAU,EAAQ,QAAU,EAAY,OAAS,EAC3E,AAAI,EAAQ,SAAW,EAAG,EAAQ,QAAU,EACxC,EAAQ,SAAW,EAAY,QAAQ,GAAQ,QAAU,EAAY,OAAS,GACvF,AAAI,EAAY,SAAW,EAAG,EAAM,KAAK,EAAY,EAAQ,QAAQ,EAChE,EAAM,KAAK,EAAK,OAAO,EAAK,OAAO,OAAS,EAAE,EACnD,GAAI,GACA,EAAM,GAAG,QAAU,QAAU,EAAM,GAAG,YAAc,OAAS,YAAsB,YAEvF,GADA,KAAM,GAAe,WAAW,GAAI,IAAI,EAAM,GAAG,GAAG,EAAE,mBAAmB,EACrE,IAAS,YACT,GAAK,EAAQ,4BAaN,GAAI,EAAQ,KAAM,KAAM,IAAI,OAAM,2DAA2D,MAb3D,CAErC,GADA,EAAQ,OAAS,EACb,EAAQ,MAAQ,EAAK,cAAc,eAAiB,EAAQ,KAAO,EACnE,KAAM,IAAI,OAAM,+BAA+B,EAAK,cAAc,cAAgB,IAAI,EAC1F,MAAO,IAAI,IACP,EAAM,GAAG,IACT,EAAK,cAAc,cACnB,EAAM,GAAG,WAAW,IACpB,OAAO,EAAM,GAAG,aAAa,EAC7B,OAAO,EAAM,GAAG,OAAO,EACvB,EAAK,cAAc,IACnB,CACJ,CACJ,CAGJ,GAAI,GACJ,MAAI,GAAM,GAAG,cACT,EAAgB,OAAO,EAAM,GAAG,aAAa,EAE7C,EAAgB,KAAM,IAAuB,EAAM,GAAG,GAAG,EAGtD,GAAI,IACP,EAAM,GAAG,IACT,EACA,EAAK,cAAc,cACnB,EACA,EAAK,cAAc,IACnB,CACJ,CACJ,CAhEsB,yBCvDtB,GAAM,IAAqB,CACvB,mEACA,2DACA,2DACA,2DACA,mDACA,kDACJ,EAoBO,YAA2B,EAAc,EAA2C,CACvF,GAAI,CAAC,EAAM,KAAM,IAAI,OAAM,wCAAwC,EACnE,AAAK,EACK,EAAQ,MAAM,GAAQ,KAAO,SADzB,EAAU,CAAE,KAAM,QAAS,MAAO,CAAE,EAElD,GAAM,GAAW,MAAO,GAAQ,OAAU,UAAY,EAAQ,MAAQ,EACtE,EAAQ,uBAAyB,GAEjC,GAAM,GAAO,EACR,MAAM,sBAAsB,IAAI,IAC/B,MAAM,aAAY,EAAE,GACrB,MAAM,uBAAuB,EAAE,GAC9B,EAAY,KAAK,MAAM,CAAI,EAC3B,EAAU,CAAC,EACX,EACF,EAAU,SAAS,+BAA+B,gBAAgB,oBAAoB,SAAS,QAC3F,AAAC,GAAW,EAAE,qBAAqB,QACvC,EACJ,OAAW,KAAU,GAAS,CAC1B,GAAI,GAAY,EAAQ,SAAW,EAAQ,MAAO,MAClD,GAAI,GAAC,GAAW,CAAC,EAAO,eAAiB,CAAC,EAAO,iBAAmB,CAAC,EAAO,kBAC5E,OAAQ,EAAQ,UACP,QAAS,CACV,GAAM,GAAS,GAAW,CAAM,EAChC,AAAI,GACI,GAAQ,sBAAsB,EAAO,WAAW,QAAQ,EAAe,EAC3E,EAAQ,KAAK,CAAM,GAEvB,KACJ,KACK,UAAW,CACZ,GAAM,GAAS,GAAa,CAAM,EAClC,AAAI,GAAQ,EAAQ,KAAK,CAAM,EAC/B,KACJ,KACK,WAAY,CACb,GAAM,GAAS,GAAc,CAAM,EACnC,AAAI,GACI,GAAQ,sBAAwB,EAAO,WAAW,GAAgB,EAAO,SAAS,EACtF,EAAQ,KAAK,CAAM,GAEvB,KACJ,SAEI,KAAM,IAAI,OAAM,wBAAwB,EAAQ,MAAM,EAElE,CACA,MAAO,EACX,CA/CgB,0BAqDhB,YAAuB,EAA0B,CAC7C,GAAI,CAAC,EAAU,MAAO,GACtB,GAAM,GAAO,EAAS,MAAM,GAAG,EAC3B,EAAM,EAEV,OAAQ,EAAK,YACJ,GACD,EAAM,SAAS,EAAK,EAAE,EAAI,GAAK,GAAK,SAAS,EAAK,EAAE,EAAI,GAAK,SAAS,EAAK,EAAE,EAC7E,UACC,GACD,EAAM,SAAS,EAAK,EAAE,EAAI,GAAK,SAAS,EAAK,EAAE,EAC/C,cAEA,EAAM,SAAS,EAAK,EAAE,EAG9B,MAAO,EACX,CAjBS,sBAuBF,YAAsB,EAA4B,CACrD,GAAI,CAAC,GAAQ,CAAC,EAAK,gBAAiB,KAAM,IAAI,OAAM,iCAAiC,EACrF,GAAM,GAAQ,EAAK,gBAAgB,cAAc,IAAI,uBAAuB,OAAO,YAAY,EACzF,EAAM,0BACR,EAAK,gBAAgB,mBAAmB,eAAe,kBACvD,EAAK,gBAAgB,mBAAmB,gBAAgB,mBAAmB,MAEzE,EAAY,EAAK,gBAAgB,UAAU,WAAW,EAAK,gBAAgB,UAAU,WAAW,OAAS,GAe/G,MAdY,IAAI,GAAe,CAC3B,GAAI,EAAK,gBAAgB,UACzB,KAAM,EAAK,gBAAgB,MAAM,WACjC,KAAM,CACF,IAAK,EAAU,IAAI,QAAQ,KAAM,UAAU,EAC3C,MAAO,EAAU,MACjB,OAAQ,EAAU,MACtB,EACA,IAAK,EACL,SAAU,QAAQ,GAAO,SAAS,UAAU,CAAC,EAC7C,OAAQ,QAAQ,GAAO,SAAS,QAAQ,CAAC,EACzC,YAAa,EAAK,gBAAgB,qBAAqB,YAAc,eACzE,CAAC,CAGL,CAvBgB,qBA6BT,YAAoB,EAA0B,CACjD,GAAI,CAAC,GAAQ,CAAC,EAAK,cAAe,KAAM,IAAI,OAAM,+BAA+B,EAEjF,GAAM,GAAU,EAAK,cAAc,UAAU,KAAK,GAC5C,EAAQ,EAAK,cAAc,cAAc,IAAI,uBAAuB,OAAO,YAAY,EACvF,EAAe,EAAK,cAAc,WA+BxC,MA9BY,IAAI,GAAa,CACzB,GAAI,EAAK,cAAc,QACvB,IAAK,mCAAmC,EAAK,cAAc,UAC3D,MAAO,EAAK,cAAc,MAAM,KAAK,GAAG,KACxC,YAAa,EAAK,cAAc,2BAA2B,GAAG,YAAY,MAAM,OAC1E,EAAK,cAAc,yBAAyB,GAAG,YAAY,KAAK,IAAI,AAAC,GAAa,EAAI,IAAI,EAAE,KAAK,EAAE,EACnG,GACN,SAAU,EAAe,GAAc,EAAa,UAAU,EAAI,EAClE,aAAc,EAAe,EAAa,WAAa,KACvD,WAAY,EAAK,cAAc,UAAU,WACzC,QAAS,CACL,GAAI,EAAQ,mBAAmB,eAAe,UAAY,KAC1D,KAAM,EAAQ,MAAQ,KACtB,IAAK,0BACD,EAAQ,mBAAmB,eAAe,kBAC1C,EAAQ,mBAAmB,gBAAgB,mBAAmB,MAElE,MAAO,EAAK,cAAc,mCAAmC,iCAAiC,UACzF,WACL,SAAU,QAAQ,GAAO,SAAS,UAAU,CAAC,EAC7C,OAAQ,QAAQ,GAAO,SAAS,QAAQ,CAAC,CAC7C,EACA,WAAY,EAAK,cAAc,mBAAmB,YAAc,KAChE,SAAU,EAAK,cAAc,mBAAmB,UAC1C,GAAI,MAAK,SAAS,EAAK,cAAc,kBAAkB,SAAS,EAAI,GAAI,EACxE,OACN,MAAO,EAAK,cAAc,eAAe,YAAY,QAAQ,MAAO,EAAE,GAAK,EAC3E,KAAM,EACV,CAAC,CAGL,CArCgB,mBA2CT,YAAuB,EAA6B,CACvD,GAAI,CAAC,GAAQ,CAAC,EAAK,iBAAkB,KAAM,IAAI,OAAM,kCAAkC,EAEvF,GAAM,GACF,EAAK,iBAAiB,WAAW,GAAG,WAAW,EAAK,iBAAiB,WAAW,GAAG,WAAW,OAAS,GACrG,EAAU,EAAK,iBAAiB,gBAAgB,OAAO,GAsB7D,MApBY,IAAI,GACZ,CACI,GAAI,EAAK,iBAAiB,WAC1B,MAAO,EAAK,iBAAiB,MAAM,WACnC,UAAW,CACP,GAAI,EAAK,iBAAiB,WAC1B,IAAK,EAAU,IACf,OAAQ,EAAU,OAClB,MAAO,EAAU,KACrB,EACA,QAAS,CACL,GAAI,GAAS,mBAAmB,eAAe,SAC/C,KAAM,GAAS,KACf,IAAK,0BAA0B,GAAS,mBAAmB,gBAAgB,mBAAmB,KAClG,EACA,OAAQ,SAAS,EAAK,iBAAiB,WAAW,QAAQ,MAAO,EAAE,CAAC,CACxE,EACA,EACJ,CAGJ,CA5BgB,sBA8BhB,YAAyB,EAA6B,CAClD,GAAI,GAAmB,KAAK,AAAC,GAAQ,EAAU,IAAI,SAAS,CAAG,CAAC,EAI5D,OAHA,EAAU,IAAM,EAAU,IAAI,MAAM,GAAG,EAAE,GAGjC,EAAU,IAAI,MAAM,GAAG,EAAE,GAAG,EAAE,EAAG,MAAM,GAAG,EAAE,QAC3C,UACA,YACD,EAAU,MAAQ,IAClB,EAAU,OAAS,IACnB,UACC,QACD,EAAU,MAAQ,KAClB,EAAU,OAAS,IACnB,UACC,YACD,EAAU,MAAQ,IAClB,EAAU,OAAS,IACnB,UACC,YACD,EAAU,MAAQ,IAClB,EAAU,OAAS,IACnB,UACC,UACD,EAAU,MAAQ,IAClB,EAAU,OAAS,GACnB,cAEA,EAAU,MAAQ,EAAU,OAAS,IAGrD,CA/BS,wBC7LT,kBAAgC,EAAgB,EAAgC,CAAC,EAAuB,CACpG,GAAI,GAAM,gDAAkD,EAE5D,GADA,EAAQ,OAAS,QACb,EAAI,QAAQ,MAAM,IAAM,GAExB,OADA,GAAO,OACC,EAAQ,UACP,UACD,GAAO,mBACP,UACC,WACD,GAAO,mBACP,UACC,QACD,GAAO,mBACP,cAEA,KAAM,IAAI,OAAM,wBAAwB,EAAQ,MAAM,EAGlE,GAAM,GAAO,KAAM,GAAQ,EAAK,CAC5B,QAAS,CACL,kBAAmB,EAAQ,UAAY,aAC3C,CACJ,CAAC,EACD,GAAI,EAAK,QAAQ,uEAAuE,IAAM,GAC1F,KAAM,IAAI,OAAM,wDAAwD,EAC5E,MAAO,IAAkB,EAAM,CAAO,CAC1C,CA3BsB,kBCoDf,WAAmB,CAqDtB,YAAY,EAAW,CACnB,KAAK,KAAO,EAAK,KACjB,KAAK,GAAK,EAAK,GACf,KAAK,KAAO,EAAK,cAAc,MAAQ,GACvC,KAAK,KAAO,QACZ,KAAK,IAAM,EAAK,cAAc,QAC9B,KAAK,SAAW,EAAK,SACrB,KAAK,SAAW,EAAK,YACrB,KAAK,aAAe,EAAK,YACzB,KAAK,cAAgB,KAAK,MAAM,KAAK,aAAe,GAAI,EACxD,GAAM,GAA4B,CAAC,EACnC,EAAK,QAAQ,QAAQ,AAAC,GAAW,CAC7B,EAAQ,KAAK,CACT,KAAM,EAAE,KACR,GAAI,EAAE,GACN,IAAK,EAAE,cAAc,OACzB,CAAC,CACL,CAAC,EACD,KAAK,QAAU,EACf,AAAK,EAAK,OAAO,KAEb,KAAK,MAAQ,CACT,KAAM,EAAK,MAAM,KACjB,IAAK,EAAK,cAAc,QACxB,GAAI,EAAK,MAAM,GACf,aAAc,EAAK,MAAM,aACzB,uBAAwB,EAAK,MAAM,uBACnC,aAAc,EAAK,MAAM,YAC7B,EATmB,KAAK,MAAQ,OAWpC,AAAK,EAAK,OAAO,SAAS,GACrB,KAAK,UAAY,EAAK,MAAM,OAAO,GADV,KAAK,UAAY,MAEnD,CAEA,QAAoB,CAChB,MAAO,CACH,KAAM,KAAK,KACX,GAAI,KAAK,GACT,IAAK,KAAK,IACV,SAAU,KAAK,SACf,aAAc,KAAK,aACnB,cAAe,KAAK,cACpB,QAAS,KAAK,QACd,MAAO,KAAK,MACZ,UAAW,KAAK,SACpB,CACJ,CACJ,EApGO,oBAwGA,WAAsB,CA0DzB,YAAY,EAAW,EAAiC,EAAiB,CACrE,KAAK,KAAO,EAAK,KACjB,KAAK,KAAO,WACZ,KAAK,OAAS,EACd,KAAK,cAAgB,EAAK,cAC1B,KAAK,YAAc,EAAK,YACxB,KAAK,IAAM,EAAK,cAAc,QAC9B,KAAK,GAAK,EAAK,GACf,KAAK,UAAY,EAAK,OAAO,GAC7B,KAAK,MAAQ,CACT,KAAM,EAAK,MAAM,aACjB,IAAK,EAAK,MAAM,cAAc,QAC9B,GAAI,EAAK,MAAM,EACnB,EACA,KAAK,YAAc,OAAO,EAAK,OAAO,KAAK,EAC3C,GAAM,GAAyB,CAAC,EAChC,AAAK,KAAK,QACN,EAAK,OAAO,MAAM,QAAQ,AAAC,GAAW,CAClC,AAAI,EAAE,OAAO,EAAO,KAAK,GAAI,GAAa,EAAE,KAAK,CAAC,CACtD,CAAC,EACL,KAAK,eAAiB,GAAI,KAC1B,KAAK,eAAe,IAAI,IAAK,CAAM,EACnC,KAAK,YAAc,CACvB,MAOM,QAAQ,CACV,GAAI,KAAK,OAAQ,MAAO,MACxB,GAAI,GAGJ,GAFA,AAAI,KAAK,YAAc,IAAM,EAAW,IACnC,EAAW,KAAK,YACjB,GAAY,IAAK,MAAO,MAC5B,GAAM,GAAO,CAAC,EACd,OAAS,GAAI,EAAG,GAAK,KAAK,KAAK,EAAW,GAAG,EAAG,IAC5C,EAAK,KACD,GAAI,SAAQ,MAAO,EAAS,IAAW,CACnC,GAAM,GAAW,KAAM,GACnB,wCAAwC,KAAK,oBACxC,GAAI,GAAK,wBACO,KAAK,YAAY,SACtC,CACI,QAAS,CACL,cAAe,GAAG,KAAK,YAAY,cAAc,KAAK,YAAY,cACtE,CACJ,CACJ,EAAE,MAAM,AAAC,GAAQ,EAAO;AAAA,EAAsB,GAAK,CAAC,EAC9C,EAAyB,CAAC,EAChC,GAAI,MAAO,IAAa,SAAU,OAElC,AADkB,KAAK,MAAM,CAAQ,EAC3B,MAAM,QAAQ,AAAC,GAAW,CAChC,AAAI,EAAE,OAAO,EAAO,KAAK,GAAI,GAAa,EAAE,KAAK,CAAC,CACtD,CAAC,EACD,KAAK,eAAe,IAAI,GAAG,IAAK,CAAM,EACtC,EAAQ,SAAS,CACrB,CAAC,CACL,EAEJ,YAAM,SAAQ,WAAW,CAAI,EACtB,IACX,CAgBA,KAAK,EAAa,CACd,GAAI,CAAC,EAAK,KAAM,IAAI,OAAM,6BAA6B,EACvD,GAAI,CAAC,KAAK,eAAe,IAAI,GAAG,GAAK,EAAG,KAAM,IAAI,OAAM,8BAA8B,EACtF,MAAO,MAAK,eAAe,IAAI,GAAG,GAAK,CAC3C,IAKI,cAAc,CACd,MAAO,MAAK,eAAe,IAC/B,IAII,eAAe,CACf,GAAI,KAAK,OAAQ,MAAO,MAAK,YAC7B,GAAM,GAAsB,KAAK,YACjC,MAAQ,GAAc,GAAK,IAAO,KAAK,eAAe,IAAI,GAAG,GAAa,EAAqB,MACnG,MAWM,aAAsC,CACxC,KAAM,MAAK,MAAM,EAEjB,GAAM,GAAyB,CAAC,EAEhC,OAAW,KAAQ,MAAK,eAAe,OAAO,EAAG,EAAO,KAAK,GAAG,CAAI,EAEpE,MAAO,EACX,CAKA,QAAuB,CACnB,MAAO,CACH,KAAM,KAAK,KACX,cAAe,KAAK,cACpB,YAAa,KAAK,YAClB,IAAK,KAAK,IACV,GAAI,KAAK,GACT,UAAW,KAAK,UAChB,MAAO,KAAK,MACZ,YAAa,KAAK,WACtB,CACJ,CACJ,EAhMO,uBAoMA,WAAmB,CA8DtB,YAAY,EAAW,EAAiC,EAAiB,CACrE,KAAK,KAAO,EAAK,KACjB,KAAK,KAAO,QACZ,KAAK,GAAK,EAAK,GACf,KAAK,OAAS,EACd,KAAK,IAAM,EAAK,cAAc,QAC9B,KAAK,UAAY,EAAK,OAAO,GAC7B,GAAM,GAA4B,CAAC,EACnC,EAAK,QAAQ,QAAQ,AAAC,GAAW,CAC7B,EAAQ,KAAK,CACT,KAAM,EAAE,KACR,GAAI,EAAE,GACN,IAAK,EAAE,cAAc,OACzB,CAAC,CACL,CAAC,EACD,KAAK,QAAU,EACf,KAAK,WAAa,EAAK,WACvB,KAAK,aAAe,EAAK,aACzB,KAAK,uBAAyB,EAAK,uBACnC,KAAK,YAAc,EAAK,aACxB,GAAM,GAAyB,CAAC,EAChC,AAAK,KAAK,QACN,EAAK,OAAO,MAAM,QAAQ,AAAC,GAAW,CAClC,EAAO,KAAK,GAAI,GAAa,CAAC,CAAC,CACnC,CAAC,EACL,KAAK,eAAiB,GAAI,KAC1B,KAAK,eAAe,IAAI,IAAK,CAAM,EACnC,KAAK,YAAc,CACvB,MAOM,QAAQ,CACV,GAAI,KAAK,OAAQ,MAAO,MACxB,GAAI,GAGJ,GAFA,AAAI,KAAK,YAAc,IAAK,EAAW,IAClC,EAAW,KAAK,YACjB,GAAY,GAAI,MAAO,MAC3B,GAAM,GAAO,CAAC,EACd,OAAS,GAAI,EAAG,GAAK,KAAK,KAAK,EAAW,EAAE,EAAG,IAC3C,EAAK,KACD,GAAI,SAAQ,MAAO,EAAS,IAAW,CACnC,GAAM,GAAW,KAAM,GACnB,qCAAqC,KAAK,oBAAqB,GAAI,GAAK,sBACpE,KAAK,YAAY,SAErB,CACI,QAAS,CACL,cAAe,GAAG,KAAK,YAAY,cAAc,KAAK,YAAY,cACtE,CACJ,CACJ,EAAE,MAAM,AAAC,GAAQ,EAAO;AAAA,EAAsB,GAAK,CAAC,EAC9C,EAAyB,CAAC,EAChC,GAAI,MAAO,IAAa,SAAU,OAElC,AADkB,KAAK,MAAM,CAAQ,EAC3B,MAAM,QAAQ,AAAC,GAAW,CAChC,AAAI,GAAG,EAAO,KAAK,GAAI,GAAa,CAAC,CAAC,CAC1C,CAAC,EACD,KAAK,eAAe,IAAI,GAAG,IAAK,CAAM,EACtC,EAAQ,SAAS,CACrB,CAAC,CACL,EAEJ,YAAM,SAAQ,WAAW,CAAI,EACtB,IACX,CAgBA,KAAK,EAAa,CACd,GAAI,CAAC,EAAK,KAAM,IAAI,OAAM,6BAA6B,EACvD,GAAI,CAAC,KAAK,eAAe,IAAI,GAAG,GAAK,EAAG,KAAM,IAAI,OAAM,8BAA8B,EACtF,MAAO,MAAK,eAAe,IAAI,GAAG,GAAK,CAC3C,IAKI,cAAc,CACd,MAAO,MAAK,eAAe,IAC/B,IAII,eAAe,CACf,GAAI,KAAK,OAAQ,MAAO,MAAK,YAC7B,GAAM,GAAsB,KAAK,YACjC,MAAQ,GAAc,GAAK,IAAO,KAAK,eAAe,IAAI,GAAG,GAAa,EAAqB,MACnG,MAWM,aAAsC,CACxC,KAAM,MAAK,MAAM,EAEjB,GAAM,GAAyB,CAAC,EAEhC,OAAW,KAAQ,MAAK,eAAe,OAAO,EAAG,EAAO,KAAK,GAAG,CAAI,EAEpE,MAAO,EACX,CAKA,QAAoB,CAChB,MAAO,CACH,KAAM,KAAK,KACX,GAAI,KAAK,GACT,KAAM,KAAK,KACX,IAAK,KAAK,IACV,UAAW,KAAK,UAChB,QAAS,KAAK,QACd,WAAY,KAAK,WACjB,aAAc,KAAK,aACnB,uBAAwB,KAAK,uBAC7B,YAAa,KAAK,WACtB,CACJ,CACJ,EA3MO,oBCpXP,6EAEA,GAAI,GACJ,AAAI,GAAW,oBAAoB,GAC/B,GAAc,KAAK,MAAM,GAAa,qBAAsB,OAAO,CAAC,EACpE,EAAY,KAAO,IAmBvB,GAAM,IAAU,8DAiBhB,kBAA8B,EAA+B,CACzD,GAAI,CAAC,EAAa,KAAM,IAAI,OAAM;AAAA,qCAA+D,EACjG,GAAM,GAAO,EAAI,KAAK,EACtB,GAAI,CAAC,EAAK,MAAM,EAAO,EAAG,KAAM,IAAI,OAAM,2BAA2B,EACrE,GAAI,EAAK,QAAQ,QAAQ,IAAM,GAAI,CAC/B,GAAM,GAAU,EAAK,MAAM,QAAQ,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE,GAC3D,EAAW,KAAM,GAAQ,qCAAqC,YAAkB,EAAY,SAAU,CACxG,QAAS,CACL,cAAe,GAAG,EAAY,cAAc,EAAY,cAC5D,CACJ,CAAC,EAAE,MAAM,AAAC,GACC,CACV,EACD,GAAI,YAAoB,OAAO,KAAM,GACrC,MAAO,IAAI,GAAa,KAAK,MAAM,CAAQ,CAAC,CAChD,SAAW,EAAK,QAAQ,QAAQ,IAAM,GAAI,CACtC,GAAM,GAAU,EAAI,MAAM,QAAQ,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE,GAC1D,EAAW,KAAM,GAAQ,qCAAqC,YAAkB,EAAY,SAAU,CACxG,QAAS,CACL,cAAe,GAAG,EAAY,cAAc,EAAY,cAC5D,CACJ,CAAC,EAAE,MAAM,AAAC,GACC,CACV,EACD,GAAI,YAAoB,OAAO,KAAM,GACrC,MAAO,IAAI,GAAa,KAAK,MAAM,CAAQ,EAAG,EAAa,EAAK,CACpE,SAAW,EAAK,QAAQ,WAAW,IAAM,GAAI,CACzC,GAAM,GAAa,EAAI,MAAM,WAAW,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,MAAM,GAAG,EAAE,GAChE,EAAW,KAAM,GACnB,wCAAwC,YAAqB,EAAY,SACzE,CACI,QAAS,CACL,cAAe,GAAG,EAAY,cAAc,EAAY,cAC5D,CACJ,CACJ,EAAE,MAAM,AAAC,GACE,CACV,EACD,GAAI,YAAoB,OAAO,KAAM,GACrC,MAAO,IAAI,GAAgB,KAAK,MAAM,CAAQ,EAAG,EAAa,EAAK,CACvE,KAAO,MAAM,IAAI,OAAM,kCAAkC,CAC7D,CAzCsB,gBAkDf,YAAqB,EAAgE,CACxF,GAAM,GAAO,EAAI,KAAK,EACtB,MAAK,GAAK,WAAW,OAAO,EACvB,EAAK,MAAM,EAAO,EACnB,EAAK,QAAQ,QAAQ,IAAM,GACpB,QACA,EAAK,QAAQ,QAAQ,IAAM,GAC3B,QACA,EAAK,QAAQ,WAAW,IAAM,GAC9B,WACG,GAPmB,GADK,QAS1C,CAXgB,oBAiBhB,kBAAuC,EAA0B,EAAiC,CAC9F,GAAM,GAAW,KAAM,GAAQ,yCAA0C,CACrE,QAAS,CACL,cAAiB,SAAS,OAAO,KAAK,GAAG,EAAK,aAAa,EAAK,eAAe,EAAE,SAAS,QAAQ,IAClG,eAAgB,mCACpB,EACA,KAAM,sCAAsC,EAAK,mCAAmC,UAChF,EAAK,YACT,IACA,OAAQ,MACZ,CAAC,EAAE,MAAM,AAAC,GACC,CACV,EACD,GAAI,YAAoB,OAAO,KAAM,GACrC,GAAM,GAAY,KAAK,MAAM,CAAQ,EACrC,SAAc,CACV,UAAW,EAAK,UAChB,cAAe,EAAK,cACpB,aAAc,EAAK,aACnB,aAAc,EAAU,aACxB,cAAe,EAAU,cACzB,WAAY,OAAO,EAAU,UAAU,EACvC,OAAQ,KAAK,IAAI,EAAK,GAAU,WAAa,GAAK,IAClD,WAAY,EAAU,WACtB,OAAQ,EAAK,MACjB,EACA,AAAI,EAAM,GAAc,qBAAsB,KAAK,UAAU,EAAa,OAAW,CAAC,CAAC,EAEnF,SAAQ,IAAI,eAAe,EAAY,WAAW,EAClD,QAAQ,IAAI,mBAAmB,EAAY,eAAe,EAC1D,QAAQ,IAAI,mBAAmB,EAAY,eAAe,EAC1D,QAAQ,IAAI,YAAY,EAAY,QAAQ,EAC5C,QAAQ,IAAI;AAAA,uCAA0C,GAEnD,EACX,CAnCsB,yBA+Cf,aAA+B,CAClC,MAAI,MAAK,IAAI,GAAM,EAAY,MAEnC,CAHgB,mBAehB,kBACI,EACA,EACA,EAAgB,GACE,CAClB,GAAM,GAAqB,CAAC,EAC5B,GAAI,CAAC,EAAa,KAAM,IAAI,OAAM;AAAA,qCAA+D,EACjG,GAAI,EAAM,SAAW,EAAG,KAAM,IAAI,OAAM,4BAA4B,EACpE,GAAI,EAAQ,IAAM,EAAQ,EAAG,KAAM,IAAI,OAAM,+CAA+C,EAC5F,GAAM,GAAW,KAAM,GACnB,0CAA0C,OAAU,WAAe,YAAgB,EAAY,SAC/F,CACI,QAAS,CACL,cAAe,GAAG,EAAY,cAAc,EAAY,cAC5D,CACJ,CACJ,EAAE,MAAM,AAAC,GACE,CACV,EACD,GAAI,YAAoB,OAAO,KAAM,GACrC,GAAM,GAAY,KAAK,MAAM,CAAQ,EACrC,MAAI,KAAS,QACT,EAAU,OAAO,MAAM,QAAQ,AAAC,GAAe,CAC3C,EAAQ,KAAK,GAAI,GAAa,CAAK,CAAC,CACxC,CAAC,EACE,AAAI,IAAS,QAChB,EAAU,OAAO,MAAM,QAAQ,AAAC,GAAe,CAC3C,EAAQ,KAAK,GAAI,GAAa,EAAO,EAAa,EAAI,CAAC,CAC3D,CAAC,EACM,IAAS,YAChB,EAAU,UAAU,MAAM,QAAQ,AAAC,GAAkB,CACjD,EAAQ,KAAK,GAAI,GAAgB,EAAU,EAAa,EAAI,CAAC,CACjE,CAAC,EAEE,CACX,CAnCsB,kBA8CtB,mBAAuD,CACnD,GAAM,GAAW,KAAM,GAAQ,yCAA0C,CACrE,QAAS,CACL,cAAiB,SAAS,OAAO,KAAK,GAAG,EAAY,aAAa,EAAY,eAAe,EAAE,SAC3F,QACJ,IACA,eAAgB,mCACpB,EACA,KAAM,0CAA0C,EAAY,gBAC5D,OAAQ,MACZ,CAAC,EAAE,MAAM,AAAC,GACC,CACV,EACD,GAAI,YAAoB,OAAO,MAAO,GACtC,GAAM,GAAY,KAAK,MAAM,CAAQ,EACrC,SAAY,aAAe,EAAU,aACrC,EAAY,WAAa,OAAO,EAAU,UAAU,EACpD,EAAY,OAAS,KAAK,IAAI,EAAK,GAAU,WAAa,GAAK,IAC/D,EAAY,WAAa,EAAU,WAC/B,EAAY,MAAM,GAAc,qBAAsB,KAAK,UAAU,EAAa,OAAW,CAAC,CAAC,EAC5F,EACX,CArBsB,qBAuBtB,kBAAsC,EAA6B,CAC/D,EAAc,EACd,EAAY,KAAO,GACnB,KAAM,IAAa,CACvB,CAJsB,wBCjPtB,yDCCA,wCA4FO,WAAsB,CA2DzB,YAAY,EAAW,CACnB,KAAK,KAAO,EAAK,MACjB,KAAK,GAAK,EAAK,GACf,KAAK,IAAM,EAAK,IAChB,KAAK,UAAY,EAAK,cACtB,KAAK,QAAU,GACf,KAAK,KAAO,QACZ,KAAK,cAAgB,KAAK,MAAM,OAAO,EAAK,QAAQ,EAAI,GAAI,EAC5D,KAAK,aAAe,OAAO,EAAK,QAAQ,EACxC,AAAI,EAAK,mBACL,KAAK,UAAY,CACb,KAAM,EAAK,mBAAmB,UAC9B,GAAI,EAAK,mBAAmB,GAC5B,OAAQ,EAAK,mBAAmB,OAChC,eAAgB,QAAQ,EAAK,mBAAmB,cAAc,GAAK,GACnE,gBAAiB,EAAK,mBAAmB,eAC7C,EACC,KAAK,UAAY,KACtB,KAAK,QAAU,EAAK,MAAM,aAC1B,KAAK,KAAO,CACR,KAAM,EAAK,KAAK,SAChB,GAAI,EAAK,KAAK,GACd,KAAM,OACN,IAAK,EAAK,KAAK,cACf,SAAU,QAAQ,EAAK,KAAK,QAAQ,GAAK,GACzC,YAAa,EAAK,KAAK,YACvB,WAAY,EAAK,KAAK,WACtB,UAAW,EAAK,KAAK,UACrB,UAAW,EAAK,KAAK,UACrB,UAAW,EAAK,KAAK,UACzB,EACA,KAAK,UAAY,EAAK,WAC1B,CAKA,QAAyB,CACrB,MAAO,CACH,KAAM,KAAK,KACX,GAAI,KAAK,GACT,IAAK,KAAK,IACV,UAAW,KAAK,UAChB,QAAS,KAAK,QACd,aAAc,KAAK,aACnB,cAAe,KAAK,cACpB,UAAW,KAAK,UAChB,QAAS,KAAK,QACd,UAAW,KAAK,UAChB,KAAM,KAAK,IACf,CACJ,CACJ,EA/GO,uBAmHA,WAAyB,CAmD5B,YAAY,EAAW,EAAmB,CACtC,KAAK,KAAO,EAAK,MACjB,KAAK,GAAK,EAAK,GACf,KAAK,IAAM,EAAK,IAChB,KAAK,UAAY,EACjB,KAAK,KAAO,WACZ,KAAK,SAAW,EAAK,SACrB,KAAK,cAAgB,KAAK,MAAM,OAAO,EAAK,QAAQ,EAAI,GAAI,EAC5D,KAAK,aAAe,OAAO,EAAK,QAAQ,EACxC,KAAK,KAAO,CACR,KAAM,EAAK,KAAK,SAChB,GAAI,EAAK,KAAK,GACd,KAAM,OACN,IAAK,EAAK,KAAK,cACf,SAAU,QAAQ,EAAK,KAAK,QAAQ,GAAK,GACzC,YAAa,EAAK,KAAK,YACvB,WAAY,EAAK,KAAK,WACtB,UAAW,EAAK,KAAK,UACrB,UAAW,EAAK,KAAK,UACrB,UAAW,EAAK,KAAK,UACzB,EACA,KAAK,YAAc,EAAK,YACxB,GAAM,GAAgB,CAAC,EACvB,EAAK,OAAO,QAAQ,AAAC,GAAe,CAChC,AAAI,EAAM,MACN,EAAO,KAAK,GAAI,GAAgB,CAAK,CAAC,EAEtC,EAAO,KAAK,CACR,GAAI,EAAM,GACV,QAAS,GACT,KAAM,OACV,CAAC,CACT,CAAC,EACD,KAAK,OAAS,CAClB,MAOM,QAAqC,CACvC,GAAM,GAAc,CAAC,EACrB,OAAS,GAAI,EAAG,EAAI,KAAK,OAAO,OAAQ,IACpC,AAAK,KAAK,OAAO,GAAG,SAChB,EAAK,KACD,GAAI,SAAQ,KAAO,IAAY,CAC3B,GAAM,GAAM,EACN,EAAO,KAAM,GACf,wCAAwC,KAAK,OAAO,GAAG,gBAAgB,KAAK,WAChF,EAEA,KAAK,OAAO,GAAO,GAAI,GAAgB,KAAK,MAAM,CAAI,CAAC,EACvD,EAAQ,EAAE,CACd,CAAC,CACL,EAGR,YAAM,SAAQ,WAAW,CAAI,EACtB,IACX,IAKI,eAAuB,CACvB,GAAI,GAAQ,EACZ,YAAK,OAAO,QAAQ,AAAC,GAAU,CAC3B,GAAI,YAAiB,GAAiB,QACjC,OACT,CAAC,EACM,CACX,MAWM,aAAyC,CAC3C,YAAM,MAAK,MAAM,EAEV,KAAK,MAChB,CAKA,QAAuB,CACnB,MAAO,CACH,KAAM,KAAK,KACX,GAAI,KAAK,GACT,SAAU,KAAK,SACf,IAAK,KAAK,IACV,aAAc,KAAK,aACnB,cAAe,KAAK,cACpB,YAAa,KAAK,YAClB,KAAM,KAAK,KACX,OAAQ,KAAK,MACjB,CACJ,CACJ,EA5JO,0BAgKA,WAAuB,CAkD1B,YAAY,EAAa,EAAmB,YAAsB,CAC9D,KAAK,OAAS,GAAI,IAAS,CAAE,cAAe,EAAI,IAAO,IAAM,MAAO,CAAC,CAAE,CAAC,EACxE,KAAK,KAAO,EACZ,KAAK,IAAM,EACX,KAAK,gBAAkB,EACvB,KAAK,QAAU,KACf,KAAK,oBAAsB,EAC3B,KAAK,KAAO,CAAC,EACb,KAAK,MAAQ,GAAI,GAAM,IAAM,CACzB,KAAK,MAAM,MAAM,EACjB,KAAK,MAAM,CACf,EAAG,GAAG,EACN,KAAK,aAAe,CAAC,EACrB,KAAK,OAAO,GAAG,QAAS,IAAM,CAC1B,KAAK,QAAQ,CACjB,CAAC,EACD,KAAK,MAAM,CACf,MAKc,SAAS,CACnB,GAAM,GAAW,KAAM,GAAQ,KAAK,GAAG,EAAE,MAAM,AAAC,GACrC,CACV,EACD,GAAI,YAAoB,OAAO,KAAM,GAErC,AADc,EAAS,MAAM;AAAA,CAAI,EAC3B,QAAQ,AAAC,GAAQ,CACnB,AAAI,EAAI,WAAW,UAAU,EACzB,KAAK,KAAK,KAAK,WAAW,EAAI,QAAQ,WAAY,EAAE,CAAC,CAAC,EAC/C,EAAI,WAAW,OAAO,GAC7B,KAAK,aAAa,KAAK,CAAG,CAElC,CAAC,CAEL,MAIc,QAAQ,CAClB,GAAI,KAAK,OAAO,UAAW,CACvB,KAAK,QAAQ,EACb,MACJ,CACA,KAAK,KAAO,CAAC,EACb,KAAK,aAAe,CAAC,EACrB,KAAK,gBAAkB,EACvB,KAAM,MAAK,OAAO,EAClB,KAAK,aAAa,OAAO,EAAG,KAAK,mBAAmB,EACpD,KAAK,KAAK,CACd,MAIc,OAAO,CACjB,GAAI,KAAK,OAAO,UAAW,CACvB,KAAK,QAAQ,EACb,MACJ,CACA,GAAI,KAAK,KAAK,SAAW,GAAK,KAAK,aAAa,SAAW,EAAG,CAC1D,KAAK,QAAQ,EACb,KAAK,OAAO,KAAK,IAAI,EACrB,MACJ,CACA,KAAK,iBAAmB,KAAK,KAAK,MAAM,EACxC,KAAK,sBACL,GAAM,GAAS,KAAM,GAAe,KAAK,aAAa,MAAM,CAAW,EAAE,MAAM,AAAC,GAAe,CAAG,EAClG,GAAI,YAAkB,OAAO,CACzB,KAAK,OAAO,KAAK,QAAS,CAAM,EAChC,KAAK,QAAQ,EACb,MACJ,CAEA,KAAK,QAAU,EACf,EAAO,GAAG,OAAQ,AAAC,GAAM,CACrB,KAAK,OAAO,KAAK,CAAC,CACtB,CAAC,EACD,EAAO,GAAG,MAAO,IAAM,CACnB,AAAI,KAAK,iBAAmB,KACvB,KAAK,KAAK,CACnB,CAAC,EACD,EAAO,KAAK,QAAS,AAAC,GAAQ,CAC1B,KAAK,OAAO,KAAK,QAAS,CAAG,CACjC,CAAC,CACL,CAMQ,SAAU,CACd,KAAK,MAAM,QAAQ,EACnB,KAAK,SAAS,QAAQ,EACtB,KAAK,IAAM,GACX,KAAK,gBAAkB,EACvB,KAAK,oBAAsB,EAC3B,KAAK,QAAU,KACf,KAAK,KAAO,CAAC,EACb,KAAK,aAAe,CAAC,CACzB,CAOA,OAAQ,CACJ,KAAK,MAAM,MAAM,CACrB,CAKA,QAAS,CACL,KAAK,MAAM,OAAO,CACtB,CACJ,EAvKO,wBD5WP,GAAI,GACJ,AAAI,GAAW,uBAAuB,GAClC,GAAY,KAAK,MAAM,GAAa,wBAAyB,OAAO,CAAC,GAOzE,GAAM,IAAU,2FAiBhB,kBAAiC,EAAkC,CAC/D,GAAI,CAAC,EAAW,KAAM,IAAI,OAAM;AAAA,qCAAkE,EAClG,GAAM,GAAO,EAAI,KAAK,EACtB,GAAI,CAAC,EAAK,MAAM,EAAO,EAAG,KAAM,IAAI,OAAM,8BAA8B,EAExE,GAAM,GAAO,KAAM,GACf,6CAA6C,eAAkB,EAAU,WAC7E,EAAE,MAAM,AAAC,GAAe,CAAG,EAE3B,GAAI,YAAgB,OAAO,KAAM,GAEjC,GAAM,GAAY,KAAK,MAAM,CAAI,EAEjC,GAAI,EAAU,OAAS,SAAW,EAAU,OAAS,WACjD,KAAM,IAAI,OAAM,uCAAuC,EAE3D,MAAI,GAAU,OAAS,QAAgB,GAAI,GAAgB,CAAS,EACxD,GAAI,GAAmB,EAAW,EAAU,SAAS,CACrE,CAlBsB,mBA8BtB,kBACI,EACA,EACA,EAAgB,GACK,CACrB,GAAM,GAAW,KAAM,GACnB,wCAAwC,OAAU,eAAmB,EAAU,mBAAmB,GACtG,EACM,EAAoD,CAAC,EAE3D,MADkB,MAAK,MAAM,CAAQ,EAC3B,WAAW,QAAQ,AAAC,GAAW,CACrC,AAAI,IAAS,SAAU,EAAQ,KAAK,GAAI,GAAgB,CAAC,CAAC,EACrD,EAAQ,KAAK,GAAI,GAAmB,EAAG,EAAU,SAAS,CAAC,CACpE,CAAC,EACM,CACX,CAfsB,kBAsBtB,kBAA6B,EAAa,EAA6C,CACnF,GAAM,GAAO,KAAM,IAAW,CAAG,EAEjC,GAAI,YAAgB,GAAoB,KAAM,IAAI,OAAM,6CAA6C,EAErG,GAAM,GAAa,GAAgB,EAAK,OAAO,EAC/C,AAAI,MAAO,IAAY,SAAU,EAAU,EAAW,OAAS,EAC1D,AAAI,GAAW,EAAG,EAAU,EACxB,GAAW,EAAW,QAAQ,GAAU,EAAW,OAAS,GACrE,GAAM,GAAU,EAAW,GAAS,IAAM,cAAgB,EAAU,UAC9D,EAAS,KAAK,MAAM,KAAM,GAAQ,CAAO,CAAC,EAC1C,EAAO,EAAW,GAAS,OAAO,UAAU,WAAW,WAAW,EAClE,WACA,YACN,MAAO,IAAI,GAAiB,EAAO,IAAK,CAAI,CAChD,CAfsB,eA8BtB,mBAAyD,CAErD,GAAM,GAAW,AADJ,MAAM,GAAQ,yBAAyB,GAC9B,MAAM,2BAA2B,EACjD,EAAiB,CAAC,EACxB,SAAS,QAAQ,AAAC,GAAM,CACpB,AAAI,EAAE,WAAW,OAAO,GACpB,EAAK,KAAK,EAAE,MAAM,GAAG,EAAE,EAAE,CAEjC,CAAC,EAEM,AADO,MAAM,GAAQ,EAAK,EAAK,OAAS,EAAE,GACpC,MAAM,cAAc,EAAE,GAAG,MAAM,GAAG,EAAE,EACrD,CAXsB,wBAkBtB,kBAAuC,EAAuB,EAA6C,CACvG,GAAM,GAAa,GAAgB,EAAK,OAAO,EAC/C,AAAI,MAAO,IAAY,SAAU,EAAU,EAAW,OAAS,EAC1D,AAAI,GAAW,EAAG,EAAU,EACxB,GAAW,EAAW,QAAQ,GAAU,EAAW,OAAS,GACrE,GAAM,GAAU,EAAW,GAAS,IAAM,cAAgB,EAAU,UAC9D,EAAS,KAAK,MAAM,KAAM,GAAQ,CAAO,CAAC,EAC1C,EAAO,EAAW,GAAS,OAAO,UAAU,WAAW,WAAW,EAClE,WACA,YACN,MAAO,IAAI,GAAiB,EAAO,IAAK,CAAI,CAChD,CAXsB,yBAiBtB,kBAA+B,EAA8B,CAMzD,MAAI,EALa,KAAM,GAAQ,kDAAkD,uBAAwB,EAAE,MACvG,AAAC,GACU,CAEf,WACwB,OAE5B,CARsB,iBAiBtB,kBAAkC,EAA+D,CAC7F,GAAM,GAAO,EAAI,KAAK,EACtB,GAAI,CAAC,EAAK,WAAW,OAAO,EAAG,MAAO,SACtC,GAAI,CAAC,EAAK,MAAM,EAAO,EAAG,MAAO,GACjC,GAAM,GAAO,KAAM,GACf,6CAA6C,eAAkB,EAAU,WAC7E,EAAE,MAAM,AAAC,GAAe,CAAG,EAE3B,GAAI,YAAgB,OAAO,MAAO,GAElC,GAAM,GAAY,KAAK,MAAM,CAAI,EACjC,MAAI,GAAU,OAAS,QAAgB,QAC9B,EAAU,OAAS,WAAmB,WACnC,EAChB,CAdsB,oBAoBtB,YAAyB,EAA+B,CACpD,GAAM,GAAkC,CAAC,EACzC,SAAK,QAAQ,AAAC,GAAW,CACrB,AAAI,EAAO,OAAO,WAAa,OAAO,EAAO,KAAK,CAAM,CAC5D,CAAC,EACM,CACX,CANS,wBAQF,YAA4B,EAA2B,CAC1D,EAAY,CAChB,CAFgB,2BEhMhB,gCCwDO,WAAkB,CA8GrB,YAAY,EAAW,EAAkB,CACrC,KAAK,GAAK,EAAK,GACf,KAAK,MAAQ,EAAK,MAClB,KAAK,WAAa,EAAK,YACvB,KAAK,IAAM,EAAK,KAChB,KAAK,cAAgB,EAAK,SAC1B,KAAK,KAAO,EAAK,KACjB,KAAK,SAAW,EAAK,gBACrB,KAAK,WAAa,EAAK,QACvB,KAAK,OAAS,GAAI,GAAa,EAAK,MAAM,EAC1C,KAAK,MAAQ,GAAI,IAAiB,EAAK,KAAK,EAC5C,KAAK,KAAO,QAEZ,KAAK,QAAU,EAEV,GACD,MAAK,cAAgB,EAAK,eAC1B,KAAK,WAAa,EAAK,YACvB,KAAK,YAAc,GAAI,MAAK,EAAK,YAAY,EAC7C,KAAK,IAAM,EAAK,IAChB,KAAK,KAAO,EAAK,KACjB,KAAK,aAAe,CAAC,EAErB,EAAK,aAAa,QAAQ,AAAC,GAAqB,CAC5C,KAAK,cAAc,KAAK,GAAI,GAAa,CAAW,CAAC,CACzD,CAAC,EAET,MASM,QAA8B,CAChC,GAAI,CAAC,KAAK,QAAS,MAAO,MAE1B,GAAM,GAAW,KAAM,GAAQ,gCAAgC,KAAK,KAAK,EAAE,MAAM,AAAC,GAAe,CAAG,EAEpG,GAAI,YAAoB,OAAO,KAAM,GACrC,GAAM,GAAW,KAAK,MAAM,CAAQ,EAEpC,YAAK,QAAU,GAEf,KAAK,cAAgB,EAAS,eAC9B,KAAK,WAAa,EAAS,YAC3B,KAAK,YAAc,GAAI,MAAK,EAAS,YAAY,EACjD,KAAK,IAAM,EAAS,IACpB,KAAK,KAAO,EAAS,KACrB,KAAK,aAAe,CAAC,EAErB,EAAS,aAAa,QAAQ,AAAC,GAAqB,CAChD,KAAK,cAAc,KAAK,GAAI,GAAa,CAAW,CAAC,CACzD,CAAC,EAEM,IACX,CAKA,QAAS,CACL,MAAO,CACH,GAAI,KAAK,GACT,MAAO,KAAK,MACZ,WAAY,KAAK,WACjB,IAAK,KAAK,IACV,cAAe,KAAK,cACpB,KAAM,KAAK,KACX,SAAU,KAAK,SACf,WAAY,KAAK,WACjB,OAAQ,KAAK,OACb,MAAO,KAAK,MACZ,KAAM,KAAK,KACX,cAAe,KAAK,cACpB,WAAY,KAAK,WACjB,YAAa,KAAK,YAClB,IAAK,KAAK,IACV,KAAM,KAAK,KACX,aAAc,KAAK,YACvB,CACJ,CACJ,EAlMO,mBAsMA,WAAkB,CAyHrB,YAAY,EAAW,EAAkB,CAqBrC,GApBA,KAAK,GAAK,EAAK,GACf,KAAK,MAAQ,EAAK,MAClB,KAAK,IAAM,EAAK,KAChB,KAAK,WAAa,EAAK,YACvB,KAAK,SAAW,EAAK,gBACrB,KAAK,OAAS,GAAI,GAAa,EAAK,MAAM,EAC1C,KAAK,KAAO,QACZ,KAAK,YAAc,EAAK,UACxB,KAAK,aAAe,CAAC,EACrB,KAAK,OAAS,CAAC,EACf,KAAK,OAAS,CAAC,EACf,KAAK,MAAQ,CACT,GAAI,EAAK,SACT,IAAK,EAAK,UACV,OAAQ,EAAK,aACb,MAAO,EAAK,WAChB,EAEA,KAAK,QAAU,EAEX,CAAC,EAAS,CACV,KAAK,IAAM,EAAK,IAChB,KAAK,cAAgB,EAAK,SAC1B,KAAK,aAAe,EAAK,KACzB,KAAK,YAAc,GAAI,MAAK,EAAK,YAAY,EAC7C,KAAK,UAAY,EAAK,UAEtB,EAAK,aAAa,QAAQ,AAAC,GAAqB,CAC5C,KAAK,cAAc,KAAK,GAAI,GAAa,CAAW,CAAC,CACzD,CAAC,EAED,EAAK,OAAO,KAAK,QAAQ,AAAC,GAAe,CACrC,KAAK,QAAQ,KAAK,CACd,KAAM,EAAM,KACZ,QAAS,CACL,GAAI,GAAG,EAAM,kBACb,IAAK,GAAG,EAAM,mBACd,OAAQ,GAAG,EAAM,sBACjB,MAAO,GAAG,EAAM,oBACpB,CACJ,CAAC,CACL,CAAC,EAED,GAAM,GAAkB,CACpB,GAAI,KAAK,GACT,MAAO,KAAK,MACZ,SAAU,KAAK,MAAM,GACrB,UAAW,KAAK,MAAM,IACtB,aAAc,KAAK,MAAM,OACzB,YAAa,KAAK,MAAM,MACxB,aAAc,EAAK,YACvB,EACA,EAAK,OAAO,KAAK,QAAQ,AAAC,GAAe,CACrC,EAAM,MAAQ,EACd,KAAK,OAAO,KAAK,GAAI,GAAY,EAAO,EAAI,CAAC,CACjD,CAAC,CACL,CACJ,MASM,QAA8B,CAChC,GAAI,CAAC,KAAK,QAAS,MAAO,MAE1B,GAAM,GAAW,KAAM,GAAQ,gCAAgC,KAAK,KAAK,EAAE,MAAM,AAAC,GAAe,CAAG,EAEpG,GAAI,YAAoB,OAAO,KAAM,GACrC,GAAM,GAAW,KAAK,MAAM,CAAQ,EAEpC,KAAK,QAAU,GAEf,KAAK,IAAM,EAAS,IACpB,KAAK,cAAgB,EAAS,SAC9B,KAAK,aAAe,EAAS,KAC7B,KAAK,YAAc,GAAI,MAAK,EAAS,YAAY,EACjD,KAAK,UAAY,EAAS,UAC1B,KAAK,aAAe,CAAC,EACrB,KAAK,OAAS,CAAC,EACf,KAAK,OAAS,CAAC,EAEf,EAAS,aAAa,QAAQ,AAAC,GAAqB,CAChD,KAAK,cAAc,KAAK,GAAI,GAAa,CAAW,CAAC,CACzD,CAAC,EAED,EAAS,OAAO,KAAK,QAAQ,AAAC,GAAe,CACzC,KAAK,QAAQ,KAAK,CACd,KAAM,EAAM,KACZ,QAAS,CACL,GAAI,GAAG,EAAM,kBACb,IAAK,GAAG,EAAM,mBACd,OAAQ,GAAG,EAAM,sBACjB,MAAO,GAAG,EAAM,oBACpB,CACJ,CAAC,CACL,CAAC,EAED,GAAM,GAAkB,CACpB,GAAI,KAAK,GACT,MAAO,KAAK,MACZ,SAAU,KAAK,MAAM,GACrB,UAAW,KAAK,MAAM,IACtB,aAAc,KAAK,MAAM,OACzB,YAAa,KAAK,MAAM,MACxB,aAAc,EAAS,YAC3B,EACA,SAAS,OAAO,KAAK,QAAQ,AAAC,GAAe,CACzC,EAAM,MAAQ,EACd,KAAK,OAAO,KAAK,GAAI,GAAY,EAAO,EAAI,CAAC,CACjD,CAAC,EAEM,IACX,MAWM,aAAqC,CACvC,YAAM,MAAK,MAAM,EAEV,KAAK,MAChB,CAKA,QAAS,CACL,MAAO,CACH,GAAI,KAAK,GACT,MAAO,KAAK,MACZ,IAAK,KAAK,IACV,WAAY,KAAK,WACjB,SAAU,KAAK,SACf,OAAQ,KAAK,OACb,MAAO,KAAK,MACZ,KAAM,KAAK,KACX,IAAK,KAAK,IACV,YAAa,KAAK,YAClB,cAAe,KAAK,cACpB,aAAc,KAAK,aACnB,YAAa,KAAK,YAClB,UAAW,KAAK,UAChB,OAAQ,KAAK,OACb,aAAc,KAAK,aACnB,OAAQ,KAAK,OAAO,IAAI,AAAC,GAAU,EAAM,OAAO,CAAC,CACrD,CACJ,CACJ,EAvRO,mBA2RA,WAAqB,CA0GxB,YAAY,EAAW,EAAkB,CACrC,KAAK,GAAK,EAAK,GACf,KAAK,MAAQ,EAAK,MAClB,KAAK,OAAS,EAAK,OACnB,KAAK,IAAM,EAAK,KAChB,KAAK,aAAe,GAAI,MAAK,EAAK,aAAa,EAC/C,KAAK,KAAO,WACZ,KAAK,YAAc,EAAK,UACxB,KAAK,OAAS,CAAC,EAEf,KAAK,QAAU,CACX,GAAI,EAAK,WACT,IAAK,EAAK,YACV,OAAQ,EAAK,eACb,MAAO,EAAK,aAChB,EAEA,AAAI,EAAK,KACL,KAAK,QAAU,CACX,GAAI,EAAK,KAAK,GACd,KAAM,EAAK,KAAK,IACpB,EAEA,KAAK,QAAU,CACX,GAAI,EAAK,QAAQ,GACjB,KAAM,EAAK,QAAQ,IACvB,EAGJ,KAAK,QAAU,EAEV,GACD,MAAK,YAAc,EAAK,YACxB,KAAK,cAAgB,EAAK,SAC1B,KAAK,QAAU,EAAK,eACpB,KAAK,cAAgB,EAAK,cAC1B,KAAK,KAAO,EAAK,KAEb,KAAK,QACL,MAAK,OAAS,EAAK,OAAO,KAAK,IAAI,AAAC,GACzB,GAAI,GAAY,EAAO,EAAI,CACrC,GAGb,MASM,QAAiC,CACnC,GAAI,CAAC,KAAK,SAAY,MAAK,OAAO,SAAW,KAAK,aAAe,CAAC,KAAK,QACnE,MAAO,MAGX,GAAI,KAAK,QAAS,CACd,GAAM,GAAW,KAAM,GAAQ,mCAAmC,KAAK,KAAK,EAAE,MAAM,AAAC,GAAe,CAAG,EAEvG,GAAI,YAAoB,OAAO,KAAM,GACrC,GAAM,GAAW,KAAK,MAAM,CAAQ,EAEpC,KAAK,QAAU,GAEf,KAAK,YAAc,EAAS,YAC5B,KAAK,cAAgB,EAAS,SAC9B,KAAK,QAAU,EAAS,eACxB,KAAK,cAAgB,EAAS,cAC9B,KAAK,KAAO,EAAS,KAEjB,KAAK,QACL,MAAK,OAAS,EAAS,OAAO,KAAK,IAAI,AAAC,GAC7B,GAAI,GAAY,EAAO,EAAI,CACrC,EAET,CAEA,GAAM,GAAqB,KAAK,OAAO,OACvC,GAAI,KAAK,QAAU,IAAuB,KAAK,YAAa,CACxD,GAAI,GAAU,KAAK,YAAc,EAEjC,AAAI,EAAU,KAAM,GAAU,KAE9B,GAAM,GAAqC,CAAC,EAC5C,OAAS,GAAI,EAAG,GAAK,KAAK,KAAK,EAAU,GAAG,EAAG,IAC3C,EAAS,KACL,GAAI,SAAQ,MAAO,EAAS,IAAW,CACnC,GAAM,GAAW,KAAM,GACnB,mCAAmC,KAAK,6BAA6B,EAAI,KAC7E,EAAE,MAAM,AAAC,GAAQ,EAAO,CAAG,CAAC,EAE5B,GAAI,MAAO,IAAa,SAAU,OAElC,GAAM,GAAS,AADE,KAAK,MAAM,CAAQ,EACZ,KAAK,IAAI,AAAC,GACvB,GAAI,GAAY,EAAO,EAAI,CACrC,EAED,EAAQ,CAAM,CAClB,CAAC,CACL,EAGJ,GAAM,GAAU,KAAM,SAAQ,WAAW,CAAQ,EAC3C,EAA2B,CAAC,EAElC,OAAW,KAAU,GACjB,GAAI,EAAO,SAAW,YAClB,EAAU,KAAK,GAAG,EAAO,KAAK,MAE9B,MAAM,GAAO,OAIrB,KAAK,OAAO,KAAK,GAAG,CAAS,CACjC,CAEA,MAAO,KACX,MAWM,aAAqC,CACvC,YAAM,MAAK,MAAM,EAEV,KAAK,MAChB,CAKA,QAAS,CACL,MAAO,CACH,GAAI,KAAK,GACT,MAAO,KAAK,MACZ,OAAQ,KAAK,OACb,IAAK,KAAK,IACV,QAAS,KAAK,QACd,aAAc,KAAK,aACnB,KAAM,KAAK,KACX,QAAS,KAAK,QACd,YAAa,KAAK,YAClB,YAAa,KAAK,YAClB,cAAe,KAAK,cACpB,QAAS,KAAK,QACd,cAAe,KAAK,cACpB,KAAM,KAAK,KACX,OAAQ,KAAK,OAAO,IAAI,AAAC,GAAU,EAAM,OAAO,CAAC,CACrD,CACJ,CACJ,EAxQO,sBA0QP,YAAuB,CAOnB,YAAY,EAAW,CACnB,KAAK,GAAK,EAAK,GACf,KAAK,MAAQ,EAAK,MAClB,KAAK,IAAM,gCAAgC,EAAK,MAChD,KAAK,MAAQ,CACT,GAAI,EAAK,SACT,IAAK,EAAK,UACV,OAAQ,EAAK,aACb,MAAO,EAAK,WAChB,EAEI,EAAK,cAAc,MAAK,YAAc,GAAI,MAAK,EAAK,YAAY,EACxE,CACJ,EApBA,yBAwBA,WAAmB,CAuBf,YAAY,EAAW,CACnB,KAAK,GAAK,EAAK,GACf,KAAK,KAAO,EAAK,KAEjB,KAAK,IAAM,EAAK,KAAO,EAAK,KAAO,iCAAiC,EAAK,MAErE,EAAK,YACL,MAAK,QAAU,CACX,GAAI,EAAK,WACT,IAAK,EAAK,YACV,OAAQ,EAAK,eACb,MAAO,EAAK,aAChB,GAEA,EAAK,MAAM,MAAK,KAAO,EAAK,KACpC,CACJ,EAvCA,oBD3vBA,kBAAgC,EAAgC,CAC5D,GAAI,GACJ,GAAI,CAEA,EAAS,GAAI,IAAI,CAAG,CACxB,MAAE,CACE,MAAO,CAAE,KAAM,QAAS,CAC5B,CAEA,GAAI,EAAO,WAAa,UAAY,EAAO,WAAa,QACpD,MAAO,CAAE,KAAM,QAAS,EAG5B,GAAI,GAAW,EAAO,SACtB,AAAI,EAAS,SAAS,GAAG,GACrB,GAAW,EAAS,MAAM,EAAG,EAAE,GAEnC,GAAM,GAAO,EAAS,MAAM,GAAG,EAC/B,OAAQ,EAAO,cACN,iBACA,iBAAkB,CACnB,GAAI,EAAK,SAAW,GAEhB,GAAI,CAAC,AADQ,EAAK,OAAO,EAAG,CAAC,EAAE,GACrB,MAAM,YAAY,EACxB,MAAO,CAAE,KAAM,EAAM,UAElB,EAAK,SAAW,EACvB,MAAO,CAAE,KAAM,EAAM,EAGzB,MAAK,GAAK,KAAO,SAAW,EAAK,KAAO,SAAW,EAAK,KAAO,aAAe,EAAK,GAAG,MAAM,OAAO,EACxF,CACH,KAAM,EAAK,GACX,GAAI,EAAK,EACb,EAEO,CAAE,KAAM,EAAM,CAE7B,KACK,iBACD,MACI,GAAK,SAAW,GACf,GAAK,KAAO,SAAW,EAAK,KAAO,SAAW,EAAK,KAAO,aAC3D,EAAK,GAAG,MAAM,OAAO,EAEd,CACH,KAAM,EAAK,GACX,GAAI,EAAK,EACb,EAEO,CAAE,KAAM,EAAM,MAGxB,mBACD,GAAI,EAAK,SAAW,GAAK,EAAK,GAAG,MAAM,gBAAgB,EAAG,CACtD,GAAM,GAAW,KAAM,GAAyB,CAAG,EAAE,MAAM,AAAC,GAAQ,CAAG,EAEvE,MAAI,aAAoB,OACb,CAAE,KAAM,GAAO,MAAO,EAAS,OAAQ,EAG3C,KAAM,IAAiB,CAAQ,CAC1C,KACI,OAAO,CAAE,KAAM,EAAM,UAIzB,MAAO,CAAE,KAAM,QAAS,EAEpC,CArEe,yBAkFf,kBAA6B,EAA8B,CACvD,GAAM,GAAW,KAAM,IAAiB,EAAI,KAAK,CAAC,EAElD,GAAI,EAAS,MACT,KAAM,IAAI,OAAM;AAAA,EAAuD,EAAS,OAAO,EACpF,GAAI,CAAC,EAAS,MAAQ,EAAS,OAAS,SAC3C,KAAM,IAAI,OAAM,mDAAmD,EAEvE,GAAM,GAAW,KAAM,GAAQ,0BAA0B,EAAS,QAAQ,EAAS,IAAI,EAAE,MAAM,AAAC,GAAe,CAAG,EAElH,GAAI,YAAoB,OAAO,KAAM,GAErC,GAAM,GAAW,KAAK,MAAM,CAAQ,EAEpC,GAAI,EAAS,MACT,KAAM,IAAI,OAAM,qBAAqB,EAAS,MAAM,SAAS,EAAS,MAAM,SAAS,EAGzF,OAAQ,EAAS,UACR,QACD,MAAO,IAAI,GAAY,EAAU,EAAK,MACrC,WACD,MAAO,IAAI,GAAe,EAAU,EAAK,MACxC,QACD,MAAO,IAAI,GAAY,EAAU,EAAK,EAElD,CA1BsB,eAkCtB,kBAAkC,EAAyE,CAEvG,MAAO,AADU,MAAM,IAAiB,EAAI,KAAK,CAAC,GAClC,IACpB,CAHsB,oBAetB,kBAAgC,EAAe,EAAiD,CAC5F,GAAI,GAAS,EAAM,KAAK,EAElB,EAAO,EAAQ,MAAQ,QACvB,EAAQ,EAAQ,OAAS,GACzB,EAAQ,EAAQ,OAAS,GAE/B,GAAI,EAAO,SAAW,EAAG,KAAM,IAAI,OAAM,gCAAgC,EACzE,GAAI,EAAQ,IAAK,KAAM,IAAI,OAAM,4CAA4C,EAC7E,GAAI,EAAQ,EAAG,KAAM,IAAI,OAAM,0CAA0C,EACzE,GAAI,IAAS,SAAW,IAAS,SAAW,GAAQ,WAChD,KAAM,IAAI,OAAM,IAAI,sCAAyC,EAEjE,EAAS,mBAAmB,CAAM,EAClC,GAAM,GAAW,KAAM,GACnB,iCAAiC,QAAW,WAAgB,IAAQ,EAAQ,GAAK,aACrF,EAAE,MAAM,AAAC,GAAe,CAAG,EAE3B,GAAI,YAAoB,OAAO,KAAM,GAErC,GAAM,GAAW,KAAK,MAAM,CAAQ,EAEpC,GAAI,EAAS,MACT,KAAM,IAAI,OAAM,qBAAqB,EAAS,MAAM,SAAS,EAAS,MAAM,SAAS,EAGzF,GAAI,GAAoB,CAAC,EACzB,OAAQ,OACC,QACD,EAAU,EAAS,KAAK,IAAI,AAAC,GAAe,GAAI,GAAY,EAAO,EAAI,CAAC,EACxE,UACC,WACD,EAAU,EAAS,KAAK,IAAI,AAAC,GAAkB,GAAI,GAAe,EAAU,EAAI,CAAC,EACjF,UACC,QACD,EAAU,EAAS,KAAK,IAAI,AAAC,GAAe,GAAI,GAAY,EAAO,EAAI,CAAC,EACxE,MAGR,MAAO,EACX,CAxCsB,kBAyDtB,kBAA+C,EAA8D,CACzG,GAAM,GAAQ,EAAQ,OAAS,GAE/B,GAAI,EAAQ,IAAK,KAAM,IAAI,OAAM,4CAA4C,EAC7E,GAAI,EAAQ,EAAG,KAAM,IAAI,OAAM,0CAA0C,EAEzE,GAAM,GAAqB,CAAC,EAiB5B,GAhBI,EAAQ,QAAQ,EAAS,KAAK,WAAW,mBAAmB,EAAQ,OAAO,KAAK,CAAC,IAAI,EAErF,EAAQ,OAAO,EAAS,KAAK,UAAU,mBAAmB,EAAQ,MAAM,KAAK,CAAC,IAAI,EAElF,EAAQ,OAAO,EAAS,KAAK,UAAU,mBAAmB,EAAQ,MAAM,KAAK,CAAC,IAAI,EAElF,EAAQ,OAAO,EAAS,KAAK,UAAU,mBAAmB,EAAQ,MAAM,KAAK,CAAC,IAAI,EAEjF,MAAM,OAAO,EAAQ,gBAAgB,CAAC,GAAG,EAAS,KAAK,WAAW,EAAQ,kBAAkB,EAE5F,MAAM,OAAO,EAAQ,gBAAgB,CAAC,GAAG,EAAS,KAAK,WAAW,EAAQ,kBAAkB,EAE5F,MAAM,OAAO,EAAQ,MAAM,CAAC,GAAG,EAAS,KAAK,WAAW,EAAQ,QAAQ,EAExE,MAAM,OAAO,EAAQ,MAAM,CAAC,GAAG,EAAS,KAAK,WAAW,EAAQ,QAAQ,EAEzE,EAAS,SAAW,EAAG,KAAM,IAAI,OAAM,4CAA4C,EAEvF,GAAM,GAAW,KAAM,GAAQ,0CAA0C,EAAS,KAAK,GAAG,WAAW,GAAO,EAAE,MAC1G,AAAC,GAAe,CACpB,EAEA,GAAI,YAAoB,OAAO,KAAM,GAErC,GAAM,GAAW,KAAK,MAAM,CAAQ,EAEpC,GAAI,EAAS,MACT,KAAM,IAAI,OAAM,qBAAqB,EAAS,MAAM,SAAS,EAAS,MAAM,SAAS,EAKzF,MAFgB,GAAS,KAAK,IAAI,AAAC,GAAe,GAAI,GAAY,EAAO,EAAI,CAAC,CAGlF,CAxCsB,iCEpMtB,kBAA+B,EAAuB,CAClD,AAAI,EAAQ,SAAS,KAAM,IAAgB,EAAQ,OAAO,EACtD,EAAQ,YAAY,GAAmB,EAAQ,UAAU,EACzD,EAAQ,SAAS,GAAe,EAAQ,OAAO,EAC/C,EAAQ,WAAW,GAAa,EAAQ,SAAS,CACzD,CALsB,iBCoBtB,iDACA,0EAiCA,kBAAsB,EAAa,EAAyB,CAAC,EAA8C,CACvG,GAAM,GAAO,EAAI,KAAK,EACtB,GAAI,EAAK,SAAW,EAAG,KAAM,IAAI,OAAM,qDAAqD,EAC5F,GAAI,EAAQ,SAAU,MAAO,MAAM,IAAU,EAAM,CAAO,EAC1D,GAAI,EAAK,QAAQ,SAAS,IAAM,GAC5B,KAAM,IAAI,OACN,wHACJ,EAEJ,GAAI,EAAK,QAAQ,QAAQ,IAAM,GAC3B,KAAM,IAAI,OACN,uHACJ,EAEJ,MAAI,GAAK,QAAQ,YAAY,IAAM,GAAW,KAAM,IAAU,EAAM,EAAQ,OAAO,EACvE,KAAM,IAAU,EAAM,CAAO,CAC7C,CAhBe,eA+Ff,kBACI,EACA,EAAyB,CAAC,EAC8B,CACxD,AAAK,EAAQ,QAAQ,GAAQ,OAAS,CAAE,QAAS,OAAQ,GACzD,GAAM,GAAS,mBAAmB,EAAM,KAAK,CAAC,EAC9C,GAAI,EAAQ,OAAO,QACf,MAAO,MAAM,IAAU,EAAQ,CAC3B,MAAO,EAAQ,MACf,KAAM,EAAQ,OAAO,QACrB,SAAU,EAAQ,SAClB,qBAAsB,EAAQ,oBAClC,CAAC,EACA,GAAI,EAAQ,OAAO,QAAS,MAAO,MAAM,IAAU,EAAQ,EAAQ,OAAO,QAAS,EAAQ,KAAK,EAChG,GAAI,EAAQ,OAAO,WAAY,MAAO,MAAM,IAAU,EAAQ,EAAQ,OAAO,WAAY,EAAQ,KAAK,EACtG,GAAI,EAAQ,OAAO,OACpB,MAAO,MAAM,IAAU,EAAQ,CAAE,MAAO,EAAQ,MAAO,KAAM,EAAQ,OAAO,OAAQ,MAAO,EAAQ,KAAM,CAAC,EACzG,KAAM,IAAI,OAAM,4EAA4E,CACrG,CAlBe,eAkDf,kBACI,EACA,EAAyB,CAAC,EACe,CACzC,MAAI,aAAgB,GAAwB,KAAM,IAAe,EAAM,EAAQ,OAAO,EAC1E,KAAM,IAAe,EAAM,CAAO,CAClD,CANe,yBAoBf,kBACI,EAcF,CACE,GAAI,GACE,EAAO,EAAI,KAAK,EACtB,MAAK,GAAK,WAAW,OAAO,EACxB,EAAK,QAAQ,SAAS,IAAM,GAC5B,GAAQ,GAAY,CAAI,EACjB,IAAU,GAAU,MAAQ,EAAqD,IACjF,EAAK,QAAQ,YAAY,IAAM,GACtC,GAAQ,KAAM,IAAY,CAAI,EACvB,IAAU,GAAU,MAAQ,EAAwC,IACpE,EAAK,QAAQ,QAAQ,IAAM,GAClC,GAAQ,KAAM,IAAY,CAAI,EACvB,IAAU,GAAU,MAAQ,EAAqD,IAExF,GAAQ,EAAY,CAAI,EACjB,IAAU,GAAU,MAAQ,EAAwC,IAZzC,QAc1C,CAhCe,iBA8Cf,aAA+B,CAC3B,GAAM,GAAM,GAAgB,CACxB,MAAO,QAAQ,MACf,OAAQ,QAAQ,MACpB,CAAC,EACD,EAAI,SAAS,oDAAqD,AAAC,GAAQ,CACvE,GAAI,GACJ,GAAI,EAAI,YAAY,IAAM,MAAO,EAAO,WAC/B,EAAI,YAAY,IAAM,KAAM,EAAO,OACvC,CACD,QAAQ,IAAI,yCAAyC,EACrD,EAAI,MAAM,EACV,MACJ,CACA,EAAI,SAAS,qFAAsF,AAAC,GAAQ,CACxG,GAAI,EAAI,YAAY,EAAE,WAAW,IAAI,EAAG,CACpC,GAAI,GAAmB,EAAuB,EAAsB,EACpE,EAAI,SAAS,sCAAuC,AAAC,GAAO,CACxD,EAAY,EACZ,EAAI,SAAS,kCAAmC,AAAC,GAAW,CACxD,EAAgB,EAChB,EAAI,SAAS,iCAAkC,AAAC,GAAQ,CACpD,EAAe,EACf,QAAQ,IACJ;AAAA;AAAA;AAAA,CACJ,EACA,EAAI,SAAS,oDAAqD,AAAC,GAAQ,CACvE,AAAI,EAAI,SAAW,EAAG,EAAS,EAE3B,SAAQ,IACJ,6EACJ,EACA,EAAS,MAEb,QAAQ,IACJ;AAAA;AAAA,CACJ,EACA,QAAQ,IACJ,oDAAoD,qCAA6C,UAC7F,CACJ;AAAA,CACJ,EACA,EAAI,SAAS,yCAA0C,KAAO,IAAQ,CAClE,AAAK,GAAW,OAAO,GAAG,GAAU,OAAO,EAC3C,GAAM,GAAc,CAChB,YACA,gBACA,eACA,mBAAoB,EAAI,MAAM,OAAO,EAAE,GACvC,QACJ,EAEA,GAAI,AADU,KAAM,IAAiB,EAAa,CAAI,IACxC,GAAO,KAAM,IAAI,OAAM,6BAA6B,EAClE,EAAI,MAAM,CACd,CAAC,CACL,CAAC,CACL,CAAC,CACL,CAAC,CACL,CAAC,CACL,SAAW,EAAI,YAAY,EAAE,WAAW,IAAI,EAAG,CAC3C,GAAI,CAAC,EAAM,CACP,QAAQ,IAAI,oEAAoE,EAChF,EAAI,MAAM,EACV,MACJ,CACA,EAAI,SAAS,eAAgB,KAAO,IAAO,CACvC,GAAI,GAAY,EAChB,GAAI,CAAC,EAAW,CACZ,QAAQ,IAAI,8CAA8C,EAC1D,EAAI,MAAM,EACV,MACJ,CACA,AAAK,GAAW,OAAO,GAAG,GAAU,OAAO,EAC3C,QAAQ,IAAI,uCAAuC,EACnD,AAAI,KAAM,IAAS,CAAS,EACxB,SAAQ,IAAI,4CAA4C,EACxD,GAAc,wBAAyB,KAAK,UAAU,CAAE,WAAU,EAAG,OAAW,CAAC,CAAC,GAC/E,QAAQ,IAAI,2EAA2E,EAC9F,EAAI,MAAM,CACd,CAAC,CACL,SAAW,EAAI,YAAY,EAAE,WAAW,IAAI,EAAG,CAC3C,GAAI,CAAC,EAAM,CACP,QAAQ,IAAI,+DAA+D,EAC3E,EAAI,MAAM,EACV,MACJ,CACA,EAAI,SAAS,aAAc,AAAC,GAAiB,CACzC,GAAI,CAAC,GAAQ,EAAK,SAAW,EAAG,CAC5B,QAAQ,IAAI,2CAA2C,EACvD,EAAI,MAAM,EACV,MACJ,CACA,AAAK,GAAW,OAAO,GAAG,GAAU,OAAO,EAC3C,QAAQ,IAAI,sCAAsC,EAClD,GAAI,GAAiB,CAAC,EACtB,EAAK,MAAM,GAAG,EAAE,QAAQ,AAAC,GAAM,CAC3B,GAAM,GAAM,EAAE,MAAM,GAAG,EACvB,GAAI,EAAI,QAAU,EAAG,OACrB,GAAM,GAAM,EAAI,MAAM,GAAG,KAAK,EACxB,EAAQ,EAAI,KAAK,GAAG,EAAE,KAAK,EACjC,OAAO,OAAO,EAAQ,EAAG,GAAM,CAAM,CAAC,CAC1C,CAAC,EACD,GAAc,qBAAsB,KAAK,UAAU,CAAE,QAAO,EAAG,OAAW,CAAC,CAAC,EAC5E,EAAI,MAAM,CACd,CAAC,CACL,KACI,SAAQ,IAAI,yCAAyC,EACrD,EAAI,MAAM,CAElB,CAAC,CACL,CAAC,CACL,CA/GS,sBAuHT,YAAyB,EAAsB,EAA4C,CAIvF,GAAM,GAAY,EAAO,UAAU,MAAsB,EACzD,OAAW,KAAW,GAClB,AAAK,EAAgB,0BACjB,GAAQ,EACR,EAAO,eAAe,OAAwB,CAAuB,GAI7E,GAAM,GAAgB,MAAM,EAAS,MAAM,EAArB,iBAChB,EAAiB,MAAM,EAAS,OAAO,EAAtB,kBACjB,EAAe,MAAM,CACvB,EAAO,eAAe,SAA0B,CAAa,EAC7D,EAAO,eAAe,aAA8B,CAAa,EACjE,EAAO,eAAe,UAA2B,CAAc,CACnE,EAJqB,gBAKrB,EAAc,yBAA2B,GACzC,EAAe,yBAA2B,GAC1C,EAAa,yBAA2B,GACxC,EAAO,GAAG,SAA0B,CAAa,EACjD,EAAO,GAAG,aAA8B,CAAa,EACrD,EAAO,GAAG,UAA2B,CAAc,EACnD,EAAO,KAAK,OAAwB,CAAY,CACpD,CA1BS,wBAwET,GAAO,IAAQ,CACX,cACA,iBACA,cACA,qBACA,mBACA,kBACA,eACA,kBACA,eACA,iBACA,kBACA,eACA,mBACA,iBACA,gBACA,UACA,4BACA,eACA,aACA,mBACA,cACA,iBACA,gBACA,UACA,YACA,eACA,cACA,WACA,eACA,UACA,oBACA,YACA,oBACA,cACA,aACJ","names":[]}