{"version":3,"file":"SeekStream.js","sourceRoot":"","sources":["../../../play-dl/YouTube/classes/SeekStream.ts"],"names":[],"mappings":"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","sourcesContent":["import { IncomingMessage } from 'node:http';\nimport { request_stream } from '../../Request';\nimport { parseAudioFormats, StreamOptions, StreamType } from '../stream';\nimport { video_stream_info } from '../utils/extractor';\nimport { Timer } from './LiveStream';\nimport { WebmSeeker, WebmSeekerState } from './WebmSeeker';\n\n/**\n * YouTube Stream Class for seeking audio to a timeStamp.\n */\nexport class SeekStream {\n    /**\n     * WebmSeeker Stream through which data passes\n     */\n    stream: WebmSeeker;\n    /**\n     * Type of audio data that we recieved from normal youtube url.\n     */\n    type: StreamType;\n    /**\n     * Audio Endpoint Format Url to get data from.\n     */\n    private url: string;\n    /**\n     * Used to calculate no of bytes data that we have recieved\n     */\n    private bytes_count: number;\n    /**\n     * Calculate per second bytes by using contentLength (Total bytes) / Duration (in seconds)\n     */\n    private per_sec_bytes: number;\n    /**\n     * Length of the header in bytes\n     */\n    private header_length: number;\n    /**\n     * Total length of audio file in bytes\n     */\n    private content_length: number;\n    /**\n     * YouTube video url. [ Used only for retrying purposes only. ]\n     */\n    private video_url: string;\n    /**\n     * Timer for looping data every 265 seconds.\n     */\n    private timer: Timer;\n    /**\n     * Quality given by user. [ Used only for retrying purposes only. ]\n     */\n    private quality: number;\n    /**\n     * Incoming message that we recieve.\n     *\n     * Storing this is essential.\n     * This helps to destroy the TCP connection completely if you stopped player in between the stream\n     */\n    private request: IncomingMessage | null;\n    /**\n     * YouTube Stream Class constructor\n     * @param url Audio Endpoint url.\n     * @param type Type of Stream\n     * @param duration Duration of audio playback [ in seconds ]\n     * @param headerLength Length of the header in bytes.\n     * @param contentLength Total length of Audio file in bytes.\n     * @param bitrate Bitrate provided by YouTube.\n     * @param video_url YouTube video url.\n     * @param options Options provided to stream function.\n     */\n    constructor(\n        url: string,\n        duration: number,\n        headerLength: number,\n        contentLength: number,\n        bitrate: number,\n        video_url: string,\n        options: StreamOptions\n    ) {\n        this.stream = new WebmSeeker(options.seek!, {\n            highWaterMark: 5 * 1000 * 1000,\n            readableObjectMode: true\n        });\n        this.url = url;\n        this.quality = options.quality as number;\n        this.type = StreamType.Opus;\n        this.bytes_count = 0;\n        this.video_url = video_url;\n        this.per_sec_bytes = bitrate ? Math.ceil(bitrate / 8) : Math.ceil(contentLength / duration);\n        this.header_length = headerLength;\n        this.content_length = contentLength;\n        this.request = null;\n        this.timer = new Timer(() => {\n            this.timer.reuse();\n            this.loop();\n        }, 265);\n        this.stream.on('close', () => {\n            this.timer.destroy();\n            this.cleanup();\n        });\n        this.seek();\n    }\n    /**\n     * **INTERNAL Function**\n     *\n     * Uses stream functions to parse Webm Head and gets Offset byte to seek to.\n     * @returns Nothing\n     */\n    private async seek(): Promise<void> {\n        const parse = await new Promise(async (res, rej) => {\n            if (!this.stream.headerparsed) {\n                const stream = await request_stream(this.url, {\n                    headers: {\n                        range: `bytes=0-${this.header_length}`\n                    }\n                }).catch((err: Error) => err);\n\n                if (stream instanceof Error) {\n                    rej(stream);\n                    return;\n                }\n                if (Number(stream.statusCode) >= 400) {\n                    rej(400);\n                    return;\n                }\n                this.request = stream;\n                stream.pipe(this.stream, { end: false });\n\n                // headComplete should always be called, leaving this here just in case\n                stream.once('end', () => {\n                    this.stream.state = WebmSeekerState.READING_DATA;\n                    res('');\n                });\n\n                this.stream.once('headComplete', () => {\n                    stream.unpipe(this.stream);\n                    stream.destroy();\n                    this.stream.state = WebmSeekerState.READING_DATA;\n                    res('');\n                });\n            } else res('');\n        }).catch((err) => err);\n        if (parse instanceof Error) {\n            this.stream.emit('error', parse);\n            this.bytes_count = 0;\n            this.per_sec_bytes = 0;\n            this.cleanup();\n            return;\n        } else if (parse === 400) {\n            await this.retry();\n            this.timer.reuse();\n            return this.seek();\n        }\n        const bytes = this.stream.seek(this.content_length);\n        if (bytes instanceof Error) {\n            this.stream.emit('error', bytes);\n            this.bytes_count = 0;\n            this.per_sec_bytes = 0;\n            this.cleanup();\n            return;\n        }\n\n        this.stream.seekfound = false;\n        this.bytes_count = bytes;\n        this.timer.reuse();\n        this.loop();\n    }\n    /**\n     * Retry if we get 404 or 403 Errors.\n     */\n    private async retry() {\n        const info = await video_stream_info(this.video_url);\n        const audioFormat = parseAudioFormats(info.format);\n        this.url = audioFormat[this.quality].url;\n    }\n    /**\n     * This cleans every used variable in class.\n     *\n     * This is used to prevent re-use of this class and helping garbage collector to collect it.\n     */\n    private cleanup() {\n        this.request?.destroy();\n        this.request = null;\n        this.url = '';\n    }\n    /**\n     * Getting data from audio endpoint url and passing it to stream.\n     *\n     * If 404 or 403 occurs, it will retry again.\n     */\n    private async loop() {\n        if (this.stream.destroyed) {\n            this.timer.destroy();\n            this.cleanup();\n            return;\n        }\n        const end: number = this.bytes_count + this.per_sec_bytes * 300;\n        const stream = await request_stream(this.url, {\n            headers: {\n                range: `bytes=${this.bytes_count}-${end >= this.content_length ? '' : end}`\n            }\n        }).catch((err: Error) => err);\n        if (stream instanceof Error) {\n            this.stream.emit('error', stream);\n            this.bytes_count = 0;\n            this.per_sec_bytes = 0;\n            this.cleanup();\n            return;\n        }\n        if (Number(stream.statusCode) >= 400) {\n            this.cleanup();\n            await this.retry();\n            this.timer.reuse();\n            this.loop();\n            return;\n        }\n        this.request = stream;\n        stream.pipe(this.stream, { end: false });\n\n        stream.once('error', async () => {\n            this.cleanup();\n            await this.retry();\n            this.timer.reuse();\n            this.loop();\n        });\n\n        stream.on('data', (chunk: any) => {\n            this.bytes_count += chunk.length;\n        });\n\n        stream.on('end', () => {\n            if (end >= this.content_length) {\n                this.timer.destroy();\n                this.stream.end();\n                this.cleanup();\n            }\n        });\n    }\n    /**\n     * Pauses timer.\n     * Stops running of loop.\n     *\n     * Useful if you don't want to get excess data to be stored in stream.\n     */\n    pause() {\n        this.timer.pause();\n    }\n    /**\n     * Resumes timer.\n     * Starts running of loop.\n     */\n    resume() {\n        this.timer.resume();\n    }\n}\n"]}