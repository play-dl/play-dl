{"version":3,"file":"index.js","sourceRoot":"","sources":["../../play-dl/Deezer/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { URL } from 'node:url';\nimport { request, request_resolve_redirect } from '../Request';\nimport { DeezerAlbum, DeezerPlaylist, DeezerTrack } from './classes';\n\ninterface TypeData {\n    type: 'track' | 'playlist' | 'album' | 'search' | false;\n    id?: string;\n    error?: string;\n}\n\ninterface DeezerSearchOptions {\n    /**\n     * The type to search for `'track'`, `'playlist'` or `'album'`. Defaults to `'track'`.\n     */\n    type?: 'track' | 'playlist' | 'album';\n    /**\n     * The maximum number of results to return, maximum `100`, defaults to `10`.\n     */\n    limit?: number;\n    /**\n     * Whether the search should be fuzzy or only return exact matches. Defaults to `true`.\n     */\n    fuzzy?: boolean;\n}\n\ninterface DeezerAdvancedSearchOptions {\n    /**\n     * The maximum number of results to return, maximum `100`, defaults to `10`.\n     */\n    limit?: number;\n    /**\n     * The name of the artist.\n     */\n    artist?: string;\n    /**\n     * The title of the album.\n     */\n    album?: string;\n    /**\n     * The title of the track.\n     */\n    title?: string;\n    /**\n     * The label that released the track.\n     */\n    label?: string;\n    /**\n     * The minimum duration in seconds.\n     */\n    minDurationInSec?: number;\n    /**\n     * The maximum duration in seconds.\n     */\n    maxDurationInSec?: number;\n    /**\n     * The minimum BPM.\n     */\n    minBPM?: number;\n    /**\n     * The minimum BPM.\n     */\n    maxBPM?: number;\n}\n\nasync function internalValidate(url: string): Promise<TypeData> {\n    let urlObj;\n    try {\n        // will throw a TypeError if the input is not a valid URL so we need to catch it\n        urlObj = new URL(url);\n    } catch {\n        return { type: 'search' };\n    }\n\n    if (urlObj.protocol !== 'https:' && urlObj.protocol !== 'http:') {\n        return { type: 'search' };\n    }\n\n    let pathname = urlObj.pathname;\n    if (pathname.endsWith('/')) {\n        pathname = pathname.slice(0, -1);\n    }\n    const path = pathname.split('/');\n    switch (urlObj.hostname) {\n        case 'deezer.com':\n        case 'www.deezer.com': {\n            if (path.length === 4) {\n                const lang = path.splice(1, 1)[0];\n                if (!lang.match(/^[a-z]{2}$/)) {\n                    return { type: false };\n                }\n            } else if (path.length !== 3) {\n                return { type: false };\n            }\n\n            if ((path[1] === 'track' || path[1] === 'album' || path[1] === 'playlist') && path[2].match(/^\\d+$/)) {\n                return {\n                    type: path[1],\n                    id: path[2]\n                };\n            } else {\n                return { type: false };\n            }\n        }\n        case 'api.deezer.com': {\n            if (\n                path.length === 3 &&\n                (path[1] === 'track' || path[1] === 'album' || path[1] === 'playlist') &&\n                path[2].match(/^\\d+$/)\n            ) {\n                return {\n                    type: path[1],\n                    id: path[2]\n                };\n            } else {\n                return { type: false };\n            }\n        }\n        case 'deezer.page.link': {\n            if (path.length === 2 && path[1].match(/^[A-Za-z0-9]+$/)) {\n                const resolved = await request_resolve_redirect(url).catch((err) => err);\n\n                if (resolved instanceof Error) {\n                    return { type: false, error: resolved.message };\n                }\n\n                return await internalValidate(resolved);\n            } else {\n                return { type: false };\n            }\n        }\n        default:\n            return { type: 'search' };\n    }\n}\n\n/**\n * Shared type for Deezer tracks, playlists and albums\n */\nexport type Deezer = DeezerTrack | DeezerPlaylist | DeezerAlbum;\n\n/**\n * Fetches the information for a track, playlist or album on Deezer\n * @param url The track, playlist or album URL\n * @returns A {@link DeezerTrack}, {@link DeezerPlaylist} or {@link DeezerAlbum}\n * object depending on the provided URL.\n */\nexport async function deezer(url: string): Promise<Deezer> {\n    const typeData = await internalValidate(url.trim());\n\n    if (typeData.error) {\n        throw new Error(`This is not a Deezer track, playlist or album URL:\\n${typeData.error}`);\n    } else if (!typeData.type || typeData.type === 'search')\n        throw new Error('This is not a Deezer track, playlist or album URL');\n\n    const response = await request(`https://api.deezer.com/${typeData.type}/${typeData.id}`).catch((err: Error) => err);\n\n    if (response instanceof Error) throw response;\n\n    const jsonData = JSON.parse(response);\n\n    if (jsonData.error) {\n        throw new Error(`Deezer API Error: ${jsonData.error.type}: ${jsonData.error.message}`);\n    }\n\n    switch (typeData.type) {\n        case 'track':\n            return new DeezerTrack(jsonData, false);\n        case 'playlist':\n            return new DeezerPlaylist(jsonData, false);\n        case 'album':\n            return new DeezerAlbum(jsonData, false);\n    }\n}\n\n/**\n * Validates a Deezer URL\n * @param url The URL to validate\n * @returns The type of the URL either `'track'`, `'playlist'`, `'album'`, `'search'` or `false`.\n * `false` means that the provided URL was a wrongly formatted or an unsupported Deezer URL.\n */\nexport async function dz_validate(url: string): Promise<'track' | 'playlist' | 'album' | 'search' | false> {\n    const typeData = await internalValidate(url.trim());\n    return typeData.type;\n}\n\n/**\n * Searches Deezer for tracks, playlists or albums\n * @param query The search query\n * @param options Extra options to configure the search:\n *\n * * type?: The type to search for `'track'`, `'playlist'` or `'album'`. Defaults to `'track'`.\n * * limit?: The maximum number of results to return, maximum `100`, defaults to `10`.\n * * fuzzy?: Whether the search should be fuzzy or only return exact matches. Defaults to `true`.\n * @returns An array of tracks, playlists or albums\n */\nexport async function dz_search(query: string, options: DeezerSearchOptions): Promise<Deezer[]> {\n    let query_ = query.trim();\n\n    const type = options.type ?? 'track';\n    const limit = options.limit ?? 10;\n    const fuzzy = options.fuzzy ?? true;\n\n    if (query_.length === 0) throw new Error('A query is required to search.');\n    if (limit > 100) throw new Error('The maximum search limit for Deezer is 100');\n    if (limit < 1) throw new Error('The minimum search limit for Deezer is 1');\n    if (type !== 'track' && type !== 'album' && type != 'playlist')\n        throw new Error(`\"${type}\" is not a valid Deezer search type`);\n\n    query_ = encodeURIComponent(query_);\n    const response = await request(\n        `https://api.deezer.com/search/${type}/?q=${query_}&limit=${limit}${fuzzy ? '' : 'strict=on'}`\n    ).catch((err: Error) => err);\n\n    if (response instanceof Error) throw response;\n\n    const jsonData = JSON.parse(response);\n\n    if (jsonData.error) {\n        throw new Error(`Deezer API Error: ${jsonData.error.type}: ${jsonData.error.message}`);\n    }\n\n    let results: Deezer[] = [];\n    switch (type) {\n        case 'track':\n            results = jsonData.data.map((track: any) => new DeezerTrack(track, true));\n            break;\n        case 'playlist':\n            results = jsonData.data.map((playlist: any) => new DeezerPlaylist(playlist, true));\n            break;\n        case 'album':\n            results = jsonData.data.map((album: any) => new DeezerAlbum(album, true));\n            break;\n    }\n\n    return results;\n}\n\n/**\n * Searches Deezer for tracks using the specified metadata.\n * @param options The metadata and limit for the search\n *\n * * limit?: The maximum number of results to return, maximum `100`, defaults to `10`.\n * * artist?: The name of the artist\n * * album?: The title of the album\n * * title?: The title of the track\n * * label?: The label that released the track\n * * minDurationInSec?: The minimum duration in seconds\n * * maxDurationInSec?: The maximum duration in seconds\n * * minBpm?: The minimum BPM\n * * maxBpm?: The minimum BPM\n * @returns An array of tracks matching the metadata\n */\nexport async function dz_advanced_track_search(options: DeezerAdvancedSearchOptions): Promise<DeezerTrack[]> {\n    const limit = options.limit ?? 10;\n\n    if (limit > 100) throw new Error('The maximum search limit for Deezer is 100');\n    if (limit < 1) throw new Error('The minimum search limit for Deezer is 1');\n\n    const metadata: string[] = [];\n    if (options.artist) metadata.push(`artist:\"${encodeURIComponent(options.artist.trim())}\"`);\n\n    if (options.album) metadata.push(`album:\"${encodeURIComponent(options.album.trim())}\"`);\n\n    if (options.title) metadata.push(`track:\"${encodeURIComponent(options.title.trim())}\"`);\n\n    if (options.label) metadata.push(`label:\"${encodeURIComponent(options.label.trim())}\"`);\n\n    if (!isNaN(Number(options.minDurationInSec))) metadata.push(`dur_min:${options.minDurationInSec}`);\n\n    if (!isNaN(Number(options.maxDurationInSec))) metadata.push(`dur_max:${options.maxDurationInSec}`);\n\n    if (!isNaN(Number(options.minBPM))) metadata.push(`bpm_min:${options.minBPM}`);\n\n    if (!isNaN(Number(options.maxBPM))) metadata.push(`bpm_max:${options.maxBPM}`);\n\n    if (metadata.length === 0) throw new Error('At least one type of metadata is required.');\n\n    const response = await request(`https://api.deezer.com/search/track/?q=${metadata.join(' ')}&limit=${limit}`).catch(\n        (err: Error) => err\n    );\n\n    if (response instanceof Error) throw response;\n\n    const jsonData = JSON.parse(response);\n\n    if (jsonData.error) {\n        throw new Error(`Deezer API Error: ${jsonData.error.type}: ${jsonData.error.message}`);\n    }\n\n    const results = jsonData.data.map((track: any) => new DeezerTrack(track, true));\n\n    return results;\n}\n\nexport { DeezerTrack, DeezerAlbum, DeezerPlaylist };\n"]}